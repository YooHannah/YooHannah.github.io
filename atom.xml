<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Little World</title>
  
  <subtitle>learn and share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoohannah.github.io/"/>
  <updated>2024-09-30T09:32:39.027Z</updated>
  <id>http://yoohannah.github.io/</id>
  
  <author>
    <name>YooHannah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决策树模型</title>
    <link href="http://yoohannah.github.io/post/machineLearning/decisionTreeModel.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/decisionTreeModel.html</id>
    <published>2024-09-30T07:31:37.000Z</published>
    <updated>2024-09-30T09:32:39.027Z</updated>
    
    <content type="html"><![CDATA[<p>决策树模型是通过计算特征纯度后，选取最大纯度值的特征作为决策节点，<br>将数据根据是否符合当前特征节点一份为二，再根据特征纯度，继续划分，<br>最后根据停止划分规则进行数据分类或推测的模型</p><p><img src="/image/LLM/136.png" alt></p><h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><p>决策树创建过程需要考虑两件事</p><ol><li><p>在每个节点上如果选择根据什么特征进行数据分类<br>Maximize purity<br>如果一个特征在把数据分成两组之后，使分组后的数据能够最大程度的趋于同一类，那么这个特征就是纯度高的特征,<br>即 如果这个特征能够直接决定数据属于哪个分类的程度越高，纯度就越高<br>比如用DNA特征判断猫狗分类比用耳朵是尖的还是软的更直接，DNA特征就是最大纯度的特征<br><img src="/image/LLM/137.png" alt></p></li><li><p>什么时候停止数据分类<br>a. 当一个节点里面的数据都属于同一类的时候<br>b. 到达树的深度最大值的时候，树越深，过拟合越有可能，计算成本越高<br>c. 当特征纯度(熵)低于某个阈值的时候<br>d. 当节点里的数据个数低于某个阈值的时候</p></li></ol><p><img src="/image/LLM/138.png" alt></p><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>可以理解为数据的混乱程度，如果数据特别混乱，则值越大，返回数据如果种类单一，则值越小，趋近0<br>这里用熵来计算特征的非纯度或者较杂质程度，<br>如果根据某个特征分类后的数据的熵 越小，说数据越干净，杂质越少<br>反之，如果得到的熵越大，说数据越混乱，不同类的数据越多<br>如下面判断是否是猫的问题<br>p1 代表是每组数据中猫的比例，都是猫或狗的话熵 是0，5:5 的时候熵 最大值为1，数据最混乱<br><img src="/image/LLM/139.png" alt><br>具体熵 的计算公式如下<br><img src="/image/LLM/140.png" alt></p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>在了解熵的含义后，用下面的计算过程选择节点的判断特征<br>根节点的熵减去分类后两个节点熵的加权平均值，值越大说明分类后数据越纯了<br><img src="/image/LLM/141.png" alt><br>这个计算方式得到的值就叫信息增益<br>即特征信息增益越大，在分类过程中，能够把数据分的越纯<br><img src="/image/LLM/142.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>决策树学习过程<br><img src="/image/LLM/143.png" alt><br>对于每个节点，都要像对待根节点一样<br>根据拿到的数据先找到最大信息增益的特征然后进行分类<br>整个过程就是一个递归的过程，直到满足停止分类的规则为止<br><img src="/image/LLM/144.png" alt></p><h1 id="多特征值处理办法"><a href="#多特征值处理办法" class="headerlink" title="多特征值处理办法"></a>多特征值处理办法</h1><h2 id="one-hot"><a href="#one-hot" class="headerlink" title="one-hot"></a>one-hot</h2><p>If a categorical feature can take on 𝑘 values, create 𝑘 binary features (0 or 1 valued).<br>如果一个特征有大于2个以上的N可枚举值，那么将当前特征拆分成N个新的代表相应枚举值的特征即可<br><img src="/image/LLM/145.png" alt></p><h2 id="连续值"><a href="#连续值" class="headerlink" title="连续值"></a>连续值</h2><p>如果一个特质的值是连续值，不可枚举，那么需要设定一个阈值，大于该阈值一类，小于则是另一类，从而实现对该特征的二分类<br>阈值的选取还是通过计算信息增益，选取能够使信息增益值最大的阈值参与分类<br><img src="/image/LLM/146.png" alt></p><h1 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h1><p>上面是使用决策树进行分类计算<br>接下来使用方差对连续数据进行推测，就是回归树<br>如下图，根据前三个特征，推测weight 的值，weight 是个连续的值，不能枚举的<br><img src="/image/LLM/147.png" alt></p><p><img src="/image/LLM/148.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;决策树模型是通过计算特征纯度后，选取最大纯度值的特征作为决策节点，&lt;br&gt;将数据根据是否符合当前特征节点一份为二，再根据特征纯度，继续划分，&lt;br&gt;最后根据停止划分规则进行数据分类或推测的模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/LLM/136.png&quot; alt
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>机器学习开发过程</title>
    <link href="http://yoohannah.github.io/post/machineLearning/MachineLearningDevelopmentProcess.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/MachineLearningDevelopmentProcess.html</id>
    <published>2024-09-29T08:39:37.000Z</published>
    <updated>2024-09-30T07:35:43.314Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/LLM/123.png" alt></p><p>整个开发过程是一个选择框架，训练模型，诊断模型循环的过程</p><h1 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h1><p>除了从高偏差高误差角度对模型进行分析外，还可以对mcv 产生错误分类的角度对模型进行分析<br><img src="/image/LLM/125.png" alt></p><p>可以从交叉验证集测试产生的错误中进行分析<br>通过将错误进行归类统计，找出对模型影响比例较大的错误和比例较小的错误<br>从而调整模型训练的方向，已解决上面遇到的问题<br><img src="/image/LLM/124.png" alt></p><p>如果交叉验证集产生错误的数据比较庞大，可以选择进行随机抽取一定小批量的数据进行错误分类，以节省人力</p><h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><p>通过引入更多数据完善模型的判断，更关注通过注入的数据引发的对模型的训练结果的影响</p><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><p>Augmentation: modifying an existing training example to create a new training example.<br>在原有数据基础上，通过添加特定种类的噪声，形成新的测试数据，从而完善特定种类的错误判断<br>对于图片和音频数据都适用<br><img src="/image/LLM/126.png" alt><br>但是对添加随机或者无意义噪声产生的数据进行训练，对于模型训练不会有多大帮助</p><h2 id="数据合成"><a href="#数据合成" class="headerlink" title="数据合成"></a>数据合成</h2><p>Synthesis: using artificial data inputs to create a new training example.<br>直接由计算机合成训练过程中使用的数据，通常用于计算机视觉训练的场景<br><img src="/image/LLM/127.png" alt></p><h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p>在已有大模型训练结果基础上，通过修改输出层结果使之符合自己使用场景的训练方法<br>好处是，在数据有限的情况下，可以直接使用输出层之前的参数开始训练，减少自己从头开始训练的工作</p><p>例如下面这个使用1000+分类的训练识别数字0-9的模型，只是在输出层将1000+ 输出改成10种输出，在此基础上开始训练<br><img src="/image/LLM/128.png" alt><br>一般训练步骤为下载相同输入(文本的下载文本的，音视频的下载音视频的)的预训练模型，然后用自己的数据进行训练(fine tuning)<br><img src="/image/LLM/129.png" alt></p><h1 id="完整开发流程"><a href="#完整开发流程" class="headerlink" title="完整开发流程"></a>完整开发流程</h1><p><img src="/image/LLM/130.png" alt></p><h2 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h2><p>通常应用层跟模型通过Api 进行通信，用户输入x， 模型返回预测值y^<br>软件工程师需要注意</p><ol><li>尽可能的保障低成本的计算出具有可靠性和有效性的预测结果</li><li>可以进行大规模用户扩展使用</li><li>在用户隐私允许同意的情况下进行日志记录输入和输出</li><li>对模型进行系统监控，比如根据上面日志的记录，计算出因为当前数据变化导致计算结果不准时，判断是否让模型进行进一步优化</li><li>保障模型更新，在上一步进行模型优化后要保证能够将老的模型替换成新模型</li></ol><p><img src="/image/LLM/131.png" alt></p><h1 id="避免道德偏见伦理问题"><a href="#避免道德偏见伦理问题" class="headerlink" title="避免道德偏见伦理问题"></a>避免道德偏见伦理问题</h1><ol><li>建议多元化(多背景，多种族)团队，上线前进行头脑风暴，探索可能对弱势群体造成伤害的可能</li><li>参考行业标准</li><li>上线前通过技术诊断产生的伤害可能性，从而决策是否可以上线</li><li>制定延缓计划，上线后观测可能产生的伤害，及时进行回滚处理<br><img src="/image/LLM/132.png" alt></li></ol><h1 id="二分类错误度量"><a href="#二分类错误度量" class="headerlink" title="二分类错误度量"></a>二分类错误度量</h1><p>在对倾斜数据集(y=1 和y = 0 所占比例不是5:5)进行训练时，<br>判断模型预测结果好坏通常交叉验证集的数据计算精确率和召回率两个指标衡量<br><img src="/image/LLM/133.png" alt><br>如果二者都趋近0或1时，说明当前的模型不是一个有用的模型，一直在打印0或1<br>只有二者值都很大时，才说明算法是有用的</p><p>精确率表示实际上y = 1的可能性<br>召回率表示模型计算出y = 1 的可能性</p><h2 id="对于精确率和召回率的衡量"><a href="#对于精确率和召回率的衡量" class="headerlink" title="对于精确率和召回率的衡量"></a>对于精确率和召回率的衡量</h2><p>一种是通过设置阈值大小去权衡二者，从而进行取舍<br>提高阈值，会增加精度，降低召回率<br>降低阈值，会降低精度，提高召回率<br><img src="/image/LLM/134.png" alt><br>另外一种是使用F1 score分数，自动计算出最佳的精度和召回率，从而选择对应的算法<br><img src="/image/LLM/135.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/image/LLM/123.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程是一个选择框架，训练模型，诊断模型循环的过程&lt;/p&gt;
&lt;h1 id=&quot;错误分析&quot;&gt;&lt;a href=&quot;#错误分析&quot; class=&quot;headerlink&quot; title=&quot;错误分析&quot;&gt;
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>高偏差和高方差</title>
    <link href="http://yoohannah.github.io/post/machineLearning/biasVariance.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/biasVariance.html</id>
    <published>2024-09-27T09:39:37.000Z</published>
    <updated>2024-09-29T08:24:23.070Z</updated>
    
    <content type="html"><![CDATA[<p>通过判断高方差和高偏差的大小可以判断模型的性能问题<br>一般有以下两个性能问题<br>高偏差意味着模型欠拟合<br>高方差意味着模型过拟合</p><p>高偏差的情况下，<br>Jtrain 值会比较大，且Jtrain和Jcv 值相近<br>也就是说Jtrain 较高对应的训练数据的拟合度本身就不够</p><p>高方差的情况下，<br>Jcv 会远大于Jtrain, Jtrain 值可能比较小<br>就是说模型对训练数据很拟合，但是对交叉验证数据不够拟合</p><p>也有高方差和高偏差两个问题同时存在的情况<br>Jtrain 值会比较大，且Jcv 远大于Jtrain,<br>这种情况意味着模型可能对一些数据过拟合，对一些数据又存在欠拟合</p><p><img src="/image/LLM/109.png" alt></p><h1 id="正则化参数𝜆-对模型的影响"><a href="#正则化参数𝜆-对模型的影响" class="headerlink" title="正则化参数𝜆 对模型的影响"></a>正则化参数𝜆 对模型的影响</h1><p>如果𝜆偏大会导致Jtrain 偏大，出现欠拟合<br>(想象𝜆现在是一个非常大的数值，为使Jtrain 最小，就会让w值逐渐趋近0, 最终模型无限接近b)<br>如果𝜆偏小会导致Jtrain 偏小，但是Jcv 偏大，出现过拟合<br>(想象𝜆现在无限趋近于0，或者直接等于0， 那么要使Jtrain 最小，w取值就得变大，多项式就会被保留，最终模型出现过拟合)<br>如果𝜆取值适中就可以实现Jtrain和Jcv 值都偏低，模型适当拟合的效果<br><img src="/image/LLM/110.png" alt></p><h2 id="𝜆-如何取值"><a href="#𝜆-如何取值" class="headerlink" title="𝜆 如何取值"></a>𝜆 如何取值</h2><p>通过选取不同 𝜆 带入计算最小损失函数，用得到的(w,b)值计算Jcv, 选取多组Jcv 中 最小值的(w,b)进行Jtest 计算，<br><img src="/image/LLM/111.png" alt></p><h2 id="𝜆-趋势图"><a href="#𝜆-趋势图" class="headerlink" title="𝜆 趋势图"></a>𝜆 趋势图</h2><p>𝜆 对于误差的影响趋势和多项式对误差的影响趋势呈镜像关系<br>𝜆 值从小到大，Jtrain 从小到大，模型从过拟合到欠拟合<br>多项式平方数从小到大，Jtrain 从大到小， 模型从欠拟合到过拟合<br><img src="/image/LLM/112.png" alt></p><h1 id="建立性能基准线来判断模型性能"><a href="#建立性能基准线来判断模型性能" class="headerlink" title="建立性能基准线来判断模型性能"></a>建立性能基准线来判断模型性能</h1><p>计算基准线与Jtrain 的差A， A 如果偏大说明模型存在高偏差欠拟合问题<br>计算Jtrain 与 Jcv 的差B，B 如果偏大说明存在高方差过拟合问题<br>如果A 大于B 说明存在高偏差，欠拟合<br>如果A 小于B 说明存在高方差，过拟合<br>如果A 和 B 数值接近，说明 高偏差和高方差同时存在<br><img src="/image/LLM/115.png" alt><br>基准线可以来自<br>人类的测试水平<br>竞争算法的性能水平<br>基于过程经验判断的水平<br><img src="/image/LLM/114.png" alt><br>以 语音识别为例<br><img src="/image/LLM/113.png" alt></p><h1 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h1><p>Jtrain 和Jcv 随 训练集大小m变化的趋势曲线被称为学习曲线</p><p>一般情况下，<br>Jtrain 会随m 变大逐渐变大，因为为了拟合更多数据，数据比一定会散落在曲线上，误差累加起来数值会变大<br>Jcv 会随m 变大逐渐变小，因为更多的数据可以展示更多的情况，是模型拟合度更高，对于Jcv 计算就是越小<br><img src="/image/LLM/116.png" alt></p><p>但是对于存在高偏差的模型，增加样本数量并不一定能对模型拟合产生多大帮助，<br>因为高偏差模型具备欠拟合特点，随样本数增加损失函数也会增加，且相对基本线误差依然存在<br><img src="/image/LLM/117.png" alt></p><p>对于存在高方差的模型，增加样本数量可以起到一定帮助<br>因为高方差模型具体过拟合特点，会将增加的样本继续拟合到自己的训练模型中，相当容纳近了更多的数据情况<br>可以更好的拟合实际的情况<br><img src="/image/LLM/118.png" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>高偏差和高方差的一些解决方案<br><img src="/image/LLM/119.png" alt></p><h1 id="神经网络中的应用"><a href="#神经网络中的应用" class="headerlink" title="神经网络中的应用"></a>神经网络中的应用</h1><p>神经网络是低偏差的模型，<br>在训练过程中如果Jtrain 过大可以使用更大的神经网络，缺点就是运算速度会变低且会增加研发成本<br>在Jtrain 基本与基准线相差不大时计算Jvc，如果Jvc 过大可以增加数据样本重新回到模型计算<br>经过上面不断重复的过程，最终得到合适的模型参数<br><img src="/image/LLM/120.png" alt><br>只要数据规则化做的合适，大型神经网络总是会比小型神经网络表现好一些<br><img src="/image/LLM/121.png" alt><br>在tensorFlow 中，可以在构建layer 时传入规则化参数<br><img src="/image/LLM/122.png" alt></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>练习多项式，正则化参数𝜆，训练数据个数m, 神经网络层数<br><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Advanced%20Learning%20Algorithms/week3/8.Practice%20Lab%20Advice%20for%20applying%20machine%20learning/C2_W3_Assignment.ipynb#scrollTo=3tnHtCF35uzg" target="_blank" rel="noopener">链接</a></p><p>The simple model is a bit better in the training set than the regularized model but it worse in the cross validation set.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过判断高方差和高偏差的大小可以判断模型的性能问题&lt;br&gt;一般有以下两个性能问题&lt;br&gt;高偏差意味着模型欠拟合&lt;br&gt;高方差意味着模型过拟合&lt;/p&gt;
&lt;p&gt;高偏差的情况下，&lt;br&gt;Jtrain 值会比较大，且Jtrain和Jcv 值相近&lt;br&gt;也就是说Jtrain 较高对应
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>一些其他的概念</title>
    <link href="http://yoohannah.github.io/post/machineLearning/advanceOpt.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/advanceOpt.html</id>
    <published>2024-09-25T08:27:37.000Z</published>
    <updated>2024-09-27T09:40:41.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adam-Algorithm"><a href="#Adam-Algorithm" class="headerlink" title="Adam Algorithm"></a>Adam Algorithm</h1><p>一种加快模型学习的优化算法<br> 可以自动调节学习率的大小，使模型更快的朝梯度下降的方向学习<br> <img src="/image/LLM/96.png" alt><br> <img src="/image/LLM/97.png" alt><br> <img src="/image/LLM/98.png" alt></p><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><p> 之前讨论的神经网络中的中间层，都依赖上一层所有的输出进行计算<br> Each neuron output is a function of<br> all the activation outputs of the previous layer.<br> 有一种计算方案是只选取上一层的部分数据计算本层的输出<br> 这种layer 被称为卷积层（Convolutional Layer）<br> 优点有两个<br> 一个是可以加快计算，<br> 另外一个是可以减少需要的训练数据</p><p>  <img src="/image/LLM/99.png" alt></p><h1 id="降低预测结果错误率"><a href="#降低预测结果错误率" class="headerlink" title="降低预测结果错误率"></a>降低预测结果错误率</h1><p>拿到训练模型后，如果遇到一个不可接受的错误输出，可以通过以下方式进行重新调整<br><img src="/image/LLM/100.png" alt></p><p>更常见的方式是用诊断的方式评估模型好坏<br>在训练前将数据分成两组，<br>一组用于模型训练，称为训练组<br>另一组用于测试训练得到的模型，称为测试组</p><p>比如对于过拟合的情况<br>将数据分成两组<br><img src="/image/LLM/101.png" alt><br>分别计算训练组和测试组的损失函数<br><img src="/image/LLM/102.png" alt><br>对于训练组数据的损失函数肯定会更小<br>要关注的是测试数据的损失函数，值越小，说明越近真实的值，说明模型越好<br>上面是线性回归模型，下面是对于分类问题的损失函数计算<br><img src="/image/LLM/103.png" alt></p><p><img src="/image/LLM/104.png" alt></p><p>如果需要在多个模型间进行选择，可以在一开始的时候将数据分成三组<br>训练组，交叉验证组，测试组</p><p>同样计算基于交叉验证组数据的损失函数，值越小说明越符合实际数据<br>主要作用是用于选择模型，比如挑出最合适的多项式</p><p>然后再使用测试组数据进行泛化错误的测试</p><p><img src="/image/LLM/105.png" alt><br><img src="/image/LLM/106.png" alt><br><img src="/image/LLM/107.png" alt><br><img src="/image/LLM/108.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Adam-Algorithm&quot;&gt;&lt;a href=&quot;#Adam-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Adam Algorithm&quot;&gt;&lt;/a&gt;Adam Algorithm&lt;/h1&gt;&lt;p&gt;一种加快模型学习的优化算法&lt;br&gt; 可以自动
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>多分类问题</title>
    <link href="http://yoohannah.github.io/post/machineLearning/softMax.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/softMax.html</id>
    <published>2024-09-25T08:27:37.000Z</published>
    <updated>2024-09-25T11:55:02.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Softmax-regression"><a href="#Softmax-regression" class="headerlink" title="Softmax regression"></a>Softmax regression</h1><p>之前的二分类问题用logic regression 可以解决，<br>但是对于多分类问题，可以在此基础上，遵循所有可能性加和为1的原则<br>进行扩展</p><p>假如现在需要判断4种可能性的概率<br>那我们需要四条分界线（如下图在z1-z4）<br>然后通过通过下面这个公式<br><img src="/image/LLM/87.png" alt><br>计算得到a1 - a4<br>就可以得到4种可能性的概率</p><p>这种算法就是 Softmax regression<br><img src="/image/LLM/86.png" alt></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>参照逻辑回归函数的损失函数<br>假如y = 1, 那么损失函数就是<br><img src="/image/LLM/88.png" alt><br>y = 0 的话损失函数就是<br><img src="/image/LLM/89.png" alt></p><p>归纳一下就是，当y = an时<br>损失函数就是Loss = -log(an)<br>因为 y 只能可能是a1-an N 种可能性中的一种<br>下面的Loss趋势图说明，当an 值越接近1 的时候 损失函数越小<br>也就是说a1 - an 这些概率值越接近1 损失函数越小<br>相当于概率值对应的可能性越可能接近真实y值，越准<br><img src="/image/LLM/90.png" alt></p><h2 id="在神经网络中使用"><a href="#在神经网络中使用" class="headerlink" title="在神经网络中使用"></a>在神经网络中使用</h2><p>之前的二分类问题中，在神经网络的最后一层使用sigmoid 函数作为输出函数（或者激活函数）可以识别图片中的 0 和 1<br>现在如果要识别图片中的数字是0-9 10种分类中的哪一种，<br>要做的就是将输出层激活函数换成softmax 函数，并且是10个节点就可以实现<br>每个节点代表一种可能，值最大的就是可能性最大的值</p><p><img src="/image/LLM/91.png" alt></p><h2 id="tensorFlow-中实现"><a href="#tensorFlow-中实现" class="headerlink" title="tensorFlow 中实现"></a>tensorFlow 中实现</h2><p>方案1<br><img src="/image/LLM/92.png" alt><br>不推荐，用方案2优化</p><p>方案2<br><img src="/image/LLM/93.png" alt></p><p>原因是在tensorFlow 中使用中间步骤计算数值和直接将式子带入计算最终值的处理过程不同，tensorflow 会对后者重新排列表达式中的术语<br>并想出一种更准确的计算方式去计算，方案二在方案一基础上做的修改就是在将式子带入计算，而不是先计算中间值，再带入</p><h1 id="区别多标签多分类问题"><a href="#区别多标签多分类问题" class="headerlink" title="区别多标签多分类问题"></a>区别多标签多分类问题</h1><p>上面讨论的是多分类问题，一个问题多个可能性<br> 多标签多分类问题是指同时推测多个问题的多个可能性<br><img src="/image/LLM/94.png" alt><br> 计算方式可以是分别看成单个神经网络计算，一个神经网络处理一个问题的多种可能<br> 也可以同时计算，输出多个问题对应的多个可能<br> <img src="/image/LLM/95.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Softmax-regression&quot;&gt;&lt;a href=&quot;#Softmax-regression&quot; class=&quot;headerlink&quot; title=&quot;Softmax regression&quot;&gt;&lt;/a&gt;Softmax regression&lt;/h1&gt;&lt;p&gt;之前的二分类
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://yoohannah.github.io/post/machineLearning/neuralNetworks.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/neuralNetworks.html</id>
    <published>2024-09-20T09:27:37.000Z</published>
    <updated>2024-09-23T14:08:48.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h1><p>类似于大脑中的神经元传递信息的过程，将多个输入通过多层模型处理后得到结果输出的架构，就是神经网络</p><p><img src="/image/LLM/67.png" alt><br><img src="/image/LLM/68.png" alt><br><img src="/image/LLM/69.png" alt></p><p>复杂神经网络的表示<br><img src="/image/LLM/70.png" alt><br>从预测手写数据0和1 的过程，理解神经网络向前传播的计算原理<br><img src="/image/LLM/71.png" alt></p><p>The parameters have dimensions that are sized for a neural network with  25  units in layer 1,  15  units in layer 2 and  1  output unit in layer 3.<br>the dimensions of these parameters are determined as follows:<br>If network has  𝑠𝑖𝑛  units in a layer and  𝑠𝑜𝑢𝑡  units in the next layer, then<br>𝑊  will be of dimension  𝑠𝑖𝑛×𝑠𝑜𝑢𝑡 .<br>𝑏  will a vector with  𝑠𝑜𝑢𝑡  elements<br>Therefore, the shapes of W, and b, are<br>layer1: The shape of W1 is (400, 25) and the shape of b1 is (25,)<br>layer2: The shape of W2 is (25, 15) and the shape of b2 is: (15,)<br>layer3: The shape of W3 is (15, 1) and the shape of b3 is: (1,)<br>Note: The bias vector b could be represented as a 1-D (n,) or 2-D (n,1) array. Tensorflow utilizes a 1-D representation and this lab will maintain that convention.</p><p>向前传播：从左到右计算，根据输入计算出输出，输出即预测结果，<br><img src="/image/LLM/72.png" alt></p><p>使用tensorflow 实现向前传播的神经网络<br><img src="/image/LLM/73.png" alt></p><p>具体实现<br><img src="/image/LLM/77.png" alt><br><img src="/image/LLM/78.png" alt><br><img src="/image/LLM/76.png" alt></p><p>Tensorflow models are built layer by layer. A layer’s input dimensions ( 𝑠𝑖𝑛  above) are calculated for you. You specify a layer’s output dimensions and this determines the next layer’s input dimension. The input dimension of the first layer is derived from the size of the input data specified in the model.fit statment below.</p><p>Note: It is also possible to add an input layer that specifies the input dimension of the first layer. For example:<br>tf.keras.Input(shape=(400,)), #specify input shape<br>We will include that here to illuminate some model sizing.</p><p>调用numpy()方法可以实现张量和numpy matrix 之间的转换<br><img src="/image/LLM/74.png" alt><br>使用tensorflow 实现神经网络的另外一种架构形式<br><img src="/image/LLM/75.png" alt></p><p>The model.compile statement defines a loss function and specifies a compile optimization.<br>The model.fit statement runs gradient descent and fits the weights to the data.</p><p><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Advanced%20Learning%20Algorithms/week1/9.Practice%20Lab%20Neural%20networks/C2_W1_Assignment.ipynb#scrollTo=qI3g3oYtRTZp" target="_blank" rel="noopener">图片识别0和1练习</a></p><h1 id="神经网络的训练过程"><a href="#神经网络的训练过程" class="headerlink" title="神经网络的训练过程"></a>神经网络的训练过程</h1><p><img src="/image/LLM/78.png" alt><br><img src="/image/LLM/79.png" alt><br><img src="/image/LLM/80.png" alt><br><img src="/image/LLM/81.png" alt><br><img src="/image/LLM/82.png" alt><br><img src="/image/LLM/83.png" alt></p><h2 id="如何选择激活函数"><a href="#如何选择激活函数" class="headerlink" title="如何选择激活函数"></a>如何选择激活函数</h2><p>常见的三种激活函数<br><img src="/image/LLM/84.png" alt></p><p>选择激活函数的一般规则<br>对于输出层，根据输出值来<br>如果是二分类问题，使用sigmoid<br>如果是输出正负值都有就选则线性激活函数<br>如果输出值非负，那么 就使用ReLu函数<br>对于中间层，一律使用ReLu函数<br>原因有三</p><ol><li>一个是作为激活函数，本身计算过程比sigmoid 函数简单</li><li>relu只有在小于0 的时候斜率为0，sigmoid 函数在趋向正负无穷的时候有两处斜率趋近0 的情况，会导致梯度下降计算过程变慢，所以ReLu函数在梯度下降过程相比之下会更快一些</li><li>如果在隐藏层使用线性激活函数，输出层是sigmoid函数，整个过程等同于线性回归，最终始终会变成二分类的结果</li></ol><p><img src="/image/LLM/85.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是神经网络&quot;&gt;&lt;a href=&quot;#什么是神经网络&quot; class=&quot;headerlink&quot; title=&quot;什么是神经网络&quot;&gt;&lt;/a&gt;什么是神经网络&lt;/h1&gt;&lt;p&gt;类似于大脑中的神经元传递信息的过程，将多个输入通过多层模型处理后得到结果输出的架构，就是神经网络&lt;/
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>解决过拟合问题</title>
    <link href="http://yoohannah.github.io/post/machineLearning/overfitting.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/overfitting.html</id>
    <published>2024-09-17T13:05:37.000Z</published>
    <updated>2024-09-19T10:47:00.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是过拟合"><a href="#什么是过拟合" class="headerlink" title="什么是过拟合"></a>什么是过拟合</h1><p>训练得到的预测模型对于每个训练数据都非常吻合，导致对于新的测试数据无法正确评估的想象，就是过拟合<br>下面是线性回归和逻辑回归模型三种训练结果的展示<br><img src="/image/LLM/57.png" alt><br><img src="/image/LLM/58.png" alt></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol><li>收集更多的数据进行训练</li><li>选择和使用有价值的特性值参与运算</li><li>减小部分特征值(对于结果预测关系不大的特征值)的参数值（正则化）</li></ol><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>在成本函数或者损失函数中增加正则化参数，避免过拟合<br><img src="/image/LLM/59.png" alt></p><p>在梯度下降计算过程中，会使得每个参数在原来基础上乘以一个比1小的数据再去进行减法运算，从而使得梯度下降过程中实现参数进一步缩小<br><img src="/image/LLM/60.png" alt><br><img src="/image/LLM/61.png" alt></p><p>cost and gradient functions for both linear and logistic regression. Note:</p><p>Cost</p><p>The cost functions differ significantly between linear and logistic regression, but adding regularization to the equations is the same.</p><p>Gradient</p><p>The gradient functions for linear and logistic regression are very similar. They differ only in the implementation of $f_{wb}$.</p><h2 id="线性回归正则化"><a href="#线性回归正则化" class="headerlink" title="线性回归正则化"></a>线性回归正则化</h2><p><img src="/image/LLM/62.png" alt><br><img src="/image/LLM/63.png" alt><br><img src="/image/LLM/64.png" alt></p><h2 id="逻辑回归正则化"><a href="#逻辑回归正则化" class="headerlink" title="逻辑回归正则化"></a>逻辑回归正则化</h2><p><img src="/image/LLM/65.png" alt><br><img src="/image/LLM/66.png" alt></p><h1 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week3/9.Week%203%20practice%20lab%20logistic%20regression/C1_W3_Logistic_Regression.ipynb#scrollTo=T8l3AKj8R29G" target="_blank" rel="noopener">实践案例</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是过拟合&quot;&gt;&lt;a href=&quot;#什么是过拟合&quot; class=&quot;headerlink&quot; title=&quot;什么是过拟合&quot;&gt;&lt;/a&gt;什么是过拟合&lt;/h1&gt;&lt;p&gt;训练得到的预测模型对于每个训练数据都非常吻合，导致对于新的测试数据无法正确评估的想象，就是过拟合&lt;br&gt;下面
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归模型</title>
    <link href="http://yoohannah.github.io/post/machineLearning/logicRegression.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/logicRegression.html</id>
    <published>2024-09-17T11:31:37.000Z</published>
    <updated>2024-09-19T10:45:35.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景-amp-amp-解决问题"><a href="#背景-amp-amp-解决问题" class="headerlink" title="背景&amp;&amp;解决问题"></a>背景&amp;&amp;解决问题</h1><p>逻辑回归模型时一种解决二分类问题的算法</p><p>如果用线性回归去解决分类问题，会导致过拟合出现，每增加一个测试数据，都可能导致模型发生变化</p><p><img src="/image/LLM/40.png" alt></p><p>通过使用sigmoid function函数，设置阈值，可以将线性回归产生的结果归类到两个结果上去</p><p><img src="/image/LLM/41.png" alt></p><p><img src="/image/LLM/42.png" alt></p><p>虽然目标是二分类，即结果只能是0 或者1<br>但是f(w,b) = g(w·x+b) 计算的结果值A只能无限接近这两个值<br>这里可以将A理解成结果是1 的可能性</p><p><img src="/image/LLM/43.png" alt></p><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p>在逻辑回归模型f(w,b) = g(w·x+b)  中<br>z = w·x+b 又称为 决策边界，将不同结果的数据在坐标系中进行隔离<br>如果特征在z 中没有多项式运算，那么，得到的边界必定是直线的，但是如果有多项式，拿得到的边界线就是非线性的<br><img src="/image/LLM/44.png" alt><br><img src="/image/LLM/45.png" alt><br><img src="/image/LLM/46.png" alt><br><img src="/image/LLM/47.png" alt></p><h2 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h2><p>线性回归的平方误差算法的成本函数在应用到逻辑回归时，会产生多个局部最小值，再用梯度下降的算法去找参数时，无法找到最小值</p><p><img src="/image/LLM/48.png" alt></p><p>逻辑回归引逻辑损失函数，根据单个数据集随参数变化的趋势，判断整体的变化趋势<br>操作就是将原本平方误差除以2的操作移到求和之前，单独计算每个特征值的部分就是损失函数</p><p>Logistic Regression uses a loss function more suited to the task of categorization where the target is 0 or 1 rather than any number.</p><p>Definition Note: In this course, these definitions are used:</p><p>Loss is a measure of the difference of a single example to its target value while the</p><p>Cost is a measure of the losses over the training set</p><p>下面是推导过程和最终的式子</p><p><img src="/image/LLM/49.png" alt><br><img src="/image/LLM/50.png" alt><br><img src="/image/LLM/51.png" alt><br><img src="/image/LLM/52.png" alt><br><img src="/image/LLM/53.png" alt></p><h2 id="梯度下降找到w-amp-b"><a href="#梯度下降找到w-amp-b" class="headerlink" title="梯度下降找到w&amp;b"></a>梯度下降找到w&amp;b</h2><p><img src="/image/LLM/54.png" alt><br><img src="/image/LLM/55.png" alt><br><img src="/image/LLM/56.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景-amp-amp-解决问题&quot;&gt;&lt;a href=&quot;#背景-amp-amp-解决问题&quot; class=&quot;headerlink&quot; title=&quot;背景&amp;amp;&amp;amp;解决问题&quot;&gt;&lt;/a&gt;背景&amp;amp;&amp;amp;解决问题&lt;/h1&gt;&lt;p&gt;逻辑回归模型时一种解决二分类问题
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>线性回归模型</title>
    <link href="http://yoohannah.github.io/post/machineLearning/lineregression.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/lineregression.html</id>
    <published>2024-09-07T11:31:37.000Z</published>
    <updated>2024-09-15T03:04:16.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些专业术语表达"><a href="#一些专业术语表达" class="headerlink" title="一些专业术语表达"></a>一些专业术语表达</h1><p><img src="/image/LLM/1.png" alt><br><img src="/image/LLM/2.png" alt><br>x–&gt; 训练数据入参，特征值，这里仅有一个，这个模型也被叫做 单变量线性回归模型 x(i) 第i个训练数据的x<br>y–&gt; 训练数据入参，标记值， example 的lable ,y(i) 第i个训练数据的y<br>y-hat –&gt; 出参，推测值, 模型（f（x）= wx + b） 的 结果值</p><h1 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h1><h2 id="平方误差成本函数"><a href="#平方误差成本函数" class="headerlink" title="平方误差成本函数"></a>平方误差成本函数</h2><p><img src="/image/LLM/3.png" alt><br>在f(x) = wx+ b 的模型中<br>w: 斜率<br>b: 截距，intercepter 直接与Y轴交点距离远点距离</p><p>用J(w,b)表示成本函数，找到能够使J(w,b) 的值最小的w和b，就可以找到使f(x)最接近所有测试集的模型，最拟合训练数据的模型<br>先讨论在b = 0 的情况下，j（w） 随w 变化的趋势<br><img src="/image/LLM/4.png" alt><br>找到使j(w) 最小的w,即U形线做凹的地方<br><img src="/image/LLM/5.png" alt><br>现在把b的变化趋势也加入讨论，j(w,b) 随w，b 变化的趋势，将变成3d 的碗状<br><img src="/image/LLM/6.png" alt><br>最凹的地方就是J(w,b)值最小的地方<br><img src="/image/LLM/7.png" alt><br>利用等高线的表达方式，换一种视角找J(w,b)的最小值，就是将3D 图进行水平切割，得到关于w,b 的二维椭圆视图<br>不同(w,b) 组合可能会落在在同一条线上的，相同线上的J(w,b)值一样大<br>所以使J(w,b)最小的值，就是同心园里面最里面那个圆上的多对(w,b), 当圆极限到一个点时，那就是只用一对(w,b)使J(w,b)最小<br><img src="/image/LLM/8.png" alt><br><img src="/image/LLM/9.png" alt></p><h1 id="GradientDescentAlgorithm-梯度下降算法"><a href="#GradientDescentAlgorithm-梯度下降算法" class="headerlink" title="GradientDescentAlgorithm 梯度下降算法"></a>GradientDescentAlgorithm 梯度下降算法</h1><p>是一种寻找使成本函数达到最小值参数的通用算法，现在不再局限与于f(x) = wx+b 单变量线性模型<br>对于多变量模型，也就意味着多个w, 这样J(w,b) 就会变成J(w0,…wi,b), J(w0, …wi) 的趋势不再是U形<br><img src="/image/LLM/10.png" alt><br>梯度下降指的是，从一个点出发，环顾四周，找到能够下降的谷底的最快的方向，即梯度最陡的方向，下降一步，每走一步都按最陡方案下降，从而实现最快到达谷底的目的<br>达到谷底即意味着找到J(w0,…wi,b)最小值<br>但是梯度下降有一个特性，就是，虽然从同一点出发，如果第一步选择反向不同，或者走的方式不同，肯定会到达不同谷底<br>不同谷底意味着不同的J(w0,…wi,b)最小值，这些最小值，都叫做局部最小值<br><img src="/image/LLM/11.png" alt></p><h3 id="算法实现与理解"><a href="#算法实现与理解" class="headerlink" title="算法实现与理解"></a>算法实现与理解</h3><p>J(w,b)关于w 导数 表征 U形趋势线上随w 变化的梯度值，也就是斜率<br>前面的系数α表征 下坡的步伐大小 是一个0-1 的正小数值，称为学习率<br>w,b 同时变化，同时更新<br><img src="/image/LLM/12.png" alt><br>当梯度大于0时，temp_w 逐渐变小，J(w,b) 的值也逐渐变小<br>当梯度小于0 时，temp_w 逐渐变大（负斜率，绝对值在变小）， J(w,b)的值逐渐变小<br>说明J(w,b) 的值随梯度的变化符合随w的变化趋势，当斜率绝对值逐渐变小时，就是都朝J(w,b) 最小值聚拢<br><img src="/image/LLM/13.png" alt><br><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb" target="_blank" rel="noopener">实验</a></p><h4 id="关于学习率"><a href="#关于学习率" class="headerlink" title="关于学习率"></a>关于学习率</h4><p>太小会增加计算步骤，从而使梯度算法变慢<br>太大可能导致过冲，永远无法到达最小值;甚至无法实现聚拢趋势，导致发散<br><img src="/image/LLM/14.png" alt></p><h3 id="局部最小值"><a href="#局部最小值" class="headerlink" title="局部最小值"></a>局部最小值</h3><p>如果当前参数已经似的成本函数到达一个局部最小值，那么J(w,b) 关于w 导致值将会是0，那么temp_w 会始终停留在一个固定的值，不再变化<br>梯度下降算法将不会再进行下一步的计算，保持当前参数在当前的这个一个局部最小值的状态</p><p>随这个梯度下降，我们可以知道我们正在朝成本函数最小值靠近，在学习率固定情况下，更新步骤也在下降，说明没有学习率的变化，也能到达局部最小值<br>但如果同时将学习率调小，降低下降的步伐，可以更小幅度的一点点接近最小值，最终找到成本函数最小值<br><img src="/image/LLM/15.png" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>线性回归模型，成本函数，和梯度下降算法<br><img src="/image/LLM/16.png" alt><br><img src="/image/LLM/17.png" alt><br>上述梯度下降算法具体来说是批量梯度下降，因为每一步都用到了所有训练数据<br><img src="/image/LLM/18.png" alt></p><h1 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h1><p>以上讨论的是只有一个特征值x 作为输入的情况，下面要讨论的是同时有n个特征值做输入的模型，被称为多远线性回归模型</p><p>一些符号的表示方法<br><img src="/image/LLM/19.png" alt></p><h2 id="模型表达式"><a href="#模型表达式" class="headerlink" title="模型表达式"></a>模型表达式</h2><p><img src="/image/LLM/20.png" alt><br><img src="/image/LLM/21.png" alt></p><h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>好处</p><ol><li>代码实现简洁</li><li>运算速度快</li></ol><p><img src="/image/LLM/22.png" alt><br><img src="/image/LLM/23.png" alt><br><img src="/image/LLM/24.png" alt></p><h2 id="对于多元线性回归-的-梯度下降算法"><a href="#对于多元线性回归-的-梯度下降算法" class="headerlink" title="对于多元线性回归 的 梯度下降算法"></a>对于多元线性回归 的 梯度下降算法</h2><p>w 相关的计算转成向量计算，不同权重值，取对应特征值进行计算<br><img src="/image/LLM/25.png" alt><br><img src="/image/LLM/26.png" alt></p><p><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/1.Multiple%20linear%20regression/C1_W2_Lab02_Multiple_Variable_Soln.ipynb" target="_blank" rel="noopener">实验</a></p><h1 id="实践技巧"><a href="#实践技巧" class="headerlink" title="实践技巧"></a>实践技巧</h1><p>如何更快的找到合适的参数去拟合训练集</p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><h3 id="参数大小与特征值大小关系"><a href="#参数大小与特征值大小关系" class="headerlink" title="参数大小与特征值大小关系"></a>参数大小与特征值大小关系</h3><p>如果某一特征值(x1 属于[1000,5000]范围)相对其他特征值(x2,x3,..xn,属于[1,10]范围),数值范围较大，其对应参数w1 则相对其他较小<br>反之，如果特征值较小，则参数较大，这样的规律可以更快的找到适合的参数<br><img src="/image/LLM/27.png" alt><br><img src="/image/LLM/28.png" alt><br>如果特征值的取值范围非常不同时，会导致梯度下降速度变慢<br>但如果将所有特征值想办法归一到相同的范围内，就可以加快梯度下降过程，降低计算步骤<br><img src="/image/LLM/29.png" alt></p><h3 id="缩放计算方式"><a href="#缩放计算方式" class="headerlink" title="缩放计算方式"></a>缩放计算方式</h3><h4 id="除以最大值"><a href="#除以最大值" class="headerlink" title="除以最大值"></a>除以最大值</h4><p>特征值除以各自范围的最大值<br><img src="/image/LLM/30.png" alt></p><h4 id="均值归一化"><a href="#均值归一化" class="headerlink" title="均值归一化"></a>均值归一化</h4><p>特征值 减去平均值，再除以极差值(范围最大值减去范围最小值)<br><img src="/image/LLM/31.png" alt></p><h4 id="Z-SCORE归一化"><a href="#Z-SCORE归一化" class="headerlink" title="Z-SCORE归一化"></a>Z-SCORE归一化</h4><p>特征值 减去 标准差，除以 平均值<br><img src="/image/LLM/32.png" alt></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>并不一定非要落在-1 到1 之间，落在相同的数量级之间就可接受<br><img src="/image/LLM/33.png" alt></p><h2 id="如何找到成本函数最小值"><a href="#如何找到成本函数最小值" class="headerlink" title="如何找到成本函数最小值"></a>如何找到成本函数最小值</h2><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>绘制成本函数随迭代次数变化的趋势图，称为学习曲线，主要是根据曲线走势判断梯度是否在收敛<br>如果随迭代次数增加，成本函数一直呈下降趋势，说明梯度正在下降，是正常的<br>当下降到一定程度，随迭代次数成本函数不再有明显下降，说明梯度收敛到了极限，也就是找到了成本函数的最低点<br>但如果随次数增加，成本函数出现上升，这是不正常的，则说明学习率选取过大，需要重新选取，或者代码出现错误</p><h3 id="自动收敛测试"><a href="#自动收敛测试" class="headerlink" title="自动收敛测试"></a>自动收敛测试</h3><p>自行定义一个极小的值，当某次迭代后成本函数值小于该值时，就认为梯度下降关闭，成本函数达到最小值，停止迭代，取当前迭代wb做模型参数<br>缺点就是极小值难以估计，且结果不太可靠<br><img src="/image/LLM/34.png" alt></p><h2 id="如何选择合适学习率"><a href="#如何选择合适学习率" class="headerlink" title="如何选择合适学习率"></a>如何选择合适学习率</h2><p>根据学习曲线调整学习率<br>学习率太大会导致学习曲线出现上升趋势<br>太小会导致迭代次数增加<br><img src="/image/LLM/35.png" alt><br>可以先对不同量级的学习率进行测试，观察学习曲线变化快慢<br>然后进行N倍测试，再比较，通过多组测试观察学习曲线变化快慢进行选取<br><img src="/image/LLM/36.png" alt></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>通过转换或者合并直接(原始)的特征值，生成新的特征值进行模型训练<br><img src="/image/LLM/37.png" alt></p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>如果特征值只有一个的情况下，不希望得到线性回归的直线模型，希望用曲线去拟合训练集<br>可以采用下面两种方法去拟合</p><ol><li>通乘方构建新特征值，但是在进行训练时要进行归一话处理，因为乘方处理后，各个特质值范围的数量级会变得不同</li><li>通过开方进行新特征值构建<br><img src="/image/LLM/38.png" alt></li></ol><h1 id="如何在colab中运行github-上的jupiter文件"><a href="#如何在colab中运行github-上的jupiter文件" class="headerlink" title="如何在colab中运行github 上的jupiter文件"></a>如何在colab中运行github 上的jupiter文件</h1><p>下面这个链接时梯度下降实现的.ipynb 文件</p><p><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb" target="_blank" rel="noopener">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb</a></p><p>复制域名之后的path<br>kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb<br>拼接到 <a href="https://colab.research.google.com/github/" target="_blank" rel="noopener">https://colab.research.google.com/github/</a> 后面</p><p>得到访问链接</p><p><a href="https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb" target="_blank" rel="noopener">https://colab.research.google.com/github/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week1/work/C1_W1_Lab05_Gradient_Descent_Soln.ipynb</a></p><p>如果.ipynb有依赖其他py 文件，可以点击上传图标直接上传<br><img src="/image/LLM/39.png" alt></p><p>但是要注意这里上传的文件都是运行时的状态，页面关闭即销毁，<br>如果想要保存自己修改后的.ipynb文件可以通过添加副本到goole/drive 来实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一些专业术语表达&quot;&gt;&lt;a href=&quot;#一些专业术语表达&quot; class=&quot;headerlink&quot; title=&quot;一些专业术语表达&quot;&gt;&lt;/a&gt;一些专业术语表达&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/LLM/1.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>机器学习定义</title>
    <link href="http://yoohannah.github.io/post/machineLearning/definition.html"/>
    <id>http://yoohannah.github.io/post/machineLearning/definition.html</id>
    <published>2024-09-02T00:10:37.000Z</published>
    <updated>2024-09-07T11:30:43.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><p>filed of study that gives computers the ability to learn without being explicity programmed.</p><p>让计算机在没有明确编程的情况下学习的研究领域</p><p>– Arthur Samuel (1959)</p><h1 id="Supervised-Learning-监督学习"><a href="#Supervised-Learning-监督学习" class="headerlink" title="Supervised Learning 监督学习"></a>Supervised Learning 监督学习</h1><p>learns from being given ‘right answers’</p><p>learns from  data labeled with ‘right answers’</p><h2 id="regression-algorithms-回归算法"><a href="#regression-algorithms-回归算法" class="headerlink" title="regression algorithms 回归算法"></a>regression algorithms 回归算法</h2><p>从无限多可能数字中预测数字</p><p>predict a number 预测无限可能中的一种<br>infinitely many possible outputs</p><h2 id="classify-algorithms-分类算法"><a href="#classify-algorithms-分类算法" class="headerlink" title="classify algorithms 分类算法"></a>classify algorithms 分类算法</h2><p>predict categories 预测有限分类中的一类<br>small number of possible outputs</p><h1 id="Unsupervised-Learning-无监督学习"><a href="#Unsupervised-Learning-无监督学习" class="headerlink" title="Unsupervised Learning 无监督学习"></a>Unsupervised Learning 无监督学习</h1><p>find sth interesting in unlabeled data<br>data only comes with input x ,but not output labels y, algorithm has to find structure in the data</p><h2 id="clustering-algorithms-聚类算法"><a href="#clustering-algorithms-聚类算法" class="headerlink" title="clustering algorithms 聚类算法"></a>clustering algorithms 聚类算法</h2><p>place the unlabeled data (automatically group) into different clusters</p><p>eg. google news, grouping customers</p><p>==&gt; group similar data points together</p><h2 id="Anomaly-detection-异常检测"><a href="#Anomaly-detection-异常检测" class="headerlink" title="Anomaly detection 异常检测"></a>Anomaly detection 异常检测</h2><p> find unusal data points (events)</p><p> eg. 金融诈骗中的交易异常</p><h2 id="Dimensionality-reduction-降维算法"><a href="#Dimensionality-reduction-降维算法" class="headerlink" title="Dimensionality reduction  降维算法"></a>Dimensionality reduction  降维算法</h2><p>compressn data using fewer numbers</p><p>压缩大数据集到小数据集，同时丢失尽可能少的信息</p><h2 id="Reinforcement-Learning-强化学习"><a href="#Reinforcement-Learning-强化学习" class="headerlink" title="Reinforcement Learning 强化学习"></a>Reinforcement Learning 强化学习</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是机器学习&quot;&gt;&lt;a href=&quot;#什么是机器学习&quot; class=&quot;headerlink&quot; title=&quot;什么是机器学习&quot;&gt;&lt;/a&gt;什么是机器学习&lt;/h1&gt;&lt;p&gt;filed of study that gives computers the ability to
      
    
    </summary>
    
    
      <category term="machineLearing" scheme="http://yoohannah.github.io/tags/machineLearing/"/>
    
  </entry>
  
  <entry>
    <title>关于报文压缩方法的探究</title>
    <link href="http://yoohannah.github.io/post/knowledge/compressMethod.html"/>
    <id>http://yoohannah.github.io/post/knowledge/compressMethod.html</id>
    <published>2024-03-03T10:16:37.000Z</published>
    <updated>2024-09-01T03:26:27.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>项目中需要对大数据量请求时间进行缩短优化的工作，优化过程中发现，浏览器响应报文压缩方法为br的情况会比gzip的时间要长11-13s，具体表现如下</p><p>服务端响应用时45s</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmZmZTIyZmEzZWRkZDQ2OGZmODc5YmM5ZmJkMGM0ZGRfUGF4OE1qUElncThDQXd6SkpqVWFNY3g1MDNTcXBTdUlfVG9rZW46TW5namJPWnZ1b2F2MWZ4VFRQUmNuVXRnbk9oXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>但是浏览器<strong>等</strong>服务端返回却花了58s</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OWNkYzA0ODEyYTlmMmE3ZTQ4OGM2MTc3ZDAwZTY2MzZfS3VBYVlKNDcwWTgxSklXSTRqQVdkcW1UZHd6NWR4STJfVG9rZW46Tm80M2I4Smd2b0pmamV4QkhGdWMxU3JXbmxlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTBiZTE2NDk3ZDg1YWFmYTQ0OTM3ODYwNGZhZjIzODlfOEtIaGNvbXc4NXhDbWNHbG1oWmtXSXVaWTBKa2tRNmFfVG9rZW46RUhlV2J1UWRqb3JUN094WWRoMWNCaE5ibmJoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>这样浏览器就会比服务器响应<strong>多等</strong>了58-45= <strong>13s</strong>，不是很正常</p><p>现在直接拿浏览器请求的cUrl 发起请求</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ODcyYjM3NTk3MjMxYzRiNzUyYzY3MDI3ZGIyY2Y1MmFfaEJFVDNmUHFxUXlzckgxUTV5dXZ5cFZBZUhpN1Jpck5fVG9rZW46QkVpV2JrWVBlb05kYlh4R0NnNmNyQWtHbncyXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDU4ZDI1YjUzOWFmYTZkOWU0Y2U5NGJiOTJhZGMxODBfN3lDakIwSklNVnRMbmxCc2JaZkgzYzRLbzIwQW9RUThfVG9rZW46SzdCT2JVekpYb3VwcWd4VjM4SGNMcDBJbmZkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NmQ2NjE1NDk2M2NlNzMyNDkyNDgzNWE5ZDY4Yzk1YzFfWEZFVDVDZVpjSVVQMjkzbHRqZk96TFhpVDAxcGxYYktfVG9rZW46TXJiZGJCOG9zb1N4eFp4WUFlRmMwRjJobkpkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>可以看到非浏览器请求的响应使用了gzip压缩，总用时48s, 服务端用时46s, 耗时差2s</p><p>可见使用gzip压缩算法耗时是远优于br压缩的</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>想办法禁用掉br压缩方法</p><ol><li>指定service Mesh压缩方法</li></ol><p>第一步，检查服务集群是否开启了service mesh，开启后指定才有效</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NDQ0OGQ2OWUxZDJlNGViNTJkMDMyY2I1M2Q0YjJkOWJfcms4d0dMb0ZSSnlJYk9Nb2pVWVl4a1dDMlJwellPNTVfVG9rZW46QWdNNmJXU1gzb2ljUGZ4S1ZzUWNJTUVhbjJyXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>第二步，直接在【通用流量平台-&gt;稳定性管理】指定压缩方法</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmQwYjNiODQ2YTQ2MDM1Nzg5OGJjN2I1YzE3M2Y3NzNfM2pRbTJvOTRVblpFWDg1V3FTeUlyVkRBUWZkZ2NLT2NfVG9rZW46VlVvZWJ4NGU3bzFDd2d4blpab2M1OHdibjNkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>Service mesh 在指定压缩方法后，会对所有请求按指定的压缩算法进行压缩，不管content-length 大小，也不管上游是否已经指定了其他压缩方法，简单粗暴，适合快速解决问题</p><ol><li>TLB + 项目配置</li></ol><p>该方法是在探究原因过程中发现，过程比较曲折，需要排查修改两个地方，着急解决问题不适宜</p><ol><li>确认下自己的服务是否为node服务且有使用koa-compress插件(<strong>注意排查框架是否有默认注入</strong>)，需要将br 压缩算法关闭，具体关闭形式可能因框架不同配置姿势不同，但可以参考下插件<a href="https://github.com/koajs/compress" target="_blank" rel="noopener">官方配置</a></li><li>关闭TLB 路由Ngnix默认br 压缩算法配置，禁止使用br算法</li></ol><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MjE0NjZiZDAwOWViMmJmYjgwYjgzZmRhMWU5OGZmNzdfQUtKenJndjJZMmQySXdvdFlyRUFoeFVPNWZGSzRFSEtfVG9rZW46Q05TdmJMQml0b0NFQkd4aWx0bmNnYUZEbkZoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>虽然复杂，但是方案会比方法一更合理一些</p><h2 id="为什么不在发起请求时直接更改accept-encoding？"><a href="#为什么不在发起请求时直接更改accept-encoding？" class="headerlink" title="为什么不在发起请求时直接更改accept-encoding？"></a>为什么不在发起请求时直接更改accept-encoding？</h2><p>解决这个问题的另一条途径就是从源头，请求发起端就去掉相关br的设置，也就是更改accept-encoding, 让它不包含br，如果客户端不支持br 压缩，那请求响应自然是不能使用br 压缩的，但是天有不测风云，accept-encoding 是一个不能通过代码去修改的请求报文(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name" target="_blank" rel="noopener">详见</a>)，所以这条路是行不通的。</p><h1 id="这到底是怎么回事？"><a href="#这到底是怎么回事？" class="headerlink" title="这到底是怎么回事？"></a>这到底是怎么回事？</h1><p>虽然使用方法一可以快速彻底的解决掉问题，但是不应用方法一时，可以发现的一个明显问题就是不同请求的压缩方法不同，而且存在不使用压缩方法的情况，这就激起了作者尘封已久的好奇心，到底是谁在指定content-encoding呢？</p><p>接下来就需要看一下从服务端到客户端，到底是哪个环节在决定content-encoding</p><h2 id="Koa-compress"><a href="#Koa-compress" class="headerlink" title="Koa-compress"></a>Koa-compress</h2><p>鉴于本人node服务项目基于ACE1.X构建，在搜索代码进行排查时，并没有在配置文件中搜到相关的配置，重新查阅框架文档的时候，才注意到框架有进行<a href="https://iesfe.bytedance.net/ace-v1/fullstack/basic/middleware/#compress" target="_blank" rel="noopener">默认注入</a>，这就从服务端源头找到了一个会更改content-encoding的地方，俗话说，灯下黑，不过如此。</p><p>既然有使用koa-compress, 而且<a href="https://github.com/koajs/compress/tree/master/lib" target="_blank" rel="noopener">源码</a>不是很复杂，那就简单探索下它的压缩原理</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTgyZTg5MmY1NWUyMTYzNGQ1NzUxZTBiM2EzYjk4N2ZfdGRzZ3lxQW1iVTdER21JYUxzQm9iWGFGbjFlSnA4bERfVG9rZW46SUVBMGJmaWJKb2xGQkh4U0JXM2NVYmVBbkNMXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>查看源码可知，当content-length大于1024b时，会根据Accept-encoding进行压缩</p><p>在Accept-Encoding值是’gzip, deflate, br’情况下</p><p>压缩方法的选择逻辑就是accept-encoding有br 会优先使用br，如果br被禁用就使用gzip</p><p>由于默认注入时，没有指定压缩阈值，所以当我们的请求数据过大, 大于1024b时，自然就会触发koa-compress进行br压缩，也就是说上面问题的出现，罪魁祸首就是koa-compress</p><p>但是当数据量小于1024b时，又会出现br，甚至不进行压缩又是怎么回事呢？</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTk5ZjMxMTIwOTgwMTc3YzY5MjRmMjRkYjMyNDdlOGRfMHA4SlJNbDdaalBzQ1dWSXhuQXNJcXZJQTFjV2U3b0NfVG9rZW46VHBDSGJDNWZ0b2VxUW14cnFJWWNXa0ZnbkdnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDIyZTAwZjdkYmI1YTg1OWY3OGFlOTI4MzFhOWVmNzdfMmFlZGZ4S25DekNnUzhSZTB4Z2NDUVY3dVpZMWs5SFpfVG9rZW46VmV1V2JlNnZzb2hHald4M0RGTWNMYk1hbk1nXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><h3 id="whisle插曲"><a href="#whisle插曲" class="headerlink" title="whisle插曲"></a>whisle插曲</h3><p>在排查过程中，相同条件请求，在本地开启whistle代理，通过域名进行本地访问，出现了响应始终是gzip 的情况，这对于大于1024b的响应就不对了，按上面koa-compress逻辑，应该是br才对</p><p>经过在http\://localhost:8899/#network 抓包，可以发现whistle给本地服务的请求报文accept-encoding是不带br的</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OWVkMWNjYzMwZDE2N2ExMjNmNzFkOTk2NTgyM2U4YWJfZ1BYSnFNUGNZVkpvaGVRamZaenp0b2hKZHFqOEt2TU1fVG9rZW46UWxDRmIwT1Vqb3ViY2R4VFQwcGNDMDlwbnNiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>经过与whistle开发者请教(<a href="https://github.com/avwo/whistle/issues/950" target="_blank" rel="noopener">issue</a>)，whistle确实会篡改我们的报文，把accept-encoding中的br 去掉，这样就实现了响应始终是gzip压缩的效果，因此，在本地的测试推荐大家直接使用localhost访问，避免代理的干扰</p><p>以下在本地进行的测试也均是在关闭代理情况下进行</p><h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>根据请求响应链路，响应从node服务返回后，会依次经过Mesh, TLB然后到浏览器</p><p>由于mesh 在不指定压缩算法的情况下是<strong>不参与</strong>压缩的，所以对于小于1024的数据压缩，矛头指向了TLB</p><p>在开始验证前，先来了解下TLB的压缩原理<a href="https://bytedance.feishu.cn/docx/CgO6dfGYOo86eYxILLPcMc2MnRc" target="_blank" rel="noopener">TLB压缩问题oncall排查手册</a></p><p>文中对我们比较重要的信息是这部分</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjZmMDE3ZmJjNzYxNThjZjk5Mzc2MDBlNmVkYjk4YzRfODVpZm9jSDFKUnUwUUJzZ2hVbnIyZEJoa3lZZWo4Z2ZfVG9rZW46QVFRTWJpRXJSb0dKTHF4d25qY2NaaHpTblJkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>文中配置与tlb同学确认后就是默认配置，这样对于我们验证就有了参照物</p><p>在关掉koa-compress 的br 压缩后，我进行了如下实验</p><ol><li>构造响应不同content-length的接口</li><li>分别通过本地localhost 访问，域名访问，以及关掉tlb 的br 压缩后再通过域名访问以上接口（保证经过tlb）</li></ol><p>得到如下结果（no表示不压缩）</p><table><thead><tr><th style="text-align:left">content-length</th><th style="text-align:left">localhost:3000</th><th style="text-align:left">域名访问</th><th style="text-align:left">tlb 设置 brotli = off</th></tr></thead><tbody><tr><td style="text-align:left">117</td><td style="text-align:left">no</td><td style="text-align:left">no</td><td style="text-align:left">no</td></tr><tr><td style="text-align:left">152</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">no</td></tr><tr><td style="text-align:left">204</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">958</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">1208</td><td style="text-align:left">gzip</td><td style="text-align:left">gzip</td><td style="text-align:left">gzip</td></tr></tbody></table><p>从koa-compress 压缩原理我们可以知道从服务端响应的数据，大于1024采用gzip，小于则不压缩</p><p>所以本地访问是符合预期的</p><p>经过域名访问，我们可以看到小于1024大于150的响应被用br进行压缩了, 符合br 大于150就压缩</p><p>当把tlb 上nginx的br开启指令关掉，我们可以看到小于1024大于200的响应被用gzip压缩了，符合gzip 大于200就压缩的逻辑</p><p>再看大于1024的最后一行，当服务端已经指定content-encoding的时候，tlb 是不会进行压缩的，会沿用上游指定压缩算法</p><p>综上看来，<strong>TLB 会在上游响应未指定content-encoding的时候进行小于1M响应数据的压缩, 默认大于150b时会使用br压缩，大于200b且禁用br情况下才会使用gzip，如果上游指定了content-encoding, 就沿用上游压缩算法</strong></p><p>至此，响应报文的content-encoding 来源我们搞清楚了，接下来回到解决办法一，验证下service mesh指定压缩方法后报文变化</p><h3 id="集群插曲"><a href="#集群插曲" class="headerlink" title="集群插曲"></a>集群插曲</h3><p>虽然<a href="https://bytedance.feishu.cn/docx/CgO6dfGYOo86eYxILLPcMc2MnRc" target="_blank" rel="noopener">文档</a>中指令是默认指令，但不并是<strong>所有</strong>TLB集群的默认Ngnix 配置，如果出现了与上述结论异常的情况，需要邀请TLB 的同学帮忙查一下域名依赖的<strong>TLB 集群</strong>是否就是文档中的默认配置（因为只有TLB同学有权限可以查）</p><p>比如，相同600B请求，Boe 环境是br压缩，但是线上则变成了gzip</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZjFjMTkwMTg2NzkzNDA3MDZmOTZlNGEzMGYzOTc2OGVfdFY3ZUhMN0tIU2lFdTRuaDFDbzl6bWNOTEtDUEwyRWtfVG9rZW46RERKdmI0azFPbzJQdjd4TkpNQ2NDd2JobmVkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YzE1YWJjZTNjZWNhNDA4NDk0ODNjNjg0MTNlMGFlMTRfVmJ1VVA0M1pMZm5hQ0hqcDJQOVVwd3lwZUFlUm5rUHpfVG9rZW46VTVoeGJlNXhsb3g2SWN4SXBZbmNFakxGbmtBXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>按上面的结论，服务器不会对小于1024的请求进行压缩，经过tlb 默认配置会使用br，boe 环境是正常的，线上是不正常的，经过排查发现，线上tlb 依赖的<strong>集群默认</strong>配置没有开启br ，所以再走默认配置会进行gzip压缩</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzQzNDk5NGQyMDc0YTE4NzA1MGU5YzJkN2ZlOGM2MDlfNGtDdVNGYTUxMTdBUUR2em9aS1lpcERXN3FsNFFqRkhfVG9rZW46R2VlZWJ0TTU0b2VxcWN4OXNtM2MyQ0hibmZkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YzUzZGYyNDkyOTE4YjQxZGVhMWU3ZDIyZmNlYWYwNjNfdzNvWUtFT0U4amcyeXdTT3U5TE51UlJoVFlPS1pFTDVfVG9rZW46SUZPY2JtamJ6b0RmQ014YWtjdmM2UWJSbjBlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><h3 id="Cloud-IDE"><a href="#Cloud-IDE" class="headerlink" title="Cloud IDE"></a>Cloud IDE</h3><p>这里需要注意一点的是，上面我们在发现小于1024的压缩算法异常时，访问的是cloud IDE 上启动项目后帮我们生成的域名，我们在本地请求接口是没有进行压缩的，也就是说cloud IDE生成的域名是有经过TLB的，而且其集群默认开启了br压缩</p><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p>实验条件(复现问题)：</p><p>TLB nginx 不禁用br</p><p>不禁用koa=compress的br压缩算法</p><table><thead><tr><th style="text-align:left">content-length</th><th style="text-align:left">localhost:3000</th><th style="text-align:left">域名访问</th><th style="text-align:left">域名访问</th></tr></thead><tbody><tr><td style="text-align:left">117</td><td style="text-align:left">no</td><td style="text-align:left">no</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">152</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">204</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">958</td><td style="text-align:left">no</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr><tr><td style="text-align:left">1208</td><td style="text-align:left">br</td><td style="text-align:left">br</td><td style="text-align:left">gzip</td></tr></tbody></table><p>我们从浏览器发起请求</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=M2IyNDRhOTRhNDk3Yzg3ZWMxOWY2NWQ1NWQzYjYzZDNfWWVyY2toZjFxWDJqRlE4aGtOM25BRE5XQTU3cEpjVGNfVG9rZW46VlhJSmJDOUhtb01GREp4UzJHSmNzaTdzbkpiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>在最后一个中间件打印响应头，说明服务器没有参与数据压缩 (可以通过设置priority让中间件在最后一个执行)</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTJlNTA3NzA4ZTA2YjcxZjE1ZDNjMmE5ZjEzYWU1YTFfcFlUVGhlMHFyb2JwQ1JGNVRvTklaMWd1WDJoSGg2ektfVG9rZW46Wk4wMWIyUFhDb2Z6UXV4dGVUS2NqSXprbklkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>然后通过监听端口报文</p><p>tcpdump -i eth0 port 3000 -nn</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzAwZDkxZjUxNWQ1YWUwNGZkNzQyZmY3ZTA5MjgwNDhfYWM5TEZTZWZvQXpRTEpoT2xOdGZRU1FISmZZUFZwSFFfVG9rZW46WGdPdWJwdzZMb2ZTd1Z4NzRPRWNvOFdSbkVjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>基本上通过上述表现我们基本上是可以判断是mesh 进行了压缩</p><p>但是，我们现在监听的是3000配置端口(其他服务监听实例输出的端口)</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NjRjYTJiYTI1NzBmMWRlOGYzNDMxOTQ2Y2Q3MmNkYzBfMGtXMzc2c3NVQW9jUmVoNXZoV0RQVHhGOW5YZ2JqemFfVG9rZW46UGE2T2JqVjVJb2JnTDl4NXdJbGNZSG9sbjFjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>如果3000端口吐出来的是经过了mesh的话，那通信的结构应该是这样</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTc5NDRmMzRjOGY5MzkwZTQ3MTY0NGNhNjhlNzBiN2FfYjViaDYyRkNLVXdSZk9WeDkwS3ZYcnJGYVllZG0zOXJfVG9rZW46WHJjU2JVbHY0b2l1alJ4eVlZdWNrUzNHbkh6XzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p><strong>往深了想一下，上面的判断逻辑并不是非常精确</strong></p><ol><li>node 最后吐出来的数据的header 可能跟我们上面在最后一个中间件打印的header并不同，也就是说我们在最后一个中间件打印的header 并不是最终实例吐出数据的header，有一些 header 是会在最后吐数据的时候装的</li><li>Gzip 的请求头真的是mesh 加上去的吗？实例和mesh 之间不会还有其他服务？</li></ol><p>要解决上面两个疑问，就要想办法去抓取一下mesh 接收的数据，也就是服务吐给mesh的数据</p><h3 id="抓取mesh-socket"><a href="#抓取mesh-socket" class="headerlink" title="抓取mesh socket"></a>抓取mesh socket</h3><p>当给服务开启mesh 服务时，mesh 会给环境注入一些<a href="https://bytedance.feishu.cn/wiki/wikcnNBQTrQvvto4XpAtlgDtbvh" target="_blank" rel="noopener">环境变量</a></p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQyNDk2YzM4Y2ZkNTcyMTVhOGQ2ZGQ4NThlNzMyODNfaUlEV3htRTNEZVRCWEZxVXhZR0JMVEd3dTBLQ1dDUUxfVG9rZW46SWN4cWJWdHZib2JLaEN4STY4VmM1RnRObktjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZGNiZjlhY2U5NDkzZjI5NjYwN2NkNGRiZWY5MDIxNjVfRmNwb1VDVFRVRWZ6bjRKWksxZlEwd2lFb2w3SlVxREVfVG9rZW46WndZWGI0aGg3bzFJaUp4ZVBzUGNxWmtyblhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>其中SERVICE_MESH_HTTP_EGRESS_ADDR 这个变量对应的地址就是服务交给mesh 转发的数据</p><p>即服务会往这个地址吐数据，然后再由mesh从这里转发再吐出去</p><p>那我们接下来就要想办法去读这个socket</p><p><a href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">通过tcpdump对Unix Domain Socket 进行抓包解析</a></p><p>当我打算用curl 命令去执行相关方法时，却发现没有相应地址的socket</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MTBlNWU4ZTVhNGUxZmFhNmY4NzBhMTRhMmQxYzk2ODZfVlgzRHdpZGVGbTllQnBXaVZZNVlyaTFyajRyOTBXYVdfVG9rZW46UGE3dmJIZGJlb25YVHJ4OUFaOWNaWFlGbmxUXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>ok，拉mesh 同学onCall 说这种情况是因为服务器和mesh之间不是用的uds通信，用的ip PORT通信</p><p><a href="https://bytedance.feishu.cn/wiki/wikcn4bvZsBkZMpUVC2WQ0lUzPg#OqPeFE" target="_blank" rel="noopener">ByteMesh HTTP 出流量接入</a></p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTk1YzA0YjJmNmYxODc4ZDcwMjcxMDY2MzY3MTg1OWJfcVVsa2M1WUFxN3dtelJnQzJTbHJZNTI3cVpjWGtya3JfVG9rZW46SHJUemJRV2xwbzFrdWx4QWRDSWN1NEVvblZoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><h3 id="抓取PORT-9507"><a href="#抓取PORT-9507" class="headerlink" title="抓取PORT 9507"></a>抓取PORT 9507</h3><p>&#x20;那我现在需要找到MESH_EGRESS_PORT具体是什么</p><p>无论是通过打印环境变量</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTM3NTkyNGJhZmIxOWVhNTcyZmFkODhhMDJmZmFmNzlfcXk2dkRFZ3E3SUtKWVFVTkQ4ZkR2c3ZVNUw4VDBZS3dfVG9rZW46UmN3QWJ0Y0l2b1lqT2d4MWhnbGNScUJnbm1iXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>还是通过 cat /proc/\${pid}/environ 查看配置文件，以及通过查看监听端口</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTkxMWI0YTIxYzJkOWI4NzgxNjdlNzg1N2Q0MmU2MDdfSU1MRnNDRjFLdDNya0t6bWFoMzB0Yk5uREhlSjVZVkJfVG9rZW46SlpVZ2IwR0pVbzlSbnp4RkpoQ2NtbWVSbkJoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>基本都确定lookback通信的port 是9507</p><p>Ok 那我们再回到用tcpdump 抓包的方式,会发现什么也抓不到</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTA2ZGY0ZmY5MTA0YWRmZDUwM2Y4ZWRmYzllMmUxNTdfMW9zdGE2bVp0cWMyWnpJYnhnSUNyYXZwQW16VXRISW1fVG9rZW46TE5URmJFY0g1b3ZyYkx4SkRlVmNJWFJWbkdjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>陷入死胡同, 那就是说没有数据包经过mesh 接收数据的端口</p><h3 id="重新认识Service-Mesh"><a href="#重新认识Service-Mesh" class="headerlink" title="重新认识Service Mesh"></a>重新认识Service Mesh</h3><h4 id="入流量"><a href="#入流量" class="headerlink" title="入流量"></a>入流量</h4><p>我们之前是通过入流量开启压缩算法的</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ODJjMTdiYmU4MjExZmJiMGFmYjlkYzYyZDM5NTg1NTNfeDNjR2dwYm9neHR6OVNhOGs5eTVWMXhibkg5TWIzVE5fVG9rZW46UFFvdmJieDBtb2tiMUV4ZURmaWMxVGI1blhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>入流量在整个通信链路中的作用是这样的</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzYwYjFhOTE5YWUyM2M1MjU0NGU1NTIwODQ0NTJlNTJfTVcxUFZTcHpGM2U2a1YyUHJ2cHZJdkZ0NUNkbm5nc3BfVG9rZW46STFERGJzY2dXb3dRVGV4WExWbWNLQXVvbnVEXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>&#x20;所以现在需要抓取的是入流量的端口<a href="https://bytedance.feishu.cn/wiki/wikcntxkGyIyWhfQ2ZZiqCmOj4c" target="_blank" rel="noopener">ByteMesh WebSocket &amp; HTTP/1.1 &amp; HTTP/2协议接入约定</a></p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NmY1NDM1ODcyNDZiNDJhMjk3YTIxMjEyODJlMTIzNDNfVnlvM1hRMEVwY0RzRW0xYXFXR3hjUTdlWUNBNkowclhfVG9rZW46R2d6T2I3ZURjb0l3NEd4VHNsYmNzMnpubmRkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>需要找到MESH_INGRESS_PORT 通过查看pid 下面 environ 文件可以看到port 为3000，也就是配置端口</p><p>然后尝试监听 <a href="https://www.cnblogs.com/zgq123456/articles/10251860.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq123456/articles/10251860.html</a></p><p>tcpdump -i any -A -s 0 ‘tcp port 3000 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)’</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTk1NjI5ZTgzMjBlZjQ0MmY3MjNkZTM2OWI0NzRmZTBfQ1ZJM3JCcFhvamFaOGhrZXNGT0w2MUd6cVFRcnY5d2RfVG9rZW46R2tKTGJQRmlob2JqSjh4dWFLYWM1QmtjbmdkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NGU2ZWI0MzMzN2MxYWIwNjU0NDgzMTc1NTc2MmEyNWZfTDdvSmpVNk9xbXFpQmJFTFBNbTdsV3ZLZXRQa29JcVpfVG9rZW46WGp2NmJCeUhJbzlGMUl4UDFEZWNjTlpzbnhiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>这一次看到了报文的整个变化过程如上两图</p><h4 id="出流量"><a href="#出流量" class="headerlink" title="出流量"></a>出流量</h4><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQ3YjQ2NGZhZDU2NzY0MTRkNmRlZDAxN2FlNzRjODlfNVJIOW11d1cyWlFNZ1JYQWVMZ2t2WWw5dWg3VENlTDFfVG9rZW46WXlVa2J4R1Fsb1Jva0F4RktMZGNjWW5WbnNmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQyOGI1OGFhNjlmNDlhZThkZWJjZWY1ZjVmMDNlMThfeUxHQ0w2anc5Zjc4MTU4RUlKOW1qS2NTYWJoUFlrRkNfVG9rZW46V2Y0S2JCVHZ1b2Nndml4TTB2a2NvSUtDbjhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>通过给服务开启出流量代理，可以看到两种通信地址</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjIxMDQzZjNjNTE5ZTEyYTcxMjU4NTY1NTRkMWRmZDFfRmZBRWYwc2RnT0xMUkVrZ01DNmw1NmNhUjJ0QWxUNmVfVG9rZW46Vk5BbWJzVHR5b3JnUVh4SjYwS2NSREUwbkxnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>SERVICE_MESH_EGRESS_ADDR 即如果node 跟下游服务通信会走dsl 通信</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTg1NmYwMDdmNTJjNjk2MTNkNTVkYWM4M2MwYmIzYTJfZVR5VFFxNXNGM2REaXppZkpwQ1BlOWpranA3S2RRWnlfVG9rZW46STl1Y2JUUEhjb2FwcjJ4VVA3c2M1U2JIbkllXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>MESH_EGRESS_PORT 即如果node 发起http 请求会通过这个端口与mesh 进行http 通信，过程同上面入流量过程</p><h5 id="看一下UDS报文长啥样"><a href="#看一下UDS报文长啥样" class="headerlink" title="看一下UDS报文长啥样"></a>看一下UDS报文长啥样</h5><p>还是参考这篇<a href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">文章</a>的方法</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTExN2NmOGE1ZDQ2MmU4ODllMzdmZWUxNzE0MjNlY2JfZ2hua29rcnN3WnFKSXY5SDZrWmViZ0t5U0RIdTBFZ1VfVG9rZW46QkhyWGJjZ2JRbzJDajN4V1ZtaGN6TXZYbmFiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><ol><li>为方便后续指令执行，切到rpc.egress.sock所在文件夹，</li></ol><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTM0YTFmNTRkOTQwMzY2ZWUyMzdlODA4MGViYzlkNGNfWVQ2Y3FWRk5LVU93Y2xmWGEzeUU3V1pwYWd4aHlCOVpfVG9rZW46T252V2JVRGs3b29sSUh4dzRNN2NrSWNLbnFmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGE2ZDE0ZmYxMjA1ODU1MWQyN2RhNjc5YjUzZWJmYzFfQ2w0eGpCN3F4SHFDUTROdjFZWGtqeDkwb042YW5NbTZfVG9rZW46R3B3SWJQbm9Tb3lvN2V4T0kxOWNnWHozbk9nXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><ol><li>将给到rpc.egress.sock 的数据转发到 8089</li></ol><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmY1YTlkYTI3ZWFhZGM0NDZlMWIzYzM1YzExN2NjMzdfa0NISWFuZDEyeHVqR281ZzJybWRzdE55V2lsb2FPUEdfVG9rZW46UmNtQ2JZeUdob3AwVWt4SEpJWWNWQ1c1blVlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><ol><li>用curl 发起请求，并用tcpdump 对8089进行抓包</li></ol><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTljZjM4MjdmYjRhZmFmZmJlZmE4M2ZkNjU5NDYyYWFfcUQ5QXc1cEdwMGNpZmxTdngxVG5ZaUV2VVFoZW1rWXlfVG9rZW46QlZkbGJUR0tOb2ZCVnJ4bkdGM2NnVUlKbnpoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>注意使用curl –-unix-socket /rpc.egress.sock 时 如果不支持–-unix-socket 参数，需要使用apt-get 升级curl 版本，如无法升级，可能是linux 版本不再维护，可尝试替换基础镜像(指定高版本linux 的)进行部署后再测试 虽然位于rpc.egress.sock 所在文件夹下执行，但是前面的/ 不能省</p><p>先用tcpdump -i any -netvv port 8089 看看能不能</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDYzMGQxYTI3OWRjZTljYjZiMmE4ZjkxYjIzMWRkY2Ffd0lOelN3Sk9COFc0TjRhSWhxamxqNmZSTGVleFNEampfVG9rZW46SGo0U2I3MjBUb2hxRUt4SnZMVmM0aGJxbjRlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><p>加上-A -s , ===&gt; tcpdump -i any -A -s 0 -netvv port 8089 看看具体报文</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=N2MxNTE1ZjliYTE4ZDNhYzUzNTVmMzk3NjBmODg4MGVfc0hxdFdkTjJJRU04QVMwbURUVWNzSGZ0a1BOaDZrZDZfVG9rZW46Wk15S2J3WTZqb2RMZmp4UVBFTGNmaDdhblRmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p><h1 id="知识收获"><a href="#知识收获" class="headerlink" title="知识收获"></a>知识收获</h1><h2 id="cUrl"><a href="#cUrl" class="headerlink" title="cUrl"></a>cUrl</h2><p>cUrl <a href="https://curl.se/docs/manual.html" target="_blank" rel="noopener">命令相关参数</a></p><p>-v/–verbose 用于打印更多信息，包括发送的请求信息</p><p>-o /dev/null 把输出写到该文件中，保留远程文件的文件名</p><p>-w ‘%{size_download}\n’ 获取下载大小</p><p>--unix-socket 测试socket 地址，注意要求curl 版本7.50+，如果webshell 不支持，需要考虑更换tce基础镜像</p><h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>tcpdump -i eth0 port 3000 -nn</p><p>tcpdump -i eth0 -nn -vv</p><p>tcpdump -i lo -nn -vv</p><p><a href="https://www.cnblogs.com/zgq123456/articles/10251860.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq123456/articles/10251860.html</a></p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>lsof -i | grep LISTEN</p><p>ps -le</p><p>ps -ef | grep node</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>apt/apt-get update</p><p>apt/apt-get install 包名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题发现&quot;&gt;&lt;a href=&quot;#问题发现&quot; class=&quot;headerlink&quot; title=&quot;问题发现&quot;&gt;&lt;/a&gt;问题发现&lt;/h1&gt;&lt;p&gt;项目中需要对大数据量请求时间进行缩短优化的工作，优化过程中发现，浏览器响应报文压缩方法为br的情况会比gzip的时间要长11
      
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>历史记录功能设计</title>
    <link href="http://yoohannah.github.io/post/knowledge/historySearchDesign.html"/>
    <id>http://yoohannah.github.io/post/knowledge/historySearchDesign.html</id>
    <published>2024-03-03T07:17:37.000Z</published>
    <updated>2024-09-01T03:26:27.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>根据用户反馈，查询条件多个时，想要重新看一下上次的查询结果，操作比较繁琐，希望可以有历史查询的功能，将最近查询的n次记录可以找到，方便回溯问题</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在用户点击查询按钮的时候，将当前页面链接调接口保存起来，查询时链接会携带查询条件</p><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>&#x20;历史记录需要跟用户身份做绑定，当前天级uv可达75人，不适宜用tcc或者wcc平台进行数据存储</p><p>&#x20;所以需要申请资源进行数据存储</p><p><strong>容量</strong></p><p>&#x20;一个连接大小按照500Byte算，如果只保存最近10条记录，那么一个用户需要5000b ==&gt; 5kb</p><p>目前平台用户数以1000为底计算,一开始平台会需要 5kb * 1000 ==&gt;5000kb ==&gt; 5mb</p><p>(目前纯个人用户有530，加上以部门为单位申请的权限，各部门人数不确定)</p><p>假设半年后用户量翻倍那么存储空间需要增加一倍也就是10MB</p><p><strong>负载</strong></p><p>目前平台日pv 350,日uv 50, 大致计算一个用户一天会访问页面7次，四舍五入假设1天会进行10次查询</p><p>1个用户1天会进行10次数据库读写</p><p>那整个平台1天平均会进行500次读写，高峰假设1000次读写(75四舍五入)</p><p>平均 500 * 500 /(3600*24) ~~ 0.003kb/s 高峰1000*500/(3600*24) ~~~0.006kb/s</p><p>很低</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本来想如果数据库有数组的话，表结构就是用户id + 记录数组；</p><p>没有的话，我现在想了两种方案，</p><p>一个就是用字符串存这个数组，用户id + 记录数组字符串形式，相当于更新时要先获得这个字符串，转成数组后，看有没有10条，没有的话直接push,有的话，把时间最早的那条删除，push进数组，再转成字符串更新数据库，这样缺点就是展示的时候也得字符串转数组一下；</p><p>另一种就是用户id只和一条记录存在一起，不用一个字符串存整个10条记录，更新的时候我去拿数据的时候拿整个用户id所有的，超过10条的话就用数据库删除方法把时间早的删除了，再存进去最新的</p><p>看起来都挺麻烦</p><p>而且在实际接入数据库的过程中，还要手动执行命令行产生model相关文件</p><p>通过调研公司存储系统的各种方式，觉得redis可以更好的解决存储问题，redis支持List类型存储，</p><p>而且LPUSH, LPOP,EXPIRE方法可以很好的帮助实现数据存取更新缓存等问题,省了数据库建表等过程</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>redis可以很好的支持数据删除，在更新数据的时候重新设置过期时间即可保证删除不活跃用户的记录</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>申请redis服务，用户工号做redis的key值，key值的value即用户的查询历史记录list,</p><p>写接口: 查记录，更新记录</p><p>前端在点击查询的时候调接口更新记录</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://bytedance.feishu.cn/wiki/wikcnfEUcTwW8A3bUUQNtqUlsUd" target="_blank" rel="noopener">存储系统对比 （草稿）Storage System Comparision（Draft）</a> #</p><p><a href="https://bytedance.feishu.cn/wiki/wikcnKKISdh4ftbAj6FG24gAwCb" target="_blank" rel="noopener">数据结构与命令一览 List of data structure and commands</a> #</p><p><a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;根据用户反馈，查询条件多个时，想要重新看一下上次的查询结果，操作比较繁琐，希望可以有历史查询的功能，将最近查询的n次记录可以找到，方便回溯问
      
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 运行机制深入研究</title>
    <link href="http://yoohannah.github.io/post/knowledge/mobxlearn.html"/>
    <id>http://yoohannah.github.io/post/knowledge/mobxlearn.html</id>
    <published>2024-03-03T07:17:37.000Z</published>
    <updated>2024-09-01T03:26:27.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="追踪原理"><a href="#追踪原理" class="headerlink" title="追踪原理"></a><strong>追踪原理</strong></h1><p><a href="https://cn.mobx.js.org/best/react.html" target="_blank" rel="noopener">官方文档</a></p><p>MobX 会对在执行 <strong>跟踪函数 期间</strong> 读取的任何现有的<strong>可观察属性</strong>做出反应</p><p>“<strong>读取</strong>” 是对象属性的间接引用，可以用过 . (例如 user.name) 或者 [] (例如 user[‘name’]) 的形式完成。</p><p>“<strong>追踪函数</strong>” 是 <strong>computed 表达式、observer 组件的 render() 方法和 when、reaction 和 autorun 的第一个入参函数。</strong></p><p>“<strong>过程(during)</strong>” 意味着只追踪那些在函数执行时被读取的 observable 。这些值是否由追踪函数直接或间接使用并不重要。</p><p>换句话说，MobX 不会对其作出反应:</p><p>从 observable 获取的值，但是在追踪函数之外</p><p>在异步调用的代码块中读取的 observable</p><p>Mobx 5 以下 MobX 不会追踪还不存在的索引或者对象属性(当使用 observable 映射(map)时除外)。</p><p>所以建议总是使用 .length 来检查保护基于数组索引的访问。</p><p>所有数组的索引分配都可以检测到，但前提条件必须是提供的索引小于数组长度。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h2><p>追踪属性访问，而不是值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let message = observable(&#123;</span><br><span class="line">    title: &quot;Foo&quot;,</span><br><span class="line">    author: &#123;</span><br><span class="line">        name: &quot;Michel&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    likes: [</span><br><span class="line">        &quot;John&quot;, &quot;Sara&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjI2YjAxNTdhOWZkMmM1ZjFkOThlOTRhM2RlMWJkYjdfcnliUm9PSXdJWFZseExRcFdxNDhNaHNUcEh4dURwQ0pfVG9rZW46Ym94Y250QmJzT2ZWZkh3QzZVd05mNjlWSExmXzE3MDcxOTA3Mzk6MTcwNzE5NDMzOV9WNA" alt></p><p>mobx会追踪箭头有没有变化</p><p>如果箭头发生变化，就会执行追踪函数</p><h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><strong>使用注意</strong></h1><h2 id="处理数据时"><a href="#处理数据时" class="headerlink" title="处理数据时"></a><strong>处理数据时</strong></h2><p>1.更改没有被obserable的箭头，追踪函数不执行</p><p>2.追踪函数里使用间接引用指向obserable属性，追踪函数不执行</p><p>3.对新增的属性，可以使用set,get实现obserable</p><p>4.在异步代码中访问的obserable属性，不会引起追踪函数执行</p><pre><code>1.更改没有被obserable的箭头，追踪函数不执行autorun(() =&gt; {    console.log(message.title)})message = observable({ title: &quot;Bar&quot; }) //指向message的箭头没有被obervableautorun(() =&gt; {    message.likes;//箭头没变，又没有访问数组里面的属性})message.likes.push(&quot;Jennifer&quot;);2.追踪函数里使用间接引用指向obserable属性，追踪函数不执行var title = message.title;autorun(() =&gt; {    console.log(title) //访问箭头没有变，还是指向老值的位置})message.title = &quot;Bar&quot; //箭头改了，但autorun里没有用到const author = message.author;autorun(() =&gt; {    console.log(author.name) })message.author.name = &quot;Sara&quot;;//会执行跟踪函数，autorun里有访问name属性，这里指向name值得箭头改了message.author = { name: &quot;John&quot; };//不会执行，没有访问author属性的箭头正确使用A:autorun(() =&gt; {    console.log(message.author.name)})message.author.name = &quot;Sara&quot;;message.author = { name: &quot;John&quot; };B:function upperCaseAuthorName(author) {    const baseName = author.name;    return baseName.toUpperCase();}autorun(() =&gt; {    console.log(upperCaseAuthorName(message.author))})message.author.name = &quot;Chesterton&quot;3.异步const message = observable({ title: &quot;hello&quot; })autorun(() =&gt; {    console.log(message) //会执行两次，因为console.log是异步的，请确保始终传递不变数据 ( immutable data ) 或防御副本给 console.log。})message.title = &quot;Hello world&quot;autorun(() =&gt; {    setTimeout(        () =&gt; console.log(message.likes.join(&quot;, &quot;)), //异步执行，访问原始数据打印一次        10    )})message.likes.push(&quot;Jennifer&quot;);//不会引起autorun执行4.MobX 5 可以追踪还不存在的属性autorun(() =&gt; {    console.log(message.postDate)})message.postDate = new Date()</code></pre><h2 id="组件使用时"><a href="#组件使用时" class="headerlink" title="组件使用时"></a><strong>组件使用时</strong></h2><h3 id="子组件问题"><a href="#子组件问题" class="headerlink" title="子组件问题"></a><strong>子组件问题</strong></h3><p><strong>MobX 只会为数据是直接通过 render 存取的 observer 组件进行数据追踪</strong></p><p>所以当需要将数据传递给子组件时，要保证子组件也是一个obserable组件，可以做出反应</p><p>解决办法：</p><p>1.将子组件使用obserable函数处理</p><p>它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件</p><p>2.使用mobx-react的Obserable组件包裹子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">方法一：将子组件使用obserable函数处理</span><br><span class="line"><span class="keyword">const</span> MyComponent = observer(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span></span><br><span class="line">    &lt;SomeContainer</span><br><span class="line">        title = &#123;() =&gt; &lt;TitleRenderer message=&#123;message&#125; /&gt;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> TitleRenderer = observer(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span></span><br><span class="line">    &lt;div&gt;&#123;message.title&#125;&lt;<span class="regexp">/div&gt;&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">message.title = "Bar"</span></span><br><span class="line"><span class="regexp">方法二：使用mobx-react的Obserable组件包裹子组件</span></span><br><span class="line"><span class="regexp">const MyComponent = (&#123; message &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SomeContainer</span></span><br><span class="line"><span class="regexp">        title = &#123;() =&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Observer&gt;</span></span><br><span class="line"><span class="regexp">                &#123;() =&gt; &lt;div&gt;&#123;message.title&#125;&lt;/</span>div&gt;&#125;</span><br><span class="line">            &lt;<span class="regexp">/Observer&gt;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;</span><br><span class="line">message.title = <span class="string">"Bar"</span></span><br></pre></td></tr></table></figure><h3 id="避免在本地字段中缓存-observable"><a href="#避免在本地字段中缓存-observable" class="headerlink" title="避免在本地字段中缓存 observable"></a><strong>避免在本地字段中缓存 observable</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@observer class MyComponent extends React.component &#123;</span><br><span class="line">    author;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.author = props.message.author;//message.author发生变化时不会引起render</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;&#123;this.author.name&#125;&lt;/div&gt; //.name可以引起render</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化，使用计算属性，或者在render函数中进行间接引用</p><pre><code>@observer class MyComponent extends React.component {    @computed get author() {        return this.props.message.author    }</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.从性能上考虑，越晚进行间接引用越好</p><p>2.数组里面的是对象而不是字符串，那么对于发生在某个具体的对象中发生的变化，渲染数组的父组件将不会重新渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Message = observer((&#123; message &#125;) =&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;message.title&#125;</span><br><span class="line">        &lt;Author author=&#123; message.author &#125; /&gt;</span><br><span class="line">        &lt;Likes likes=&#123; message.likes &#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">const Author = observer((&#123; author &#125;) =&gt;</span><br><span class="line">    &lt;span&gt;&#123;author.name&#125;&lt;/span&gt;</span><br><span class="line">)</span><br><span class="line">const Likes = observer((&#123; likes &#125;) =&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;likes.map(like =&gt;</span><br><span class="line">            &lt;li&gt;&#123;like&#125;&lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">变化</th><th style="text-align:left">重新渲染组件</th></tr></thead><tbody><tr><td style="text-align:left">message.title = “Bar”</td><td style="text-align:left">Message</td></tr><tr><td style="text-align:left">message.author.name = “Susan”</td><td style="text-align:left">Author (.author 在 Message 中进行间接引用, 但没有改变)*</td></tr><tr><td style="text-align:left">message.author = { name: “Susan”}</td><td style="text-align:left">Message, Author</td></tr><tr><td style="text-align:left">message.likes[0] = “Michel”</td><td style="text-align:left">Likes</td></tr></tbody></table><h1 id="一些-对比"><a href="#一些-对比" class="headerlink" title="一些 对比"></a>一些 对比</h1><h1 id="autorun-vs-compute"><a href="#autorun-vs-compute" class="headerlink" title="autorun vs compute"></a><strong>autorun vs compute</strong></h1><p>当使用 autorun 时，所提供的函数总是立即被触发一次，然后每次它的依赖关系改变时会再次被触发</p><p>computed(function) 创建的函数只有当它有自己的观察者时才会重新计算，否则它的值会被认为是不相关的</p><p>如果一个计算值不再被观察了，例如使用它的UI不复存在了，MobX 可以自动地将其垃圾回收。</p><p>而 autorun 中的值必须要手动清理才行</p><h1 id="autorun-vs-reaction"><a href="#autorun-vs-reaction" class="headerlink" title="autorun vs reaction"></a><strong>autorun vs reaction</strong></h1><p>reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?)</p><p>它接收两个函数参数，第一个(<strong>数据</strong>函数)是用来追踪并返回数据作为第二个函数(<strong>效果</strong>函数)的输入。</p><p>传入 reaction 的第二个函数(副作用函数)当调用时会接收两个参数。</p><p>第一个参数是由 data 函数返回的值。</p><p>第二个参数是当前的 reaction，可以用来在执行期间清理 reaction</p><p>reaction 返回一个清理函数。</p><p>不同于 autorun 的是当创建时 **效果 **函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。</p><p>在执行 <strong>效果</strong>函数时访问的任何 observable 都不会被追踪。</p><p><strong>效果</strong>函数仅对<strong>数据</strong>函数中访问的数据作出反应，这可能会比实际在<strong>效果</strong>函数使用的数据要少。</p><p>此外，<strong>效果</strong> 函数只会在表达式返回的数据发生更改时触发。 换句话说: reaction需要你生产 <strong>效果</strong>函数中</p><p>所需要的东西。</p><h1 id="useObserver-vs-Observer-vs-observer"><a href="#useObserver-vs-Observer-vs-observer" class="headerlink" title="useObserver vs Observer vs observer"></a><strong>useObserver vs Observer vs observer</strong></h1><p><a href="https://juejin.im/post/6844904137167994893" target="_blank" rel="noopener">相关文档</a></p><p>1.虽然只是在返回DOM的地方使用 useObserver(), 但是，当dom中数据改变的时候，整个component都会重新render</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">  console.log(&apos;in useObserver&apos;);//点击按钮会触发执行</span><br><span class="line">  const person = useLocalStore(() =&gt; (&#123; name: &apos;John&apos; &#125;));</span><br><span class="line">  return useObserver(() =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;person.name&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; (person.name = &apos;Mike&apos;)&#125;&gt;No! I am Mike&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Observer 标签组件可以更精准的控制想要重新渲染的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default function ObservePerson() &#123;</span><br><span class="line">    console.log(&apos;in Observer&apos;);//点击按钮不会执行</span><br><span class="line">    const person = useLocalStore(() =&gt; (&#123;name: &apos;John&apos;&#125;))</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The old name is: &#123;person.name&#125; //点击按钮不会更新</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Observer&gt;&#123;() =&gt; &lt;div&gt;&#123;person.name&#125;&lt;/div&gt;&#125;&lt;/Observer&gt; //点击按钮会更新</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; (person.name = &apos;Mike&apos;)&#125;&gt;</span><br><span class="line">                    I want to be Mike</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.与useObserver相比，除了使用方法不同，目前不知道区别在哪，有时间需要探究一下</p><pre><code>const ObserverLowercasePerson: React.FC&lt;any&gt; = observer(() =&gt; {    console.log(&apos;in Observer&apos;) //点击按钮也会执行    const person = useLocalStore(() =&gt; ({name: &apos;John&apos;}));    return (        &lt;div&gt;            &lt;div&gt;The name is: {person.name}&lt;/div&gt;            &lt;button onClick={() =&gt; (person.name = &apos;Mike&apos;)}&gt;                Change name            &lt;/button&gt;        &lt;/div&gt;    )})```</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;追踪原理&quot;&gt;&lt;a href=&quot;#追踪原理&quot; class=&quot;headerlink&quot; title=&quot;追踪原理&quot;&gt;&lt;/a&gt;&lt;strong&gt;追踪原理&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://cn.mobx.js.org/best/react.ht
      
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>趋势图卡片实现原理</title>
    <link href="http://yoohannah.github.io/post/knowledge/trendCard.html"/>
    <id>http://yoohannah.github.io/post/knowledge/trendCard.html</id>
    <published>2024-03-02T07:17:37.000Z</published>
    <updated>2024-09-01T03:26:27.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>春节看板项目中有对数据进行趋势分析的展示，其中一种卡片的展示形式经过思考后可以提炼成组件向外提供服务，于是进行封装上传<a href="https://semi.bytedance.net/material/zh-CN/playground/219" target="_blank" rel="noopener">Semi物料市场</a></p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmE3Y2ExN2NlYzhlNDI5NWMxODIxODEyZjhkMjVmMjJfMm5HZG1OSVF0aUx1b2NBWGUwUm1iN0txcDkzTWJWZ0RfVG9rZW46Ym94Y25LYkFuYkhSQ3ZUMDRMbzl4SUtJdmhlXzE3MDcyMDQ3MDk6MTcwNzIwODMwOV9WNA" alt></p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ol><li>既要支持一个卡片的展现，也要支持多个卡片的展示，所以数据源应该是一个数组 list</li><li>每个卡片的大小应该是一样的，所以应该给一个统一设置卡片大小的属性 size</li><li>卡片可以静态展示，也可以有响应事件，这里先支持一个点击事件 onClick</li><li>单个卡片的功能需要展示趋势折线图，标题，提示，数量，还要支持定制颜色</li></ol><p>所以单个卡片的数据结构应该是这样的</p><table><thead><tr><th style="text-align:left">name</th><th style="text-align:left">标题名</th><th style="text-align:left">string 或者 ReactNode</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">tip</td><td style="text-align:left">提示（可选）</td><td style="text-align:left">string 或者 ReactNode</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">tipNormalShow</td><td style="text-align:left">提示图标展示方式,默认值false,鼠标滑过才展示</td><td style="text-align:left">boolean</td><td style="text-align:left">FALSE</td></tr><tr><td style="text-align:left">hoverLayer</td><td style="text-align:left">鼠标hover是否展示蒙层效果,默认false,不展示</td><td style="text-align:left">boolean</td><td style="text-align:left">FALSE</td></tr><tr><td style="text-align:left">lineColor</td><td style="text-align:left">折线的颜色,涉及渐变色计算,配置成十六进制格式</td><td style="text-align:left">string</td><td style="text-align:left">#E91E63 或者 #00B3A1根据卡片位置奇偶情况切换默认颜色</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">标题下的数据</td><td style="text-align:left">string 或者 ReactNode</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">xData</td><td style="text-align:left">折线图x轴数据</td><td style="text-align:left">Array[string或者number]</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yData</td><td style="text-align:left">折线图y轴数据</td><td style="text-align:left">Array[string或者number]</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">loading</td><td style="text-align:left">数据加载状态开启,默认false,不开启</td><td style="text-align:left">boolean</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">noDataTip</td><td style="text-align:left">没有数据时的提示</td><td style="text-align:left">string 或者 ReactNode</td><td style="text-align:left">抱歉，没有数据可展示</td></tr><tr><td style="text-align:left">errorInfo</td><td style="text-align:left">错误展示</td><td style="text-align:left">{text: ‘xxx’, color: ‘xxxx’}</td></tr></tbody></table><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>将List 传进来的数据，循环成多个卡片，将单个卡片信息，onClick 和size都传递给卡片组件</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YWRmY2QyZWQxNmYwM2ZhZGM1N2QyYTcxODQyYzYxOWRfTlRJZ01PaGJSbDBKNlJlcld0Z0NMZ1Bma2ppYTJjQkFfVG9rZW46Ym94Y255U0dhcGU2N2JkT29WQ25YNjc4RFpkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p><p>卡片根据传递进来属性的不同状态，展示相关信息</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGYzNGFmOGZiNTI0Yzg3YjRiMjg2ZmVjZGFjYTZlY2NfZ0hhdFc2SHNzQnRiUHpNTXF0NzFUQm1NUzU0M0xGOFZfVG9rZW46Ym94Y241allXOWUwOGVwVGs4a2x1Y3pPeTZiXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p><p>另外折线图依靠echart来画，所以需要根据颜色和卡片位置生产曲线配置，这里依靠getChartOption</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NzA2YmRlODRkMjBhMjE3M2JjNGZhOTIwNjhjMDQ1ZjhfTk81QTQ0WExwQTQ2TWdaaGE5NHVnSWd6ZmdYdzVTRHFfVG9rZW46Ym94Y24wZUVYeDIzZExjWEVla3ZWd0FxcVRkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p><p>计算渐变颜色同转换成rgb格式，设置透明度来实现渐变</p><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzU1YzI0YjVhMWExNWU4Nzk1MjFhOWI4M2E1ZWU2NmFfckFaNk41aURobmE2V1FOcGxuUm5pWWlVQjMydHZZT0FfVG9rZW46Ym94Y244djl1bkxXVjllaVlPWU1JMTFQR1JkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p><h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><p>在线体验地址：<a href="https://semi.bytedance.net/material/zh-CN/playground/219" target="_blank" rel="noopener">https://semi.bytedance.net/material/zh-CN/playground/219</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;春节看板项目中有对数据进行趋势分析的展示，其中一种卡片的展示形式经过思考后可以提炼成组件向外提供服务，于是进行封装上传&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>拖拽渲染问题的深入研究</title>
    <link href="http://yoohannah.github.io/post/react/dragthink.html"/>
    <id>http://yoohannah.github.io/post/react/dragthink.html</id>
    <published>2024-03-01T07:17:37.000Z</published>
    <updated>2024-09-01T03:26:27.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用拖拽组件进行拖拽排序<br>1.原展示模块内容需要进行缩略展示，具备收缩展开的能力<br>2.排序的内容复杂，需要异步获取数据，循环的时候传进去的关键值(如id)作为参数拉取数据，渲染图表</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>保留原组件渲染逻辑，同时将数据源传入排序组件（排序组件显示标题类信息代表原模块），<br>然后根据是否进入排序状态，保留二者其一，就是排序时展示排序组件，非排序时展示模块内容<br>问题</p><p>从排序状态回到正常展示状态时，因为正常展示的组件DOM在进入排序状态时被销毁<br>这时再回来，相当于从无到有要重新创建，会引起数据重新请求</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>将原展示模块组件作为排序组件项进行渲染，在进入排序状态时将展示模块高度减小，仅保留标题部分充当缩略信息展示<br>因为展示模块DOM始终存在，所以可以解决掉方案一展示模块DOM消失再创建的数据拉取问题<br>原理</p><p>DOM的新建跟更新流程不同，在这种情况下，新建过程会需要去请求接口拉数据，而如果仅仅是更新的话，可以依赖react的key的关键作用减少DOM 的重建过程，只是进行调换顺序即可<br>这里在将数据源列表渲染出来的时候，将数据的特征值赋值给key，即排序前后，展示模块key不变就不会被重新新建渲染， 只是进行排序处理<br>解决方案一产生的问题</p><p>在进入排序状态时，将展示模块组件高度设置为0，overflow：hidden，就看不到展示组件，但DOM 依然存在<br>这时再使用排序组件展示缩略信息即可</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论哪种方案，在结束排序后，都要更新数据源，但数据源里面的对象不能变，因为展示模块会依赖其中的具体对象里的信息进行数据拉取<br>即</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;使用拖拽组件进行拖拽排序&lt;br&gt;1.原展示模块内容需要进行缩略展示，具备收缩展开的能力&lt;br&gt;2.排序的内容复杂，需要异步获取数据，循环的时
      
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>学习关于产品的一些思维</title>
    <link href="http://yoohannah.github.io/post/knowledge/product.html"/>
    <id>http://yoohannah.github.io/post/knowledge/product.html</id>
    <published>2022-09-03T09:57:25.000Z</published>
    <updated>2024-09-01T03:26:27.572Z</updated>
    
    <content type="html"><![CDATA[<p>产品经理决策力工具</p><p>象限法：<br>把想做的事情拆成两个指标去做<br>让这个两个指标做xy轴<br>在xy轴包围的空间内，分成四个象限<br>把要做的事情按照xy轴的值分布在四个象限中<br>然后决定要在四个象限中寻找最优解</p><p>假设思维: 把未来要做的事情一步一步的假设出来<br>用户思维： 用使用者的思维设计功能</p><p>产品路线图roadmap4个核心要素</p><ol><li>里程碑是要有意义的</li><li>跟各个方向的工作协同进行</li><li>可能不是串行的而是并行的，需要准备多种方案</li><li>基于产品框架</li></ol><p>五张图说明产品</p><ol><li>核心功能体验图，主要功能的流程图</li><li>模块图，将功能具体的实现划分不同模块，即可以概览具备的的功能，也方便进行任务分配</li><li>功能树，一个模块具体具备的功能内容，相当于再细分</li><li>页面关系图，页面的操作流程，可以跟功能树对比查看是否有功能遗漏，上面提到的模块功能树都会最终落到页面上</li><li>交互设计图，不是最重要的，但要有自解释性，每个人都能看懂</li></ol><p>用户留存率—-&gt; 指标之王<br>算法</p><ol><li>新增留存率 所有新用户中有多少比例下个时间周期会出现</li><li>活跃留存率 所有用户中（活跃用户），包括新用户，有多少比例会在下个时间周期出现，即有多少人会成为下个周期的活跃用户<br>统计分析<br>用户活跃度<br>cohort， 横纵都是第1-n周<br>每一行代表当前周用户留存率再往后几周的留存率请款<br>每一列代表当前周中，阁用户留存率情况，可以看到每周留存率在这一周的变化情况<br>对角线从左上到右下，上面数据表示次周留存率，如果呈下降趋势，说明产品在新客中粘性在下降，留存率整体在下降<br>将对角线数据处理形成折线图可直观看到用户留存趋势</li></ol><p>RFM,用户贡献值（下了多少单，总消费金额…），根据用户贡献值可采取不同的营销策略</p><p>DAU,WAU,MAU,日、周、月活跃用户，一般让DAY/MAU的值作为一个用户粘性的指标<br>以DAY/MAU为y轴，DAU为x轴，形成折线趋势图，让趋势保持稳定上升是一个产品的发展方向</p><p>如何提升留存？<br>不要去想现有总用户如何去留存，去观察哪些用户值得留存，想办法让这些用户实现留存提升</p><p>设计一套CRM系统<br>CRM系统： 维护公司与客户关系 ===&gt; 用户运营战略执行系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;产品经理决策力工具&lt;/p&gt;
&lt;p&gt;象限法：&lt;br&gt;把想做的事情拆成两个指标去做&lt;br&gt;让这个两个指标做xy轴&lt;br&gt;在xy轴包围的空间内，分成四个象限&lt;br&gt;把要做的事情按照xy轴的值分布在四个象限中&lt;br&gt;然后决定要在四个象限中寻找最优解&lt;/p&gt;
&lt;p&gt;假设思维: 把未来
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>redis 学习的一些笔记</title>
    <link href="http://yoohannah.github.io/post/knowledge/redis.html"/>
    <id>http://yoohannah.github.io/post/knowledge/redis.html</id>
    <published>2022-08-09T13:30:15.000Z</published>
    <updated>2024-09-01T03:26:27.574Z</updated>
    
    <content type="html"><![CDATA[<p>基础常识<br>磁盘<br>寻址：ms<br>带宽： G/M<br>内存<br>寻址：ns(纳秒级)<br>带宽：byte/s<br>秒&gt;毫秒&gt;微秒&gt;纳秒<br>磁盘寻址上比内存少了10w倍</p><p>I/O BUffer：成本问题<br>磁盘有磁道和扇区，一个扇区512byte<br>会造成索引成本增大<br>因此进行4K对齐，操作系统无论读多少都最少从磁盘里面拿4k出来</p><p>数据库的表很大，性能会下降吗？<br>如果表有索引，<br>那么对于增删改的操作肯定会变慢<br>查询速度<br>如果是1个或者少量查询依然很快<br>但如果是并发大的时候会受到硬盘带宽的影响，从而影响速度</p><p>数据在内存和磁盘中体积不一样</p><p>redis出现原因：<br>内存 ==&gt;  贵<br>磁盘 ==&gt;  慢<br>两个基础设施限制：<br>冯诺依曼体系的硬件制约 ===&gt; 硬盘io带宽问题<br>以太网，tcp/ip的网络 ===&gt; 不稳定</p><p><a href="https://db-engines.com/en/" target="_blank" rel="noopener">https://db-engines.com/en/</a></p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><p>上述数据类型是指value的数据类型<br>memcache 和redis区别在于，memcache value没有类型<br>将返回value所有数据到client端，会受到server 网卡IO的限制，而且client要有解码的逻辑<br>redis因为value有类型，所以对于数据的请求根据不同情况直接调用相应类型方法返回少量数据即可<br>做到了计算向数据移动</p><p>redis是单进程，单线程，单实例的，通过epoll快速处理并发请求<br>epoll是同步非阻塞的多路复用机制<br>jvm: 一个线程成本是1MB<br>线程多了会增加调度成本，从而使CPU浪费，也会增加内存成本<br>BIO—&gt;NIO（同步非阻塞）—&gt;多路复用—&gt;epoll(引入共享空间避免fd相关数据考来考去)</p><p>redis 对不同数据类型不同encoding类型的数值具有不同的方法<br>key有两个属性：<br>type标识值的类型<br>encoding标识值的编码类型<br>二者决定对值的操作可以使用哪些方法，从而加速计算</p><p>String 类型<br>字符串的相关操作：<br>set,get,append,setRange,getRange,strlen<br>适用场景：<br>使用内存存储的session，对象，小文件</p><p>数值的相关操作：<br>incr,decr<br>适用场景：<br>限流，计数<br>秒杀一般会用数据库</p><p>bitmap的相关操作：<br>setbit, bitcount,bitpos,bittop<br>使用场景：web, 离线数据<br>1.用户系统，统计用户登录天数，且窗口随机<br>key标识用户，每个用户准备365位，每一位表示当天是否登录，登录置一<br>setbit sean 1 1<br>setbit sean 7 1<br>setbit sean 364 1<br>STRLEN sean ===&gt;46 每个用户只需要46个字节来存储这些信息<br>BITCOUNT sean -2 -1 计算多少天范围内一共登录了几天</p><ol start="2"><li><p>电商做618活动，需要给活跃用户登录后送礼物，请问应该备货多少礼物<br>假设这里活跃用户统计规则为20220901-20220903三天内登录的用户，三天内只要登录一次就算活跃用户<br>key标识当天用户登录情况，将用户编号映射到二进制位的相应位置上，每一位二进制代表一位用户是否登录<br>setbit 20220901 1 1<br>setbit 20220902 1 1<br>setbit 20220902 7 1<br>bittop or destkey 20220901 20220902<br>bitcount destkey 0 -1</p></li><li><p>存储oa权限信息</p></li><li>布隆过滤器，模块调用</li></ol><p>List 类型相关操作<br>按不同放入顺序排列<br>栈：同向命令<br>队列：反向命令<br>数组<br>阻塞，单播队列<br>ltrim<br>使用场景：<br>数据共享，迁出<br>无状态</p><p>Hash类型<br>对filed进行数值计算<br>场景：<br>点赞，收藏，详情页<br>聚合场景</p><p>Set类型<br>无序去重集合<br>元素变多扩容，会触发rehash，造成原顺序颠倒不稳定<br>集合操作多<br>随机事件：<br>RANDMEMBER key count<br>正数：取出一个去重的结果集(不能超过已有集)<br>负数：取出一个带重复的结果集，一定满足你要的数量<br>如果是0，不返回<br>应用场景：<br>随机事件==&gt;抽奖：<br>10个精品，参与人数&gt; 10 时，传正数，得到10个随机不重复值<br>10个精品，参与人数&lt; 10 时，传负数，得到10个可重复的值<br>中奖是否重复<br>Spop 不重复取出一个<br>推荐系统：<br>共同好友：交集<br>推荐好友：差集</p><p>Sorted set<br>排序<br>物理内存左小右大（根据分值从左到右从小到大）<br>不随命令发生变化<br>集合操作（并集，交集）权重、聚合指令<br>排序是怎么实现的。 ==&gt; skip List 跳跃表<br>增删改查的速度<br>场景：<br>排行榜，<br>有序事件<br>评论+分页</p><p>redis持久化<br>持久化意味着性能会下降<br>两个指标<br>快照：rdb,恢复的速度快，但缺失的多<br>日志：aof, ，<br>满足完整性好，恢复速度变慢，===&gt;采用不同日志策略避免<br>指令追加造成冗余量比较大 ===&gt; 使用重写</p><p>redis 分布式集群<br>可用性：<br>单点故障可通过主从主备一变多集群构建镜像，需要同步<br>强一致性，会破坏使用性<br>弱一致性，可用性强，但同步一致性低（默认）<br>最终一致性，使用黑盒可靠集群做中间缓存，保证主从数据最终一致性<br>数据存储压力问题(装不下)，采用分片式集群代理集群，也是一变多，但不需要同步</p><p>AkF拆分原则<br>根据业务划分数据到不同redis实例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基础常识&lt;br&gt;磁盘&lt;br&gt;寻址：ms&lt;br&gt;带宽： G/M&lt;br&gt;内存&lt;br&gt;寻址：ns(纳秒级)&lt;br&gt;带宽：byte/s&lt;br&gt;秒&amp;gt;毫秒&amp;gt;微秒&amp;gt;纳秒&lt;br&gt;磁盘寻址上比内存少了10w倍&lt;/p&gt;
&lt;p&gt;I/O BUffer：成本问题&lt;br&gt;磁盘有磁道和
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>系统设计案例</title>
    <link href="http://yoohannah.github.io/post/knowledge/systemDesign.html"/>
    <id>http://yoohannah.github.io/post/knowledge/systemDesign.html</id>
    <published>2022-02-02T01:31:06.000Z</published>
    <updated>2024-09-01T03:26:27.576Z</updated>
    
    <content type="html"><![CDATA[<p>案例：用户将存储内容粘贴到站点，站点给用户返回一个短地址，用户通过短地址，可以访问之前粘贴的内容或者跳转之前的原始站点</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol><li><p>对于用户来说操作要简单，生成的短地址要简单，而且要唯一，不同用户即使内容一样也要生成唯一的短地址</p></li><li><p>时间有效性，从存储角度来说，不可能一直帮用户存储所有生成的短地址，不然存储会越来越大，所以通过设置短地址有效的访问时间，可以减少存储成本</p></li></ol><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ol><li>可用性(high Availability)， 保障用户功能可用</li><li>低延时(low latency)，用户拿到短地址或者通过短地址跳转其他网站时，重定向时间不宜过长</li><li>安全性（non guessable），不能被猜出来，用户在生成一定短地址时如果携带一些个人信息，不应体现在短地址中，否则会造成用户信息泄露</li><li>对于ins/微博/小红书之类的社交功能还要保障一致性，博主发的照片，follower看到的内容应该是一样的</li></ol><h1 id="容量负载能力假设"><a href="#容量负载能力假设" class="headerlink" title="容量负载能力假设"></a>容量负载能力假设</h1><p>对一个用户来说，可以抽象出两个主要请求</p><ol><li>请求生成短url，我们要把请求参数或者原始信息存储起来 inbound</li><li>请求访问url，把生成的url返回给用户使用，进行重定向 outbound</li></ol><p>假设一个短地址按500byte大小存储</p><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>假设一个月会有100万个新短地址生成，<br>那么5年会产生</p><p>100万<em>5年</em>12个月 ==&gt; 约等于60亿个短地址</p><p>60亿*500byte ==&gt; 3TB 会有需要3TB大小的容量存储</p><h2 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h2><p>假设一个月有100个用户，每个用户会进行100万次访问短地址进行重定向的操作</p><p>那么每秒钟会有<br>（100 <em> 100万）/（30D </em> 24H * 3600s） ==&gt; 约等于4000个短url 要给到用户<br>同时会有<br>4000/ 100 ==&gt; 大概40个短url 需要被生成</p><p>那么服务所需要的带宽就可以计算出来</p><p>inbound : 40<em> 500 byte 约等于 20kb/s<br>outbound: 4000</em> 500 byte 约等于 20MB/s</p><h1 id="API-数据库设计"><a href="#API-数据库设计" class="headerlink" title="API 数据库设计"></a>API 数据库设计</h1><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>假设会用到简单的增删<br>生成短url createURL(api-key, originUrl, expired-Date, userId)<br>删除url  deleteURL(api-key,shortUrl)</p><h2 id="DataBase"><a href="#DataBase" class="headerlink" title="DataBase"></a>DataBase</h2><p>对于shortUrl</p><p>pk: hash<br>originUrl,<br>expired-date,<br>userId<br>…</p><p>对于user<br>pk: userId<br>name<br>…</p><h2 id="生成shortUrl"><a href="#生成shortUrl" class="headerlink" title="生成shortUrl"></a>生成shortUrl</h2><p>假如计划生成一个6个字符的短url，使用base64的加密算法的话可以生成64 ^ 6 大约640个短url,</p><p>满足之前5年会产生60个亿的唯一性需求</p><h1 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h1><p>用户 —&gt;request shortUrl generation —&gt; app</p><p>app —&gt; base64 encoding + 从key generation DB中拿一个nonUse 的key —&gt; 得到shortUrl —&gt;DB</p><p>DB —&gt; app –&gt;用户</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>2-8原则</p><p>用存储的20% 的url做cache内容，可以满足80% 的访问需求</p><h2 id="load-balance"><a href="#load-balance" class="headerlink" title="load balance"></a>load balance</h2><p>均衡流量</p><h2 id="过期后的url处理，key的处理"><a href="#过期后的url处理，key的处理" class="headerlink" title="过期后的url处理，key的处理"></a>过期后的url处理，key的处理</h2><h2 id="分布式存储，分片"><a href="#分布式存储，分片" class="headerlink" title="分布式存储，分片"></a>分布式存储，分片</h2><h2 id="对于社交功能的newFeed的推送"><a href="#对于社交功能的newFeed的推送" class="headerlink" title="对于社交功能的newFeed的推送"></a>对于社交功能的newFeed的推送</h2><p>pull / push / pull + push hybrid</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;案例：用户将存储内容粘贴到站点，站点给用户返回一个短地址，用户通过短地址，可以访问之前粘贴的内容或者跳转之前的原始站点&lt;/p&gt;
&lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="systemDesign" scheme="http://yoohannah.github.io/tags/systemDesign/"/>
    
  </entry>
  
  <entry>
    <title>如何提升应用打开速度</title>
    <link href="http://yoohannah.github.io/post/react/hooks/1129.html"/>
    <id>http://yoohannah.github.io/post/react/hooks/1129.html</id>
    <published>2021-11-29T08:20:02.000Z</published>
    <updated>2024-09-01T03:26:27.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-import-语句，定义按需加载的起始模块"><a href="#使用-import-语句，定义按需加载的起始模块" class="headerlink" title="使用 import 语句，定义按需加载的起始模块"></a>使用 import 语句，定义按需加载的起始模块</h1><p>对于这个需求，ECMA Script 标准有一个提案，专门用于动态加载模块，语法是 import(someModule)。<br>注意，这里的 import 和我们一般用于引入模块的静态声明方式不同，比如 import something from ‘somemodule’ 。<br>但这里的 import 是作为一个函数动态运行的，这个 import() 函数会返回一个 Promise。<br>这样，在模块加载成功后，就可以在 Promise 的 then 回调函数中去使用这个模块了。</p><p>虽然这只是一个提案，并没有成为标准，但是 Webpack 等打包工具利用了这样的语法去定义代码的分包。</p><p>也就是说，Webpack 实现了这样的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ProfilePage() &#123;</span><br><span class="line">  // 定义一个 state 用于存放需要加载的组件</span><br><span class="line">  const [RealPage, setRealPage] = useState(null);</span><br><span class="line">  </span><br><span class="line">  // 根据路径动态加载真正的组件实现</span><br><span class="line">  import(&apos;./RealProfilePage&apos;).then((comp) =&gt; &#123;</span><br><span class="line">    setRealPage(Comp);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 如果组件未加载则显示 Loading 状态</span><br><span class="line">  if (!RealPage) return &apos;Loading....&apos;;</span><br><span class="line">  </span><br><span class="line">  // 组件加载成功后则将其渲染到界面</span><br><span class="line">  return &lt;RealPage /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>import() 这个语句完全是由 Webpack 进行处理的。</p><p>按需加载的实现原理：Webpack 利用了动态 import 语句，自动实现了整个应用的拆包。<br>而在实际开发中，其实并不需要关心 Webpack 是如何做到的，<br>而只需要考虑：该在哪个位置使用 import 语句去定义动态加载的拆分点。</p><p>总体需要采用的策略是：按业务模块为目标去做隔离，尽量在每个模块的起始页面去定义这个拆分点。</p><p><b>react-loadable</b>，专门用于 React 组件的按需加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from &quot;react-loadable&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个显示加载状态的组件</span><br><span class="line">function Loading(&#123; error &#125;) &#123;</span><br><span class="line">  return error ? &apos;Failed&apos; : &apos;Loading&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// 创建加载器组件</span><br><span class="line">const HelloLazyLoad = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&quot;./RealHelloLazyLoad&quot;),</span><br><span class="line">  loading: Loading,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到 Loadable 这个高阶组件主要就是两个 API。</p><p>loader：用于传入一个加载器回调，在组件渲染到页面时被执行。<br>在这个回调函数中，我们只需要直接使用 import 语句去加载需要的模块就可以了。</p><p>loading：表示用于显示加载状态的组件。在模块加载完成之前，加载器就会渲染这个组件。<br>如果模块加载失败，那么 react-loadable 会将 errors 属性传递给 Loading 组件，方便你根据错误状态来显示不同的信息给用户。</p><p>按需加载可以说是减少首屏加载时间最为有效的手段，它可以让用户在打开应用时，无需加载所有代码就能开始使用，从而提升用户体验。</p><h1 id="使用-service-worker-缓存前端资源"><a href="#使用-service-worker-缓存前端资源" class="headerlink" title="使用 service worker 缓存前端资源"></a>使用 service worker 缓存前端资源</h1><p>和浏览器自动的资源缓存机制相比，Service Worker 加上 Cache Storage 这个缓存机制，具有更高的准确性和可靠性。</p><p>因为它可以确保两点：<br>缓存永远不过期。你只要下载过一次，就永远不需要再重新下载，除非主动删除。<br>永远不会访问过期的资源。换句话说，如果发布了一个新版本，那么你可以通过版本化的一些机制，来确保用户访问到的一定是最新的资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-import-语句，定义按需加载的起始模块&quot;&gt;&lt;a href=&quot;#使用-import-语句，定义按需加载的起始模块&quot; class=&quot;headerlink&quot; title=&quot;使用 import 语句，定义按需加载的起始模块&quot;&gt;&lt;/a&gt;使用 import 语句，定
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>一些其他小问题</title>
    <link href="http://yoohannah.github.io/post/react/hooks/question.html"/>
    <id>http://yoohannah.github.io/post/react/hooks/question.html</id>
    <published>2021-11-29T08:20:02.000Z</published>
    <updated>2024-09-01T03:26:27.599Z</updated>
    
    <content type="html"><![CDATA[<p>1.<br>在 useEffect 中如果使用了某些变量，却没有在依赖项中指定，会发生什么呢？</p><p>依赖那里没有传任何参数的话，会每次render都执行。<br>依赖项有传值但是，有部分依赖没有传，那么没有传的那部分，数据即使变化也不会执行副作用。</p><p>对于这节课中显示的 Blog 文章的例子，我们在 useEffect 中使用了 setBlogContent 这样一个函数，本质上它也是一个局部变量，那么这个函数需要被作为依赖项吗？为什么？</p><p>函数应该是不会变化的，所以不需要监听。</p><p>2.<br>useState 其实也是能够在组件的多次渲染之间共享数据的，那么在 useRef 的计时器例子中，能否用 state 去保存 window.setInterval() 返回的 timer 呢？</p><p>可以，只是没有 useRef 更优，因为在更新 state 值后会导致重新渲染，而 ref 值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。</p><p>3.<br>componentWillUnmount 近似的实现：组件销毁和文章 id 变化时执行。那么在函数组件中如果要实现严格的 componentWillUnmount，也就是只在组件销毁时执行，应该如何实现？\</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // 这里只会在组件销毁前（componentWillUnmount）执行一次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>4.<br>每次调用 useArticle 这个 Hook 的时候都会触发副作用去获取数据。<br>但是有时候，我们希望在有些组件自动获取，但有的组件中需要点击某个按钮才去获取数据，那么你会如何设计这个 Hook？（可能这道题有一点难度。）</p><p>useArticle Hook 可以提供一个参数，用来标记本地调用是否默认触发副作用去获取数据；对于点击按钮才触发请求的功能，可以在 Hook 中将获取数据的方法 retrn 出去，供外部自由调用。</p><ol start="5"><li>Hook 一般都是使用的 useState 保存了状态数据，也就意味着状态的范围限定在组件内部，组件销毁后，数据就没了。那么如果希望数据直接缓存到全局状态，应该如何做呢？</li></ol><p>可以借助 redux，配合 useContext 等 api ，将状态数据存储至全局中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;br&gt;在 useEffect 中如果使用了某些变量，却没有在依赖项中指定，会发生什么呢？&lt;/p&gt;
&lt;p&gt;依赖那里没有传任何参数的话，会每次render都执行。&lt;br&gt;依赖项有传值但是，有部分依赖没有传，那么没有传的那部分，数据即使变化也不会执行副作用。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
</feed>
