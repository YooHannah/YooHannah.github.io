<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="cache,">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="缓存的好处 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用) 浏览器本地存储与服务器端存储之间的区别其实数据既可以在浏览器本地存储，也可以在服务器端存储。 浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据">
<meta name="keywords" content="cache">
<meta property="og:type" content="article">
<meta property="og:title" content="关于缓存">
<meta property="og:url" content="http://yoohannah.github.io/post/performance/cache/cache.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:description" content="缓存的好处 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用) 浏览器本地存储与服务器端存储之间的区别其实数据既可以在浏览器本地存储，也可以在服务器端存储。 浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoohannah.github.io/image/CACHE1.png">
<meta property="og:image" content="http://yoohannah.github.io/image/CACHE2.png">
<meta property="og:updated_time" content="2024-09-01T03:26:27.581Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于缓存">
<meta name="twitter:description" content="缓存的好处 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用) 浏览器本地存储与服务器端存储之间的区别其实数据既可以在浏览器本地存储，也可以在服务器端存储。 浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据">
<meta name="twitter:image" content="http://yoohannah.github.io/image/CACHE1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/post/performance/cache/cache.html">





  <title> 关于缓存 | My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/cache.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                关于缓存
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-22T16:54:02+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a>缓存的好处</h1><p> 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间<br> 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用)</p>
<h1 id="浏览器本地存储与服务器端存储之间的区别"><a href="#浏览器本地存储与服务器端存储之间的区别" class="headerlink" title="浏览器本地存储与服务器端存储之间的区别"></a>浏览器本地存储与服务器端存储之间的区别</h1><p>其实数据既可以在浏览器本地存储，也可以在服务器端存储。</p>
<p>浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据。</p>
<p>服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。<br>1.服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。<br>2.服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。</p>
<p>服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。<br>浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。<br>服务器存储数据安全一些，浏览器只适合存储一般数据。</p>
<h1 id="http协议里面的缓存机制"><a href="#http协议里面的缓存机制" class="headerlink" title="http协议里面的缓存机制"></a>http协议里面的缓存机制</h1><p>相关首部字段</p>
<p>Expires:资源失效日期<br>收到该字段后会缓存资源，再将缓存的资源给客户端，对于以后的请求，在该时间之前，响应缓存资源，当超过该时间后，缓存服务器在请求发来时，会向服务器请求资源<br>漏洞：用户时间和服务器时间不一致的话，会造成用户资源更新不及时</p>
<p>cache-control:通过配置参数，设置缓存机制，相关参数如下：<br>public:允许多用户共享缓存<br>private：只允许特定用户使用缓存<br>no-cache:在请求中配置，告诉服务器，我不要缓存的响应,中间服务器必须从源服务器取资源;<br>在响应中配置，告诉中间服务器不能对响应进行缓存，源服务器以后对中间服务器提出的有效性校验不在进行确认<br>no-store:请求/响应中含有机密信息，不允许缓存资源<br>max-age:缓存保存时长<br>缓存保存到现在的时长小于该值，就可以返回缓存，否则像源服务器请求资源</p>
<p>last-modified:资源最终修改时间<br>服务器会比较请求的该值与资源最终修改时间，不一致的话就返回新资源，一致的话，就返回304，not modified<br>漏洞：时间精确度到秒，可能存在同一秒保存两次文件，无法区分，<br>也可能因为通过cdn,造成服务器上文件修改时间并不一致</p>
<p>E-Tag:服务器为每份资源提供的唯一性标识，相当于文件MD5值<br>服务器会跟剧请求的if-no-match与资源ttag比较，不一致返回新资源，一致返回304</p>
<p>服务器处理机制：<br>当首部字段Cache-Control有指定max-age指令，Expires也存在时，会优先处理max-age，用于判断资源是否失效<br>当判断max-age失效后，会去判断last-modified和E-Tag，如果服务器仅支持http1.0,则仅根据last-modified做校验<br>如果服务器支持http1.1,则先根据E-Tag做校验，然后在根据last-modified做校验<br><a href="https://iammapping.com/the-http-guide-of-web-cache/" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h1><p>HTML等页面文件:短效缓存，本地服务器<br>更新策略:使用no-cache</p>
<p>css、js:长效缓存，CDN<br>更新策略：在URI上添加更新标识(md5,timestamp,version)<br>MD5：不同文件MD5值如果相同，有覆盖危险<br>timestamp:文件修改/上线时间，因为可能存在不正确性，所以需要其他操作判断文件是否有变化<br>version:每次都需要更新版本号</p>
<p>Image:长效缓存,CDN<br>更新策略：使用随机名字</p>
<h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>在web storage出现前，缓存都放在cookie里面，但存储数量有限，而且每次请求都会携带一堆数据，就会占用宽带<br>工作原理<br>       当浏览器访问服务器时，服务器可以将少量数据以set-cookie消息头的方式发送给浏览器,浏览器会将这些数据临时保存下来。<br>       当浏览器再次访问服务器，会将之前保存的这些数据以cookie消息头的方式发送给服务器。<br>cookie的限制<br>     a. cookie可以被用户禁止。<br>     b. cookie不安全(对于敏感数据，需要加密)。<br>     c. cookie只能保存少量的数据(大约是4k)。<br>     d. cookie的数量也有限制(大约是几百个)。<br>     e.cookie只能保存字符串<br>生存时间问题<br>      缺省情况下，浏览器会把cookie保存在内存里面，只要浏览器不关闭，cookie就会一直存在，浏览器关闭，cookie就会被销毁。<br><a href="http://blog.csdn.net/u011637069/article/details/49799807" target="_blank" rel="noopener">相关链接</a><br><a href="http://www.cnblogs.com/kkgreen/archive/2011/04/12/2014282.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>大小有限制，数据不安全/不可信(有xss风险，存爆，读取不成功，被损坏)，不应当存放重要数据，并且要做好容错<br>可以用于跨页面通讯<br>永久性的本地存储<br>将数据保存在客户端硬件设备上，不管它是什么，意思就是下次打开计算机时候数据还在<br>localStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。</p>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>类似localStorage,但在窗口关闭后不存在<br>会话级别的本地存储<br>通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。<br>存储在sessionStorage中的数据首先是Key-Value形式的<br>另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。即窗口关闭，数据清除<br>sessionStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。<br>注意区别session机制<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识(称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用(检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应<br>中随cookie返回给客户端保存。<br>即<br>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中<br>但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>
<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器<br>会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器</p>
<h2 id="sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="sessionStorage 、localStorage 和 cookie 之间的区别"></a>sessionStorage 、localStorage 和 cookie 之间的区别</h2><p>共同点：都是保存在浏览器端，且同源的。<br>区别：<br>1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2.存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。<br>5.Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。<br>6.Web Storage 的 api 接口使用更方便。<br><a href="http://blog.csdn.net/chen_zw/article/details/18924875" target="_blank" rel="noopener">Cache-control参数解析</a></p>
<h2 id="web-SQL"><a href="#web-SQL" class="headerlink" title="web SQL"></a>web SQL</h2><p>在浏览器端创建的一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据<br>Web SQL Database 规范中定义的三个核心方法：<br>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象<br>transaction：这个方法允许我们根据情况控制事务提交或回滚<br>executeSql：这个方法用于执行SQL 查询，用SQL语句做查询索引工作<br><a href="http://www.cnblogs.com/dolphinX/p/3405335.html" target="_blank" rel="noopener">使用链接</a><br><a href="http://www.cnblogs.com/fly_dragon/p/3946012.html" target="_blank" rel="noopener">实例参考</a><br>实际上已经被废弃</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>适用持续化的数据，不会被清除的数据<br>也相当于在本地创建数据库,通过调用API接口进行数据操作，<br>在IndexedDB大部分操作并不是常用的调用方法，返回结果的模式，而是请求——响应的模式，比如打开数据库的操作<br>不会返回一个DB对象的句柄，得到的是一个IDBOpenDBRequest对象，而希望得到的DB对象在其result属性中<br>对数据的所有操作，增删改查，均通过调用api函数实现<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">MDN接口文档</a><br><a href="http://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">使用教程1</a><br><a href="http://www.cnblogs.com/dolphinX/p/3416889.html" target="_blank" rel="noopener">使用教程2</a><br>持续化存储，可在 web worker中使用</p>
<h1 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h1><h2 id="离线缓存之App-Cache"><a href="#离线缓存之App-Cache" class="headerlink" title="离线缓存之App Cache"></a>离线缓存之App Cache</h2><p>AppCache就是对app内存缓存的方案，具体表现为当请求某个文件时不是从网络获取该文件，而是从本地获取。<br>应用程序缓存为应用带来三个优势：<br>离线浏览 - 用户可在应用离线时使用它们<br>速度 - 已缓存资源加载得更快<br>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源</p>
<p>缺点：<br>可能会缓存错误页面，甚至缓存运营商的劫持广告<br>更新中有一个文件失败了，就会全部退回上一个版本<br>由于是Lazy更新，如果后台接口有break change将会是大麻烦<br>manifest文件也有可能不小心被缓存了</p>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。<br>manifest 文件可分为三个部分：<br>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存，等价于CACHE：<br>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面<br><a href="http://blog.csdn.net/liqinghua1653/article/details/31387761" target="_blank" rel="noopener">机制分析</a></p>
<h2 id="离线缓存之service-worker"><a href="#离线缓存之service-worker" class="headerlink" title="离线缓存之service worker"></a>离线缓存之service worker</h2><p>service worker 相当于在浏览器的请求层建了一个服务器，所有的请求都会进入service worker进行处理，决定资源使用缓存还是从新获取服务器资源<br>service worker可以：<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送<br>…</p>
<p>使用时必须使用HTTPS请求协议</p>
<p>在 installing 状态中，Service Worker 脚本中的 install 事件被执行。通常在安装事件中，为 document 缓存静态文件<br>处于 activating 状态期间，Service Worker 脚本中的 activate 事件被执行。通常在 activate 事件中，清理 cache 中的文件<br>如果 Service Worker 处于激活态，就可以监听事件性事件 —— fetch 和 message。<br>service worker可以通过fetch事件拦截请求，并且给出自己的响应。<br>页面和serviceWorker之间可以通过posetMessage()方法发送消息，发送的消息可以通过message事件接收到。</p>
<p>w3c提供了一个新的fetch api，用于取代XMLHttpRequest，与XMLHttpRequest最大不同有两点：</p>
<ol>
<li>fetch()方法返回的是Promise对象，通过then方法进行连续调用，减少嵌套。ES6的Promise在成为标准之后，会越来越方便开发人员。</li>
<li>提供了Request、Response对象，如果做过后端开发，对Request、Response应该比较熟悉。前端要发起请求可以通过url发起，也可以使用Request对象发起，而且Request可以复用。但是Response用在哪里呢？在service worker出现之前，前端确实不会自己给自己发消息，但是有了service worker，就可以在拦截请求之后根据需要发回自己的响应，对页面而言，这个普通的请求结果并没有区别，这是Response的一处应用。</li>
</ol>
<p>1.注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在页面文件注册</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">        // 注册Service Worker scope表示作用的页面的path</span><br><span class="line">        // register函数返回Promise</span><br><span class="line">        navigator.serviceWorker.register(&apos;./service-worker.js&apos;, &#123;scope: &apos;./&apos;&#125;)</span><br><span class="line">            .then(function (registration) &#123;</span><br><span class="line">                console.log(registration);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(function (e) &#123;</span><br><span class="line">                console.error(e);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Service Worker is not supported in this browser.&apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码检查 service worker API 是否可用，如果可用， /service-worker.js 这个文件将会作为 service worker 被注册。<br>scope表示作用的页面的path</p>
<p>2.安装使用<br>service-worker.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&apos;js/cache-polyfill.js&apos;); // cache 扩展</span><br><span class="line"></span><br><span class="line">var CACHE_VERSION = &apos;app-v1&apos;; // 缓存文件的版本</span><br><span class="line">var CACHE_FILES = [ // 需要缓存的页面文件</span><br><span class="line">    &apos;/&apos;,</span><br><span class="line">    &apos;images/background.jpeg&apos;,</span><br><span class="line">    &apos;js/app.js&apos;,</span><br><span class="line">    &apos;css/styles.css&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function (event) &#123; // 监听worker的install事件</span><br><span class="line">    event.waitUntil( // 延迟install事件直到缓存初始化完成</span><br><span class="line">        caches.open(CACHE_VERSION) //开启一个缓存</span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">                console.log(&apos;Opened cache&apos;);</span><br><span class="line">                return cache.addAll(CACHE_FILES); //缓存文件</span><br><span class="line">                //这个过程是通过一连串 promise （caches.open 和 cache.addAll）完成的。</span><br><span class="line">                //event.waitUntil 会拿到一个 promise ，并使用其来获取安装耗费的时间以及是否安装成功。</span><br><span class="line">                //如果所有的文件都缓存成功，service worker 就安装成功了。</span><br><span class="line">                //如果任何一个文件下载失败，那么安装步骤就会失败。这个方式依赖于自己指定的资源，但这意味着，需要非常仔细地确定哪些文件需要被缓存。</span><br><span class="line">                //指定了太多文件的话，会增加失败率</span><br><span class="line">                //可以在 install 事件中执行其他操作，甚至忽略 install 事件</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123; // 监听worker的activate事件,正在激活状态会触发该事件，更新service worker时，也会触发</span><br><span class="line">    event.waitUntil( // 延迟activate事件直到</span><br><span class="line">        caches.keys().then(function(keys)&#123;</span><br><span class="line">            return Promise.all(keys.map(function(key, i)&#123; // 清除旧版本缓存</span><br><span class="line">                if(key !== CACHE_VERSION)&#123;</span><br><span class="line">                    return caches.delete(keys[i]);</span><br><span class="line">                    //需要在 activate 的 callback 中进行 cache 管理，来清理老的 cache。</span><br><span class="line">                    //在 activate 而不是 install 的时候进行的原因，是如果在 install 的时候进行清理，</span><br><span class="line">                    //那么老的 service worker 仍然在控制页面，他们依赖的缓存就失效了，因此就会突然被停止</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123; // 截取页面的资源请求</span><br><span class="line">    event.respondWith( // 返回页面的资源请求</span><br><span class="line">        caches.match(event.request).then(function(res)&#123; // 判断缓存是否命中</span><br><span class="line">            if(res)&#123;  // 返回缓存中的资源</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            requestBackend(event); // 执行请求备份操作</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function requestBackend(event)&#123;  // 请求备份操作</span><br><span class="line">    var url = event.request.clone();</span><br><span class="line">    return fetch(url).then(function(res)&#123; // 请求线上资源</span><br><span class="line">        //if not a valid response send the error</span><br><span class="line">        //确保 response 有效</span><br><span class="line">				//检查 response 的状态是200</span><br><span class="line">				//确保 response 的类型是 basic 类型的，这说明请求是同源的，这意味着第三方的请求不能被缓存。</span><br><span class="line">        if(!res || res.status !== 200 || res.type !== &apos;basic&apos;)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var response = res.clone();</span><br><span class="line">        //如果检查通过会clone 这个请求。</span><br><span class="line">        //这么做的原因是如果 response 是一个 Stream，那么它的 body 只能被消费一次。</span><br><span class="line">        //所以为了让浏览器跟缓存都使用这个body,必须克隆这个 body，一份到浏览器，一份到缓存中缓存</span><br><span class="line"></span><br><span class="line">        caches.open(CACHE_VERSION).then(function(cache)&#123; // 缓存从线上获取的资源</span><br><span class="line">            cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>service worker 更新步骤：<br>1.更新 service worker 的 JavaScript 文件<br>  当用户浏览你的网站时，浏览器尝试在后台重新下载 service worker 的脚本文件。<br>  经过对比，只要服务器上的文件和本地文件有一个字节不同，这个文件就认为是新的。<br>2.之后更新后的 service worker 启动并触发 install 事件。<br>3.此时，当前页面生效的依然是老版本的 service worker，新的 service worker 会进入 “waiting” 状态。<br>4.当页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面<br>5.一旦新的 service worker 生效后会触发 activate 事件。</p>
<p>关于 service worker 的一些注意点：<br>1.service worker 是一个JavaScript worker ,所以它不能直接访问 DOM 。相反, service worker 可以通过postMessage 接口与跟其相关的页面进行通信,发送消息,从而让这些页面在有需要的时候去操纵 DOM 。<br>2.Service worker 是一个可编程的网络代理，允许你去控制如何处理页面的网络请求。<br>3.Service worker 在不使用时将被终止，并会在需要的时候重新启动，因此你不能把onfetch 和 onmessage事件来作为全局依赖处理程序。如果你需要持久话一些信息并在重新启动Service worker后使用他，可以使用 IndexedDBAPI ，service worker 支持。 　　<br>4.Service worker 广泛使用了 promise<br>缺点：<br>如果安装失败了，没有一个很好的方式来知晓<br>fetch api()目前仅支持Service Workers中使用<br>fetch() 中不会被触发重定向<br>页面在改变 hash 时，service worker 会停止工作</p>
<p><a href="https://segmentfault.com/a/1190000006061528" target="_blank" rel="noopener">Service Worker 生命周期</a><br><a href="https://zhuanlan.zhihu.com/p/20040372" target="_blank" rel="noopener">Service Worker那些事</a><br><a href="https://zhuanlan.zhihu.com/p/27264234" target="_blank" rel="noopener">深入了解 Service Worker</a><br><a href="http://www.alloyteam.com/2016/01/9274/" target="_blank" rel="noopener">Service Worker初体验</a><br><a href="https://serviceworke.rs/" target="_blank" rel="noopener">serviceworke Introduction</a></p>
<h2 id="离线缓存之-Hybrid-Cache离线包"><a href="#离线缓存之-Hybrid-Cache离线包" class="headerlink" title="离线缓存之 Hybrid Cache离线包"></a>离线缓存之 Hybrid Cache离线包</h2><p>前端开发”就是使用 HTML、CSS、JS 技术给一个网站或 Web 应用开发图形用户界面<br>所以，前端应用本质上一个 GUI 程序，而 GUI 程序有三种典型形态：<br>Web : 以浏览器为运行环境，基于浏览器内核支持的编程语言、API 来实现，被浏览器解释执行<br>Native : 以操作系统为运行环境，基于操作系统原生支持的编程语言、API 接口实现，以二进制包的形式运行<br>Hybird : 基于 Native 应用提供的一个支持 HTML、CSS、JS 的容器开发的应用，相当与用开发 Web 的方式开发 Native 应用</p>
<p>原理：<br>1.o2o 在线资源抓取程序：基于 phantomjs 解析资源<br>2.grunt-inc-offline 增量包计算器：基于 git-diff 的增量包运算<br>3.离线包生成器<br><img src="/image/CACHE1.png" alt="CACHE1"><br>1.o2o 定时程序监听线上页面变更，将其所携带的资源（HTML、CSS、JS 和部分图片）抓取下来<br>2.增量包计算器会计算好与之前若干版本之间的增量文件，配合包生成器将增量包逐一构建打包，同时生成好每个增量包的 Diff Json<br>3.调用 Clam 命令通过 Gitlab 将资源包部署至 CDN，以备手机端更新。<br>4.Gitlab 仓库 的更新会触发一个 Hook 脚本，调用 tSync 服务器的接口，来通知资源变更<br>5.tSync 服务器沙箱完成消息封装，包括了第二步生成了的 Diff Json 文本<br>6.tSync 长连接将消息指令下发给手机终端<br>7.手机终端拼好资源文件链接，从 CDN 将增量包更新下来，随后执行 Diff Json中的指令，完成包的更新。</p>
<p>手机端的两个重要进程：</p>
<p>1.资源预加载进程：在实际访问页面之前，将资源预加载到缓存池并更新 Cache Map<br>2.创建 WebView 进程：只聚焦本地资源读写，别的什么也不干<br>手机端 touch 到网络的环节收敛到了两处，第一，Package Update Controller，第二，WebView 本身必要的网络请求<br><img src="/image/CACHE2.png" alt="CACHE2"><br><a href="https://yq.aliyun.com/articles/2939" target="_blank" rel="noopener">相关链接</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cache/" rel="tag"># cache</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/react/EventEmitter.html" rel="next" title="实现一个 EventEmitter">
                <i class="fa fa-chevron-left"></i> 实现一个 EventEmitter
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/angular/angular-digest.html" rel="prev" title="AngularJS Digest">
                AngularJS Digest <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">232</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存的好处"><span class="nav-number">1.</span> <span class="nav-text">缓存的好处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器本地存储与服务器端存储之间的区别"><span class="nav-number">2.</span> <span class="nav-text">浏览器本地存储与服务器端存储之间的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http协议里面的缓存机制"><span class="nav-number">3.</span> <span class="nav-text">http协议里面的缓存机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#资源缓存"><span class="nav-number">4.</span> <span class="nav-text">资源缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据缓存"><span class="nav-number">5.</span> <span class="nav-text">数据缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie"><span class="nav-number">5.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#localStorage"><span class="nav-number">5.2.</span> <span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SessionStorage"><span class="nav-number">5.3.</span> <span class="nav-text">SessionStorage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sessionStorage-、localStorage-和-cookie-之间的区别"><span class="nav-number">5.4.</span> <span class="nav-text">sessionStorage 、localStorage 和 cookie 之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#web-SQL"><span class="nav-number">5.5.</span> <span class="nav-text">web SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indexDB"><span class="nav-number">5.6.</span> <span class="nav-text">indexDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#离线缓存"><span class="nav-number">6.</span> <span class="nav-text">离线缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#离线缓存之App-Cache"><span class="nav-number">6.1.</span> <span class="nav-text">离线缓存之App Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离线缓存之service-worker"><span class="nav-number">6.2.</span> <span class="nav-text">离线缓存之service worker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离线缓存之-Hybrid-Cache离线包"><span class="nav-number">6.3.</span> <span class="nav-text">离线缓存之 Hybrid Cache离线包</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
