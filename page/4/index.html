<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/4/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/4/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1126.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1126.html" itemprop="url">
                  合理组织项目文件结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-26T16:20:02+08:00">
                2021-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>按领域组织文件夹结构</p>
<p>每增加一个新的功能，整个应用程序的复杂度不应该明显上升。这样才能保证我们的应用程序始终可扩展，可维护。</p>
<p>软件复杂度的根源完全来自复杂的依赖关系</p>
<p>从业务功能去理解，依赖可以分为两种。<br>第一种是硬依赖。如果功能 A 的实现必须基于功能 B，也就是说没有功能 B，功能 A 就是不可运行的，那么我们可以说 A 硬依赖于 B。<br>比如对于博客系统，评论功能肯定是基于文章功能的，因为评论的对象就是文章，脱离了文章，评论功能就没有意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import CommentList from &apos;./CommentList&apos;;</span><br><span class="line">function ArticleView() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;article-view&quot;&gt;</span><br><span class="line">      &lt;MainContent /&gt;</span><br><span class="line">      &lt;CommentList /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是软依赖。如果功能 B 扩展了功能 A，也就是说，没有功能 B，功能 A 自身也是可以独立工作的，只是缺少了某些能力。<br>同样对于博客应用，文章管理是主要的功能，而评论功能则可以认为是增强了文章的功能。<br>照此来看，即使没有评论功能，文章功能也是可以独立运行的。这样就可以认为文章功能软依赖于评论功能。<br>我们应该让文章功能相关的代码，不要硬依赖于评论功能的代码。</p>
<p>在业务功能上是一个软依赖，但是在代码实现层面，却往往做成了硬依赖。<br>这就导致随着功能的不断增加，整个应用变得越来越复杂，最终降低了整体的开发效率</p>
<p>让模块之间的交互不再通过硬依赖。<br>解决办法就是<br><b>扩展点机制</b>：在任何可能产生单点复杂度的模块中，通过扩展点的方式，允许其它模块为其增加功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在需要扩展的地方定义扩展点</span><br><span class="line">function ArticleView(&#123; id &#125;) &#123;</span><br><span class="line">  const &#123; article &#125; = useArticle(id);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;article-view&quot;&gt;</span><br><span class="line">      &lt;MainContent article=&#123;article&#125; /&gt;</span><br><span class="line">      &#123;/* 定义了一个名为 article.footer 的扩展点 */&#125;</span><br><span class="line">      &lt;Extension name=&quot;article.footer&quot; args=&#123;article&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在被扩展的组件里，将自己挂到扩展点上，这样就算被扩展组件直接删除，对需要扩展的功能组件来说也毫无影响</span><br><span class="line">extensionEngine.register(&apos;article.footer&apos;, article =&gt; &#123;</span><br><span class="line">  return &lt;CommentList article=&#123;article&#125; /&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>软件复杂度产生的根源，来自复杂的依赖关系。<br>随着功能的增加，系统复杂度也在不断增加，那么整个项目就会到达一个不可维护的状态。<br>所以我们首先需要从项目结构层面，去对复杂度做物理上的隔离，确保业务模块相关的代码都能在独立的文件夹中。<br>其次，我们要妥善地处理业务模块之间的依赖关系。<br>不仅需要在业务上区分硬依赖和软依赖。<br>同时呢，在技术的实现层面也要能做到模块的松耦合。<br>当然，上面的所有介绍要落实到实际的项目，还有很多细节问题需要考虑，<br>比如如何避免在单点模块定义所有的路由，如何避免一个导航菜单组件包含了所有业务功能的导航逻辑，等等。<br>总结来说，这里是整个隔离复杂度的思路，可以根据实际场景进行有针对性的思考，进而解决复杂度的问题。<br>同时更为重要的是，在进行实际项目开发，尤其是大型项目的架构设计时，一定要时刻有管理系统复杂度的意识，<br>不能只考虑功能是否实现，而不管复杂度，那样终究会导致系统越来越复杂，不断降低开发和维护的效率，甚至导致项目失败。</p>
<p><a href="https://github.com/rekit/js-plugin" target="_blank" rel="noopener">一个扩展点引擎</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1125.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1125.html" itemprop="url">
                  使用hooks封装自定义事件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-25T16:20:02+08:00">
                2021-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事件处理</p>
<p>1.原生事件</p>
<p>只要原生 DOM 有的事件，在 React 中基本都可以使用，只是写法上采用骆驼体就可以了</p>
<p>2.是不是所有的回调函数都需要用 useCallback 进行封装呢？是不是简单的回调函数就可以不用封装了呢？</p>
<p>其实是否需要 useCallback ，和函数的复杂度没有必然关系，而是和回调函数绑定到哪个组件有关。<br>这是为了避免因组件属性变化而导致不必要的重新渲染。<br>如果你的事件处理函数是传递给原生节点，那么不写 callback，也几乎不会有任何性能的影响。<br>但是如果你使用的是自定义组件，或者一些 UI 框架的组件，那么回调函数还都应该用 useCallback 进行封装。</p>
<h1 id="React-原生事件的原理：合成事件（Synthetic-Events）"><a href="#React-原生事件的原理：合成事件（Synthetic-Events）" class="headerlink" title="React 原生事件的原理：合成事件（Synthetic Events）"></a>React 原生事件的原理：合成事件（Synthetic Events）</h1><p>由于虚拟 DOM 的存在，在 React 中即使绑定一个事件到原生的 DOM 节点，事件也并不是绑定在对应的节点上，而是所有的事件都是绑定在根节点上。<br>然后由 React 统一监听和管理，获取事件后再分发到具体的虚拟 DOM 节点上。</p>
<p>在 React 17 之前，所有的事件都是绑定在 document 上的，<br>而从 React 17 开始，所有的事件都绑定在整个 App 上的根节点上，这主要是为了以后页面上可能存在多版本 React 的考虑。</p>
<p>具体来说，React 这么做的原因主要有两个。</p>
<p>第一，虚拟 DOM render 的时候， DOM 很可能还没有真实地 render 到页面上，所以无法绑定事件。<br>第二，React 可以屏蔽底层事件的细节，避免浏览器的兼容性问题。<br>同时呢，对于 React Native 这种不是通过浏览器 render 的运行时，也能提供一致的 API。</p>
<p>浏览器原生事件机制是冒泡模型。<br>无论事件在哪个节点被触发， React 都可以通过事件的 srcElement 这个属性，知道它是从哪个节点开始发出的，<br>这样 React 就可以收集管理所有的事件，然后再以一致的 API 暴露出来。</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>虽然自定义事件和原生事件看上去类似，但是两者的机制是完全不一样的：</p>
<p>原生事件是浏览器的机制；</p>
<p>而自定义事件则是纯粹的组件自己的行为，本质是一种回调函数机制。</p>
<p>Hooks 具备绑定任何数据源的能力, 通过分析事件中用到的数据，将数据进行抽离，从hooks角度去处理事件<br>可以实现定义一次，然后在任何组件中重复使用的效果<br>用hooks的思维去简化事件处理逻辑。</p>
<p>比如封装键盘输入事件<br>只要把键盘按键看做是一个不断变化的数据源，这样，就可以去实时监听某个 DOM 节点上触发的键盘事件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useEffect, useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// 使用 document.body 作为默认的监听节点</span><br><span class="line">const useKeyPress = (domNode = document.body) =&gt; &#123;</span><br><span class="line">  const [key, setKey] = useState(null);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const handleKeyPress = (evt) =&gt; &#123;</span><br><span class="line">      setKey(evt.keyCode);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 监听按键事件</span><br><span class="line">    domNode.addEventListener(&quot;keypress&quot;, handleKeyPress);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 接触监听按键事件</span><br><span class="line">      domNode.removeEventListener(&quot;keypress&quot;, handleKeyPress);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [domNode]);</span><br><span class="line">  return key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import useKeyPress from &apos;./useKeyPress&apos;;</span><br><span class="line"></span><br><span class="line">function UseKeyPressExample() =&gt; &#123;</span><br><span class="line">  const key = useKeyPress();</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;UseKeyPress&lt;/h1&gt;</span><br><span class="line">      &lt;label&gt;Key pressed: &#123;key || &quot;N/A&quot;&#125;&lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1124.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1124.html" itemprop="url">
                  应对复杂条件渲染场景
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-24T16:20:02+08:00">
                2021-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="容器模式：实现按条件执行-Hooks"><a href="#容器模式：实现按条件执行-Hooks" class="headerlink" title="容器模式：实现按条件执行 Hooks"></a>容器模式：实现按条件执行 Hooks</h1><p>把条件判断的结果放到两个组件之中，确保真正 render UI 的组件收到的所有属性都是有值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 定义一个容器组件用于封装真正的 UserInfoModal</span><br><span class="line">export default function UserInfoModalWrapper(&#123;</span><br><span class="line">  visible,</span><br><span class="line">  ...rest, // 使用 rest 获取除了 visible 之外的属性</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // 如果对话框不显示，则不 render 任何内容</span><br><span class="line">  if (!visible) return null; </span><br><span class="line">  // 否则真正执行对话框的组件逻辑</span><br><span class="line">  return &lt;UserInfoModal visible &#123;...rest&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器模式中可以看到，条件的隔离对象是多个子组件，这就意味着它通常用于一些比较大块逻辑的隔离。<br>所以对于一些比较细节的控制，其实还有一种做法，就是把判断条件放到 Hooks 中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function useUser(id) &#123;</span><br><span class="line">  const [data, setData] = useState(null);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(null);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 当 id 不存在，直接返回，不发送请求</span><br><span class="line">    if (!id) return</span><br><span class="line">    // 获取用户信息的逻辑</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样一个容器模式，我们把原来需要条件运行的 Hooks 拆分成子组件，<br>然后通过一个容器组件来进行实际的条件判断，从而渲染不同的组件，实现按条件渲染的目的。<br>这在一些复杂的场景之下，也能达到拆分复杂度，让每个组件更加精简的目的.</p>
<h1 id="使用-render-props-模式重用-UI-逻辑"><a href="#使用-render-props-模式重用-UI-逻辑" class="headerlink" title="使用 render props 模式重用 UI 逻辑"></a>使用 render props 模式重用 UI 逻辑</h1><p>render props 就是把一个 render 函数作为属性传递给某个组件，<br>由这个组件去执行这个函数从而 render 实际的内容</p>
<p>Hooks 是逻辑重用的第一选择。<br>不过在如今的函数组件情况下，Hooks 有一个局限，那就是只能用作数据逻辑的重用，<br>而一旦涉及 UI 表现逻辑的重用，就有些力不从心了，<br>而这正是 render props 擅长的地方。<br>所以，即使有了 Hooks，我们也要掌握 render props 这个设计模式的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; Popover &#125; from &quot;antd&quot;;</span><br><span class="line"></span><br><span class="line">function ListWithMore(&#123; renderItem, data = [], max &#125;) &#123;</span><br><span class="line">  const elements = data.map((item, index) =&gt; renderItem(item, index, data));</span><br><span class="line">  const show = elements.slice(0, max);</span><br><span class="line">  const hide = elements.slice(max);</span><br><span class="line">  return (</span><br><span class="line">    &lt;span className=&quot;exp-10-list-with-more&quot;&gt;</span><br><span class="line">      &#123;show&#125;</span><br><span class="line">      &#123;hide.length &gt; 0 &amp;&amp; (</span><br><span class="line">        &lt;Popover content=&#123;&lt;div style=&#123;&#123; maxWidth: 500 &#125;&#125;&gt;&#123;hide&#125;&lt;/div&gt;&#125;&gt;</span><br><span class="line">          &lt;span className=&quot;more-items-wrapper&quot;&gt;</span><br><span class="line">            and&#123;&quot; &quot;&#125;</span><br><span class="line">            &lt;span className=&quot;more-items-trigger&quot;&gt; &#123;hide.length&#125; more...&lt;/span&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">        &lt;/Popover&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里用一个示例数据</span><br><span class="line">import data from &apos;./data&apos;;</span><br><span class="line"></span><br><span class="line">function ListWithMoreExample () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;exp-10-list-with-more&quot;&gt;</span><br><span class="line">      &lt;h1&gt;User Names&lt;/h1&gt;</span><br><span class="line">      &lt;div className=&quot;user-names&quot;&gt;</span><br><span class="line">        Liked by:&#123;&quot; &quot;&#125;</span><br><span class="line">        &lt;ListWithMore</span><br><span class="line">          renderItem=&#123;(user) =&gt; &#123;</span><br><span class="line">            return &lt;span className=&quot;user-name&quot;&gt;&#123;user.name&#125;&lt;/span&gt;;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">          data=&#123;data&#125;</span><br><span class="line">          max=&#123;3&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;h1&gt;User List&lt;/h1&gt;</span><br><span class="line">      &lt;div className=&quot;user-list&quot;&gt;</span><br><span class="line">        &lt;div className=&quot;user-list-row user-list-row-head&quot;&gt;</span><br><span class="line">          &lt;span className=&quot;user-name-cell&quot;&gt;Name&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;City&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;Job Title&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;ListWithMore</span><br><span class="line">          renderItem=&#123;(user) =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">              &lt;div className=&quot;user-list-row&quot;&gt;</span><br><span class="line">                &lt;span className=&quot;user-name-cell&quot;&gt;&#123;user.name&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span&gt;&#123;user.city&#125;&lt;/span&gt;</span><br><span class="line">                &lt;span&gt;&#123;user.job&#125;&lt;/span&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">          &#125;&#125;</span><br><span class="line">          data=&#123;data&#125;</span><br><span class="line">          max=&#123;5&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1123.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1123.html" itemprop="url">
                  从 Hooks 的角度去组织异步请求
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-23T16:20:02+08:00">
                2021-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="要定义一个自己的-API-Client"><a href="#要定义一个自己的-API-Client" class="headerlink" title="要定义一个自己的 API Client"></a>要定义一个自己的 API Client</h1><p>封装整个应用中异步请求的一些通过设置，以及统一处理，方便在 Hooks 中使用。</p>
<p>通常来说，会包括以下几个方面：</p>
<ol>
<li>一些通用的 Header。比如 Authorization Token。</li>
<li>服务器地址的配置。前端在开发和运行时可能会连接不同的服务器，比如本地服务器或者测试服务器，此时这个 API Client 内部可以根据当前环境判断该连接哪个 URL。</li>
<li>请求未认证的处理。比如如果 Token 过期了，需要有一个统一的地方进行处理，这时就会弹出对话框提示用户重新登录。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">// 定义相关的 endpoint</span><br><span class="line">const endPoints = &#123;</span><br><span class="line">  test: &quot;https://60b2643d62ab150017ae21de.mockapi.io/&quot;,</span><br><span class="line">  prod: &quot;https://prod.myapi.io/&quot;,</span><br><span class="line">  staging: &quot;https://staging.myapi.io/&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建 axios 的实例</span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">  // 实际项目中根据当前环境设置 baseURL</span><br><span class="line">  baseURL: endPoints.test,</span><br><span class="line">  timeout: 30000,</span><br><span class="line">  // 为所有请求设置通用的 header</span><br><span class="line">  headers: &#123; Authorization: &quot;Bear mytoken&quot; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 听过 axios 定义拦截器预处理所有请求</span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    // 可以假如请求成功的逻辑，比如 log</span><br><span class="line">    return res;</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    if (err.response.status === 403) &#123;</span><br><span class="line">      // 统一处理未授权请求，跳转到登录界面</span><br><span class="line">      document.location = &apos;/login&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default instance;</span><br></pre></td></tr></table></figure>
<h1 id="封装远程资源"><a href="#封装远程资源" class="headerlink" title="封装远程资源"></a>封装远程资源</h1><p>将通过get方法获取的数据其实就是远程数据源，UI依赖远程数据源渲染</p>
<p>比起在组件内部直接发请求，只是把代码换了个地方，也就是写到了 Hook 里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// useArticle</span><br><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import apiClient from &quot;./apiClient&quot;;</span><br><span class="line"></span><br><span class="line">// 将获取文章的 API 封装成一个远程资源 Hook</span><br><span class="line">const useArticle = (id) =&gt; &#123;</span><br><span class="line">  // 设置三个状态分别存储 data, error, loading</span><br><span class="line">  const [data, setData] = useState(null);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(null);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 重新获取数据时重置三个状态</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setData(null);</span><br><span class="line">    setError(null);</span><br><span class="line">    apiClient</span><br><span class="line">      .get(`/posts/$&#123;id&#125;`)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        // 请求成功时设置返回数据到状态</span><br><span class="line">        setLoading(false);</span><br><span class="line">        setData(res.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((err) =&gt; &#123;</span><br><span class="line">        // 请求失败时设置错误状态</span><br><span class="line">        setLoading(false);</span><br><span class="line">        setError(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [id]); // 当 id 变化时重新获取数据</span><br><span class="line"></span><br><span class="line">  // 将三个状态作为 Hook 的返回值</span><br><span class="line">  return &#123;</span><br><span class="line">    loading,</span><br><span class="line">    error,</span><br><span class="line">    data</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import useArticle from &quot;./useArticle&quot;;</span><br><span class="line"></span><br><span class="line">const ArticleView = (&#123; id &#125;) =&gt; &#123;</span><br><span class="line">  // 将 article 看成一个远程资源，有 data, loading, error 三个状态</span><br><span class="line">  const &#123; data, loading, error &#125; = useArticle(id);</span><br><span class="line">  if (error) return &quot;Failed.&quot;;</span><br><span class="line">  if (!data || loading) return &quot;Loading...&quot;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;exp-09-article-view&quot;&gt;</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123;id&#125;. &#123;data.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;data.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了这样一个 Hook，React 的函数组件几乎不需要有任何业务的逻辑，而只是把数据映射到 JSX 并显示出来就可以了，在使用的时候非常方便。</p>
<p>在项目中，可以把每一个 Get 请求都做成这样一个 Hook。<br>数据请求和处理逻辑都放到 Hooks 中，从而实现 Model 和 View 的隔离，<br>不仅代码更加模块化，而且更易于测试和维护。</p>
<p>这样做是为了保证每个 Hook 自身足够简单。</p>
<p>一般来说，为了让服务器的返回数据满足 UI 上的展现要求，通常需要进一步处理。<br>而这个对于每个请求的处理逻辑可能都不一样，通过一定的代码重复，能够避免产生太复杂的逻辑。</p>
<p>同时呢，某个远程资源有可能是由多个请求组成的，那么 Hooks 中的逻辑就会不一样，因为要同时发出去多个请求，组成 UI 展现所需要的数据。<br>所以，将每个 Get 请求都封装成一个 Hook ，也是为了让逻辑更清楚。</p>
<p>这个模式仅适用于 Get 请求的逻辑，对于其它类型，可以使用 useAsync 这样一个自定义的 Hook，<br>同样也是用 Hook 的思想，把请求的不同状态封装成了一个数据源供组件使用。</p>
<h1 id="处理并发或串行请求"><a href="#处理并发或串行请求" class="headerlink" title="处理并发或串行请求"></a>处理并发或串行请求</h1><p>从状态变化的角度去组织异步调用。</p>
<p>函数组件的每一次 render，其实都提供了我们根据状态变化执行不同操作的机会，<br>就是利用这个机制，通过不同的状态组合，来实现异步请求的逻辑</p>
<p>利用状态的组合变化来实现并发和串行请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// useArticle 同上</span><br><span class="line">// useUser </span><br><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import apiClient from &quot;./apiClient&quot;;</span><br><span class="line"></span><br><span class="line">export default (id) =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(null);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(null);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 当 id 不存在，直接返回，不发送请求</span><br><span class="line">    if (!id) return;</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setData(null);</span><br><span class="line">    setError(null);</span><br><span class="line">    apiClient</span><br><span class="line">      .get(`/users/$&#123;id&#125;`)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        setLoading(false);</span><br><span class="line">        setData(res.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((err) =&gt; &#123;</span><br><span class="line">        setLoading(false);</span><br><span class="line">        setError(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [id]);</span><br><span class="line">  return &#123;</span><br><span class="line">    loading,</span><br><span class="line">    error,</span><br><span class="line">    data</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 应用</span><br><span class="line"></span><br><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line">import CommentList from &quot;./CommentList&quot;;</span><br><span class="line">import useArticle from &quot;./useArticle&quot;;</span><br><span class="line">import useUser from &quot;./useUser&quot;;</span><br><span class="line">import useComments from &quot;./useComments&quot;;</span><br><span class="line"></span><br><span class="line">const ArticleView = (&#123; id &#125;) =&gt; &#123; </span><br><span class="line">  const &#123; data: article, loading, error &#125; = useArticle(id);</span><br><span class="line">  const &#123; data: comments &#125; = useComments(id);</span><br><span class="line">  const &#123; data: user &#125; = useUser(article?.userId);</span><br><span class="line">  if (error) return &quot;Failed.&quot;;</span><br><span class="line">  if (!article || loading) return &quot;Loading...&quot;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;exp-09-article-view&quot;&gt;</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123;id&#125;. &#123;article.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &#123;user &amp;&amp; (</span><br><span class="line">        &lt;div className=&quot;user-info&quot;&gt;</span><br><span class="line">          &lt;img src=&#123;user.avatar&#125; height=&quot;40px&quot; alt=&quot;user&quot; /&gt;</span><br><span class="line">          &lt;div&gt;&#123;user.name&#125;&lt;/div&gt;</span><br><span class="line">          &lt;div&gt;&#123;article.createdAt&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">      &lt;p&gt;&#123;article.content&#125;&lt;/p&gt;</span><br><span class="line">      &lt;CommentList data=&#123;comments || []&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  const [id, setId] = useState(1);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;exp-09-article-view-wrapper&quot;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; setId(1)&#125;&gt;Article 1&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; setId(2)&#125;&gt;Article 2&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; setId(3)&#125;&gt;Article 3&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; setId(4)&#125;&gt;Article 4&lt;/li&gt;</span><br><span class="line">        &lt;li onClick=&#123;() =&gt; setId(5)&#125;&gt;Article 5&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;ArticleView id=&#123;id&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>useArticle 和 useComments属于并发请求；useArticle 和 useUser属于串行请求，</p>
<p>之所以useUser能在article数据变化时重新执行，是因为在useUser的hook里面用useEffect做了依赖</p>
<p>或者换个角度想，把三个钩子的逻辑全部都写在应用代码里，不再封装起来，明显可以看到，<br>因为useEffect的原因，可以使获取user信息的请求，在拿到article数据后再执行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1122.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1122.html" itemprop="url">
                  复杂状态管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-22T16:20:02+08:00">
                2021-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React 的开发其实就是复杂应用程序状态的管理和开发</p>
<h1 id="复杂状态管理的两个原则"><a href="#复杂状态管理的两个原则" class="headerlink" title="复杂状态管理的两个原则"></a>复杂状态管理的两个原则</h1><p>原则一：保证状态最小化</p>
<p>在定义一个新的状态之前，都要再三拷问自己：<br>这个状态是必须的吗？是否能通过计算得到呢？<br>在得到肯定的回答后，再去定义新的状态，<br>就能避免大部分多余的状态定义问题，也就能在简化状态管理的同时，保证状态的一致性</p>
<p>比如根据关键字搜索的场景，搜索结果可以根据关键和原始数据计算得到，可以使用useMemo保存过滤结果，<br>而不是再为过滤结果声明一个state</p>
<p>原则二：避免中间状态，确保唯一数据源</p>
<p>比如在需要根据URL查询数据的场景，查询条件在url,同时页面有配置条件的交互<br>那么直接将 URL 作为唯一的数据来源，状态的读取和修改都是对 URL 直接进行操作，<br>而不是通过一个中间的状态保存条件<br>(URL 变化时，同步查询关键字到 State;State 变化时，同步查询关键字到输入框; 用户在输入框输入的时候，同步关键字到 URL 和 State),<br>这样就简化了状态的管理，保证了状态的一致性</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1117.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1117.html" itemprop="url">
                  redux的基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-17T16:20:02+08:00">
                2021-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redux-的三个基本概念"><a href="#Redux-的三个基本概念" class="headerlink" title="Redux 的三个基本概念"></a>Redux 的三个基本概念</h1><p>Redux 引入的概念其实并不多，主要就是三个：State、Action 和 Reducer。</p>
<p>其中 State 即 Store，一般就是一个纯 JavaScript Object。<br>Action 也是一个 Object，用于描述发生的动作。<br>而 Reducer 则是一个函数，接收 Action 和 State 并作为参数，通过计算得到新的 Store。</p>
<h1 id="如何在-React-中使用-Redux"><a href="#如何在-React-中使用-Redux" class="headerlink" title="如何在 React 中使用 Redux"></a>如何在 React 中使用 Redux</h1><h2 id="如何建立-Redux-和-React-的联系"><a href="#如何建立-Redux-和-React-的联系" class="headerlink" title="如何建立 Redux 和 React 的联系"></a>如何建立 Redux 和 React 的联系</h2><p>主要是两点：</p>
<ol>
<li>React 组件能够在依赖的 Store 的数据发生变化时，重新 Render；</li>
<li>在 React 组件中，能够在某些时机去 dispatch 一个 action，从而触发 Store 的更新</li>
</ol>
<p>答案：<br>借助<b>react-redux</b> 这样一个工具库，工具库的作用就是建立一个桥梁，让 React 和 Redux 实现互通。</p>
<p>在 react-redux 的实现中，为了确保需要绑定的组件能够访问到全局唯一的 Redux Store，<br>利用了 React 的 Context 机制去存放 Store 的信息。<br>通常我们会将这个 Context 作为整个 React 应用程序的根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&apos;root&apos;)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  rootElement</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Hooks 的本质就是提供了让 React 组件能够绑定到某个可变的数据源的能力。<br>在这里，当 Hooks 用到 Redux 时可变的对象就是 Store，而 useSelector 则让一个组件能够在 Store 的某些数据发生变化时重新 render.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import &#123; useSelector, useDispatch &#125; from &apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">export function Counter() &#123;</span><br><span class="line">  // 从 state 中获取当前的计数值</span><br><span class="line">  const count = useSelector(state =&gt; state.value)</span><br><span class="line"></span><br><span class="line">  // 获得当前 store 的 dispatch 方法</span><br><span class="line">  const dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line">  // 在按钮的 click 时间中去分发 action 来修改 store</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; type: &apos;counter/incremented&apos; &#125;)&#125;</span><br><span class="line">      &gt;+&lt;/button&gt;</span><br><span class="line">      &lt;span&gt;&#123;count&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; type: &apos;counter/decremented&apos; &#125;)&#125;</span><br><span class="line">      &gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Redux-处理异步逻辑"><a href="#使用-Redux-处理异步逻辑" class="headerlink" title="使用 Redux 处理异步逻辑"></a>使用 Redux 处理异步逻辑</h2><p>借助中间件机制</p>
<p>middleware 可以让你提供一个拦截器在 reducer 处理 action 之前被调用。<br>在这个拦截器中，你可以自由处理获得的 action。<br>无论是把这个 action 直接传递到 reducer，或者构建新的 action 发送到 reducer，都是可以的</p>
<p>Middleware 正是在 Action 真正到达 Reducer 之前提供的一个额外处理 Action 的机会</p>
<p>Redux 提供了 <b>redux-thunk</b> 这样一个中间件，它如果发现接受到的 action 是一个函数，那么就不会传递给 Reducer，<br>而是执行这个函数，并把 dispatch 作为参数传给这个函数，从而在这个函数中你可以自由决定何时，如何发送 Action。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 在创建 Redux Store 时指定了 redux-thunk 这个中间件</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;</span><br><span class="line">import thunkMiddleware from &apos;redux-thunk&apos;</span><br><span class="line">import rootReducer from &apos;./reducer&apos;</span><br><span class="line"></span><br><span class="line">const composedEnhancer = applyMiddleware(thunkMiddleware)</span><br><span class="line">const store = createStore(rootReducer, composedEnhancer)</span><br><span class="line"></span><br><span class="line">//dispatch action 时就可以 dispatch 一个函数用于来发送请求</span><br><span class="line"></span><br><span class="line">function fetchData() &#123;</span><br><span class="line">  return dispatch =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &apos;FETCH_DATA_BEGIN&apos; &#125;);</span><br><span class="line">    fetch(&apos;/some-url&apos;).then(res =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &apos;FETCH_DATA_SUCCESS&apos;, data: res &#125;);</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &apos;FETCH_DATA_FAILURE&apos;, error: err &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// dispatch action 时就可以 dispatch 一个函数用于来发送请求</span><br><span class="line">import fetchData from &apos;./fetchData&apos;;</span><br><span class="line"></span><br><span class="line">function DataList() &#123;</span><br><span class="line">  const dispatch = useDispatch();</span><br><span class="line">  // dispatch 了一个函数由 redux-thunk 中间件去执行</span><br><span class="line">  dispatch(fetchData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这种方式，我们就实现了异步请求逻辑的重用。那么这一套结合 redux-thunk 中间件的机制，我们就称之为异步 Action.</p>
<h2 id="dispatch时可以传入其他参数"><a href="#dispatch时可以传入其他参数" class="headerlink" title="dispatch时可以传入其他参数"></a>dispatch时可以传入其他参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function counterReducer(state = initialState, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;counter/incremented&apos;: return &#123;value: state.value + action.payload&#125;</span><br><span class="line">        case &apos;counter/decremented&apos;: return &#123;value: state.value - action.payload&#125;</span><br><span class="line">        default: return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const incrementAction = &#123; type: &apos;counter/incremented&apos;, payload: 10 &#125;;</span><br><span class="line">store.dispatch(incrementAction); // 计数器加 10</span><br><span class="line">const decrementAction = &#123; type: &apos;counter/decremented&apos;, payload: 10 &#125;;</span><br><span class="line">store.dispatch(decrementAction); // 计数器减 10</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1116.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1116.html" itemprop="url">
                  hooks 的典型应用场景
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-16T16:20:02+08:00">
                2021-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h1><p>声明一个名字以 use 开头的函数, 并在函数中用到其他hooks。<br>Hooks 和普通函数在语义上的区别，就在于函数中有没有用到其它 Hooks（自定义或者内置，能够让组件刷新，或者去产生副作用），没有用到就是普通函数。</p>
<p>典型的四个使用场景</p>
<ol>
<li>抽取业务逻辑；</li>
<li>封装通用逻辑；</li>
<li>监听浏览器状态；</li>
<li>拆分复杂组件.</li>
</ol>
<h1 id="抽取业务逻辑"><a href="#抽取业务逻辑" class="headerlink" title="抽取业务逻辑"></a>抽取业务逻辑</h1><p>抽取具体业务逻辑到hooks中，暴露接口在组件中调用<br>一方面能让这个逻辑得到重用，另外一方面也能让代码更加语义化，并且易于理解和维护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 实现计数器业务逻辑的拆分和重用</span><br><span class="line">import &#123; useState, useCallback &#125;from &apos;react&apos;;</span><br><span class="line"> </span><br><span class="line">function useCounter() &#123;</span><br><span class="line">  // 定义 count 这个 state 用于保存当前数值</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  // 实现加 1 的操作</span><br><span class="line">  const increment = useCallback(() =&gt; setCount(count + 1), [count]);</span><br><span class="line">  // 实现减 1 的操作</span><br><span class="line">  const decrement = useCallback(() =&gt; setCount(count - 1), [count]);</span><br><span class="line">  // 重置计数器</span><br><span class="line">  const reset = useCallback(() =&gt; setCount(0), []);</span><br><span class="line">  </span><br><span class="line">  // 将业务逻辑的操作 export 出去供调用者使用</span><br><span class="line">  return &#123; count, increment, decrement, reset &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 应用</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  // 调用自定义 Hook</span><br><span class="line">  const &#123; count, increment, decrement, reset &#125; = useCounter();</span><br><span class="line"></span><br><span class="line">  // 渲染 UI</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;decrement&#125;&gt; - &lt;/button&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;reset&#125;&gt; reset &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="封装通用逻辑：useAsync"><a href="#封装通用逻辑：useAsync" class="headerlink" title="封装通用逻辑：useAsync"></a>封装通用逻辑：useAsync</h1><p>在每个需要异步请求的组件中，其实都需要重复相同的逻辑。<br>事实上，在处理这类请求的时候，模式都是类似的，通常都会遵循下面步骤：</p>
<ol>
<li>创建 data，loading，error 这 3 个 state；</li>
<li>请求发出后，设置 loading state 为 true；</li>
<li>请求成功后，将返回的数据放到某个 state 中，并将 loading state 设为 false；</li>
<li>请求失败后，设置 error state 为 true，并将 loading state 设为 false。</li>
</ol>
<p>最后，基于 data、loading、error 这 3 个 state 的数据，<br>UI 就可以正确地显示数据，或者 loading、error 这些反馈给用户了。<br>所以，通过创建一个自定义 Hook，可以很好地将这样的逻辑提取出来，成为一个可重用的模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line">// asyncFunction 真正发出请求的函数</span><br><span class="line">const useAsync = (asyncFunction) =&gt; &#123;</span><br><span class="line">  // 设置三个异步逻辑相关的 state</span><br><span class="line">  const [data, setData] = useState(null);</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  const [error, setError] = useState(null);</span><br><span class="line">  // 定义一个 callback 用于执行异步逻辑 相当于声明一个请求的函数，在需要请求数据的情况下调用</span><br><span class="line">  const execute = useCallback(() =&gt; &#123;</span><br><span class="line">    // 请求开始时，设置 loading 为 true，清除已有数据和 error 状态</span><br><span class="line">    setLoading(true);</span><br><span class="line">    setData(null);</span><br><span class="line">    setError(null);</span><br><span class="line">    return asyncFunction()</span><br><span class="line">      .then((response) =&gt; &#123;</span><br><span class="line">        // 请求成功时，将数据写进 state，设置 loading 为 false</span><br><span class="line">        setData(response);</span><br><span class="line">        setLoading(false);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((error) =&gt; &#123;</span><br><span class="line">        // 请求失败时，设置 loading 为 false，并设置错误状态</span><br><span class="line">        setError(error);</span><br><span class="line">        setLoading(false);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [asyncFunction]);</span><br><span class="line"></span><br><span class="line">  return &#123; execute, loading, data, error &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 应用</span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import useAsync from &apos;./useAsync&apos;;</span><br><span class="line"></span><br><span class="line">export default function UserList() &#123;</span><br><span class="line">  // 通过 useAsync 这个函数，只需要提供异步逻辑的实现</span><br><span class="line">  const &#123;</span><br><span class="line">    execute: fetchUsers, // fetchUsers可以在需要请求的地方去使用</span><br><span class="line">    data: users, // 返回的数据可以直接拿来渲染ui</span><br><span class="line">    loading,</span><br><span class="line">    error,</span><br><span class="line">  &#125; = useAsync(async () =&gt; &#123;</span><br><span class="line">    const res = await fetch(&quot;https://reqres.in/api/users/&quot;);</span><br><span class="line">    const json = await res.json();</span><br><span class="line">    return json.data;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  return (</span><br><span class="line">    // 根据状态渲染 UI...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用了 Hooks 能够管理 React 组件状态的能力，将一个组件中的某一部分状态独立出来，从而实现了通用逻辑的重用。</p>
<h1 id="监听浏览器状态：useScroll"><a href="#监听浏览器状态：useScroll" class="headerlink" title="监听浏览器状态：useScroll"></a>监听浏览器状态：useScroll</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 获取横向，纵向滚动条位置</span><br><span class="line">const getPosition = () =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    x: document.body.scrollLeft,</span><br><span class="line">    y: document.body.scrollTop,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const useScroll = () =&gt; &#123;</span><br><span class="line">  // 定一个 position 这个 state 保存滚动条位置</span><br><span class="line">  const [position, setPosition] = useState(getPosition());</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const handler = () =&gt; &#123;</span><br><span class="line">      setPosition(getPosition(document));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 监听 scroll 事件，更新滚动条位置</span><br><span class="line">    document.addEventListener(&quot;scroll&quot;, handler);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      // 组件销毁时，取消事件监听</span><br><span class="line">      document.removeEventListener(&quot;scroll&quot;, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import React, &#123; useCallback &#125; from &apos;react&apos;;</span><br><span class="line">import useScroll from &apos;./useScroll&apos;;</span><br><span class="line"></span><br><span class="line">function ScrollTop() &#123;</span><br><span class="line">  const &#123; y &#125; = useScroll();</span><br><span class="line"></span><br><span class="line">  const goTop = useCallback(() =&gt; &#123;</span><br><span class="line">    document.body.scrollTop = 0;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const style = &#123;</span><br><span class="line">    position: &quot;fixed&quot;,</span><br><span class="line">    right: &quot;10px&quot;,</span><br><span class="line">    bottom: &quot;10px&quot;,</span><br><span class="line">  &#125;;</span><br><span class="line">  // 当滚动条位置纵向超过 300 时，显示返回顶部按钮</span><br><span class="line">  if (y &gt; 300) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;goTop&#125; style=&#123;style&#125;&gt;</span><br><span class="line">        Back to Top</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  // 否则不 render 任何 UI</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拆分复杂组件"><a href="#拆分复杂组件" class="headerlink" title="拆分复杂组件"></a>拆分复杂组件</h1><p>拆分逻辑的目的不一定是为了重用，而可以是仅仅为了业务逻辑的隔离。</p>
<p>把 Hooks 就看成普通的函数，能隔离的尽量去做隔离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import React, &#123; useEffect, useCallback, useMemo, useState &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Select, Table &#125; from &quot;antd&quot;;</span><br><span class="line">import _ from &quot;lodash&quot;;</span><br><span class="line">import useAsync from &quot;./useAsync&quot;;</span><br><span class="line"></span><br><span class="line">const endpoint = &quot;https://myserver.com/api/&quot;;</span><br><span class="line">const useArticles = () =&gt; &#123;</span><br><span class="line">  // 使用上面创建的 useAsync 获取文章列表</span><br><span class="line">  const &#123; execute, data, loading, error &#125; = useAsync(</span><br><span class="line">    useCallback(async () =&gt; &#123;</span><br><span class="line">      const res = await fetch(`$&#123;endpoint&#125;/posts`);</span><br><span class="line">      return await res.json();</span><br><span class="line">    &#125;, []),</span><br><span class="line">  );</span><br><span class="line">  // 执行异步调用</span><br><span class="line">  useEffect(() =&gt; execute(), [execute]);</span><br><span class="line">  // 返回语义化的数据结构</span><br><span class="line">  return &#123;</span><br><span class="line">    articles: data,</span><br><span class="line">    articlesLoading: loading,</span><br><span class="line">    articlesError: error,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const useCategories = () =&gt; &#123;</span><br><span class="line">  // 使用上面创建的 useAsync 获取分类列表</span><br><span class="line">  const &#123; execute, data, loading, error &#125; = useAsync(</span><br><span class="line">    useCallback(async () =&gt; &#123;</span><br><span class="line">      const res = await fetch(`$&#123;endpoint&#125;/categories`);</span><br><span class="line">      return await res.json();</span><br><span class="line">    &#125;, []),</span><br><span class="line">  );</span><br><span class="line">  // 执行异步调用</span><br><span class="line">  useEffect(() =&gt; execute(), [execute]);</span><br><span class="line"></span><br><span class="line">  // 返回语义化的数据结构</span><br><span class="line">  return &#123;</span><br><span class="line">    categories: data,</span><br><span class="line">    categoriesLoading: loading,</span><br><span class="line">    categoriesError: error,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">const useCombinedArticles = (articles, categories) =&gt; &#123;</span><br><span class="line">  // 将文章数据和分类数据组合到一起</span><br><span class="line">  return useMemo(() =&gt; &#123;</span><br><span class="line">    // 如果没有文章或者分类数据则返回 null</span><br><span class="line">    if (!articles || !categories) return null;</span><br><span class="line">    return articles.map((article) =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ...article,</span><br><span class="line">        category: categories.find(</span><br><span class="line">          (c) =&gt; String(c.id) === String(article.categoryId),</span><br><span class="line">        ),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [articles, categories]);</span><br><span class="line">&#125;;</span><br><span class="line">const useFilteredArticles = (articles, selectedCategory) =&gt; &#123;</span><br><span class="line">  // 实现按照分类过滤</span><br><span class="line">  return useMemo(() =&gt; &#123;</span><br><span class="line">    if (!articles) return null;</span><br><span class="line">    if (!selectedCategory) return articles;</span><br><span class="line">    return articles.filter((article) =&gt; &#123;</span><br><span class="line">      console.log(&quot;filter: &quot;, article.categoryId, selectedCategory);</span><br><span class="line">      return String(article?.category?.name) === String(selectedCategory);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [articles, selectedCategory]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const columns = [</span><br><span class="line">  &#123; dataIndex: &quot;title&quot;, title: &quot;Title&quot; &#125;,</span><br><span class="line">  &#123; dataIndex: [&quot;category&quot;, &quot;name&quot;], title: &quot;Category&quot; &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function BlogList() &#123;</span><br><span class="line">  const [selectedCategory, setSelectedCategory] = useState(null);</span><br><span class="line">  // 获取文章列表</span><br><span class="line">  const &#123; articles, articlesError &#125; = useArticles();</span><br><span class="line">  // 获取分类列表</span><br><span class="line">  const &#123; categories, categoriesError &#125; = useCategories();</span><br><span class="line">  // 组合数据</span><br><span class="line">  const combined = useCombinedArticles(articles, categories);</span><br><span class="line">  // 实现过滤</span><br><span class="line">  const result = useFilteredArticles(combined, selectedCategory);</span><br><span class="line"></span><br><span class="line">  // 分类下拉框选项用于过滤</span><br><span class="line">  const options = useMemo(() =&gt; &#123;</span><br><span class="line">    const arr = _.uniqBy(categories, (c) =&gt; c.name).map((c) =&gt; (&#123;</span><br><span class="line">      value: c.name,</span><br><span class="line">      label: c.name,</span><br><span class="line">    &#125;));</span><br><span class="line">    arr.unshift(&#123; value: null, label: &quot;All&quot; &#125;);</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;, [categories]);</span><br><span class="line"></span><br><span class="line">  // 如果出错，简单返回 Failed</span><br><span class="line">  if (articlesError || categoriesError) return &quot;Failed&quot;;</span><br><span class="line"></span><br><span class="line">  // 如果没有结果，说明正在加载</span><br><span class="line">  if (!result) return &quot;Loading...&quot;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Select</span><br><span class="line">        value=&#123;selectedCategory&#125;</span><br><span class="line">        onChange=&#123;(value) =&gt; setSelectedCategory(value)&#125;</span><br><span class="line">        options=&#123;options&#125;</span><br><span class="line">        style=&#123;&#123; width: &quot;200px&quot; &#125;&#125;</span><br><span class="line">        placeholder=&quot;Select a category&quot;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Table dataSource=&#123;result&#125; columns=&#123;columns&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1115.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1115.html" itemprop="url">
                  hooks 与 生命周期
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-15T16:20:02+08:00">
                2021-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单次执行函数"><a href="#单次执行函数" class="headerlink" title="单次执行函数"></a>单次执行函数</h1><p>利用 useRef 这个 Hook，我们可以实现一个 useSingleton 这样的一次性执行某段代码的自定义 Hook</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import &#123; useRef &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 创建一个自定义 Hook 用于执行一次性代码</span><br><span class="line">function useSingleton(callback) &#123;</span><br><span class="line">  // 用一个 called ref 标记 callback 是否执行过</span><br><span class="line">  const called = useRef(false);</span><br><span class="line">  // 如果已经执行过，则直接返回</span><br><span class="line">  if (called.current) return;</span><br><span class="line">  // 第一次调用时直接执行</span><br><span class="line">  callBack();</span><br><span class="line">  // 设置标记为已执行过</span><br><span class="line">  called.current = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import useSingleton from &apos;./useSingleton&apos;;</span><br><span class="line"></span><br><span class="line">const MyComp = () =&gt; &#123;</span><br><span class="line">  // 使用自定义 Hook</span><br><span class="line">  useSingleton(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;这段代码只执行一次&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;My Component&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="useEffect与class生命周期方法联系"><a href="#useEffect与class生命周期方法联系" class="headerlink" title="useEffect与class生命周期方法联系"></a>useEffect与class生命周期方法联系</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // componentDidMount + componentDidUpdate</span><br><span class="line">  console.log(&apos;这里基本等价于 componentDidMount + componentDidUpdate&apos;);</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // componentWillUnmount</span><br><span class="line">    console.log(&apos;这里基本等价于 componentWillUnmount&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [deps])</span><br></pre></td></tr></table></figure>
<p>这个写法并没有完全等价于传统的这几个生命周期方法。主要有两个原因。</p>
<p>一方面，useEffect(callback) 这个 Hook 接收的 callback，只有在依赖项变化时才被执行。<br>而传统的 componentDidUpdate 则一定会执行。<br>这样来看，Hook 的机制其实更具有语义化，<br>因为过去在 componentDidUpdate 中，我们通常都需要手动判断某个状态是否发生变化，然后再执行特定的逻辑。</p>
<p>另一方面，<br>callback 返回的函数（一般用于清理工作）在下一次依赖项发生变化以及组件销毁之前执行，<br>而传统的 componentWillUnmount 只在组件销毁时才会执行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1112.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1112.html" itemprop="url">
                  react 自带的hooks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-12T16:20:02+08:00">
                2021-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="useCallback：缓存回调函数"><a href="#useCallback：缓存回调函数" class="headerlink" title="useCallback：缓存回调函数"></a>useCallback：缓存回调函数</h1><p>在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的</p>
<p>如果组件中依赖的处理函数没有被useCallback做缓存处理，那么每次重新执行时都会被重新创建<br>那么依赖处理函数的组件就会因为处理函数更新进行重现渲染</p>
<p>为避免频繁的重新渲染组件，useCallback的作用就是将函数缓存起来，<br>只有当函数逻辑中依赖的状态发生变化才会去重新生成，然后引起组件更新，<br>避免了依赖没有变化时的无效更新</p>
<p>useCallback 可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件。<br>如果每次都不一样就会造成组件的重新渲染。<br>但是如果确定子组件多次渲染也没有太大问题，特别是原生的组件，比如 button，<br>那么不用 useCallback 也问题不大。所以这和子组件的实现相关，和函数是否轻量无关。</p>
<h1 id="useMemo：缓存计算的结果"><a href="#useMemo：缓存计算的结果" class="headerlink" title="useMemo：缓存计算的结果"></a>useMemo：缓存计算的结果</h1><p>同处理函数类似，如果组件中用到的数据A通过其他状态值计算得到，<br>在依赖值没有发生变化情况下，其实就不用重新计算，<br>即<br>如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算<br>因此当组件因为其他原因刷新，进而重新执行函数，引起的重新计算是没有必要的</p>
<p>可以实现这个功能的hooks就是useMemo,useMemo就是只有在依赖的状态值发生变化时才会去重新执行计算的过程<br>避免不必要的重新计算过程<br>同时，对于依赖数据A的组件来说，没有重新计算产生的新值，可以在一定程度上<b>避免子组件重复渲染</b>。</p>
<p>如果将函数也看做一个状态值/变量的话，其实，useMemo可以实现useCallback的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const myEventHandler = useMemo(() =&gt; &#123;</span><br><span class="line">  // 返回一个函数作为缓存结果</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // 在这里进行事件处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [dep1, dep2]);</span><br></pre></td></tr></table></figure>
<p>二者的本质就是<br><b>建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。</b></p>
<h1 id="useRef：在多次渲染之间共享数据"><a href="#useRef：在多次渲染之间共享数据" class="headerlink" title="useRef：在多次渲染之间共享数据"></a>useRef：在多次渲染之间共享数据</h1><p>可以把 useRef 看作是在函数组件之外创建的一个容器空间<br>在这个容器上，我们可以通过唯一的 current 属设置一个值，从而在函数组件的多次渲染之间共享这个值</p>
<p><b>使用 useRef 保存的数据一般是和 UI 的渲染无关的，因此当 ref 的值发生变化时，是不会触发组件的重新渲染的，</b><br>这也是 useRef 区别于 useState 的地方。<br>比如保存定时器句柄，在回调函数中关掉定时器，然后将ref.current 设置为null, 这个句柄没有在组件中被用到，所以不会引起重新渲染。<br>但如果用useState去保存句柄，将定时器关掉时，同时将state设置为null，即使没有被组件用到，也会引起重新组件渲染。</p>
<p>useRef 还有一个重要的功能，就是保存某个 DOM 节点的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function TextInputWithFocusButton() &#123;</span><br><span class="line">  const inputEl = useRef(null);</span><br><span class="line">  const onButtonClick = () =&gt; &#123;</span><br><span class="line">    // current 属性指向了真实的 input 这个 DOM 节点，从而可以调用 focus 方法</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ref 这个属性提供了获得 DOM 节点的能力，并利用 useRef 保存了这个节点的应用</p>
<h1 id="useContext：定义全局状态"><a href="#useContext：定义全局状态" class="headerlink" title="useContext：定义全局状态"></a>useContext：定义全局状态</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const MyContext = React.createContext(initialValue);</span><br><span class="line"></span><br><span class="line">const themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: &quot;#000000&quot;,</span><br><span class="line">    background: &quot;#eeeeee&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: &quot;#ffffff&quot;,</span><br><span class="line">    background: &quot;#222222&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 创建一个 Theme 的 Context</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(themes.light);</span><br><span class="line">function App() &#123;</span><br><span class="line">  // 整个应用使用 ThemeContext.Provider 作为根组件</span><br><span class="line">  return (</span><br><span class="line">    // 使用 themes.dark 作为当前 Context </span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Toolbar 组件中使用一个会使用 Theme 的 Button</span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Theme Button 中使用 useContext 来获取当前的主题</span><br><span class="line">function ThemedButton() &#123;</span><br><span class="line">  const theme = useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button style=&#123;&#123;</span><br><span class="line">      background: theme.background,</span><br><span class="line">      color: theme.foreground</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context 提供了一个方便在多个组件之间共享数据的机制。<br>不过需要注意的是，它的灵活性也是一柄双刃剑。<br>你或许已经发现，Context 相当于提供了一个定义 React 世界中全局变量的机制，<br>而全局变量则意味着两点：</p>
<ol>
<li>会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。</li>
<li>让组件的复用变得困难，因为一个组件如果使用了某个 Context，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。</li>
</ol>
<p>需要再三强调的是，Context 更多的是提供了一个强大的机制，<b> 让 React 应用具备定义全局的响应式数据的能力。</b></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1111.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1111.html" itemprop="url">
                  如何保存组件状态和使用生命周期
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-11T16:20:02+08:00">
                2021-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="那么什么样的值应该保存在-state-中呢？"><a href="#那么什么样的值应该保存在-state-中呢？" class="headerlink" title="那么什么样的值应该保存在 state 中呢？"></a>那么什么样的值应该保存在 state 中呢？</h1><p>在一个函数组件的多次渲染之间，这个 state 是共享的。<br>这是日常开发中需要经常思考的问题。通常来说，我们要遵循的一个原则就是：state 中永远不要保存可以通过计算得到的值。<br>比如说：</p>
<ol>
<li>从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。<br>那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。</li>
<li>从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。</li>
<li>从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。</li>
</ol>
<h1 id="useEffect执行"><a href="#useEffect执行" class="headerlink" title="useEffect执行"></a>useEffect执行</h1><p>useEffect 让我们能够在下面四种时机去执行一个回调函数产生副作用：</p>
<ol>
<li>每次 render 后执行：不提供第二个依赖项参数。比如useEffect(() =&gt; {})。</li>
<li>仅第一次 render 后执行：提供一个空数组作为依赖项。比如useEffect(() =&gt; {}, [])。</li>
<li>第一次以及依赖项发生变化后执行：提供依赖项数组。比如useEffect(() =&gt; {}, [deps])。</li>
<li>组件 unmount 后执行：返回一个回调函数。比如useEffect() =&gt; { return () =&gt; {} }, [])。</li>
</ol>
<h1 id="定义依赖项注意点"><a href="#定义依赖项注意点" class="headerlink" title="定义依赖项注意点"></a>定义依赖项注意点</h1><p>那么在定义依赖项时，我们需要注意以下三点：</p>
<ol>
<li>依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。</li>
<li>依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。</li>
<li>React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。<br>如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方。</li>
</ol>
<h1 id="Hooks-的使用规则"><a href="#Hooks-的使用规则" class="headerlink" title="Hooks 的使用规则"></a>Hooks 的使用规则</h1><h2 id="只能在函数组件的顶级作用域使用"><a href="#只能在函数组件的顶级作用域使用" class="headerlink" title="只能在函数组件的顶级作用域使用"></a>只能在函数组件的顶级作用域使用</h2><p>第一，所有 Hook 必须要被执行到。第二，必须按顺序执行。</p>
<p>所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。<br>同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。<br>因为在 React 组件内部，其实是维护了一个对应组件的固定 Hooks 执行列表的，以便在多次渲染之间保持 Hooks 的状态，并做对比。<br>也不能在return语句后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function MyComp() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  if (count &gt; 10) &#123;</span><br><span class="line">    // 错误：不能将 Hook 用在条件判断里</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;, [count])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了</span><br><span class="line">  if (count === 0) &#123;</span><br><span class="line">    return &apos;No content&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 错误：不能将 Hook 放在可能的 return 之后</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  </span><br><span class="line">  //...</span><br><span class="line">  return &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hooks-只能在函数组件或者其它-Hooks-中使用"><a href="#Hooks-只能在函数组件或者其它-Hooks-中使用" class="headerlink" title="Hooks 只能在函数组件或者其它 Hooks 中使用"></a>Hooks 只能在函数组件或者其它 Hooks 中使用</h2><p>如果一定要在 Class 组件中使用，那应该如何做呢？<br>其实有一个通用的机制，那就是利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a.</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; useWindowSize &#125; from &apos;../hooks/useWindowSize&apos;;</span><br><span class="line"></span><br><span class="line">export const withWindowSize = (Comp) =&gt; &#123;</span><br><span class="line">  return props =&gt; &#123;</span><br><span class="line">    const windowSize = useWindowSize();</span><br><span class="line">    return &lt;Comp windowSize=&#123;windowSize&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; withWindowSize &#125; from &apos;./withWindowSize&apos;;</span><br><span class="line"></span><br><span class="line">class MyComp &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; windowSize &#125; = this.props;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性</span><br><span class="line">export default withWindowSize(MyComp);</span><br></pre></td></tr></table></figure>
<p>小结<br>hooks使用时应包括这么三点：</p>
<ol>
<li>在 useEffect 的回调函数中使用的变量，都必须在依赖项中声明；</li>
<li>Hooks 不能出现在条件语句或者循环中，也不能出现在 return 之后；</li>
<li>Hooks 只能在函数组件或者自定义 Hooks 中使用。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">240</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
