<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/5/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/5/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/compressMethod.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/compressMethod.html" itemprop="url">
                  关于报文压缩方法的探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-03T18:16:37+08:00">
                2024-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>项目中需要对大数据量请求时间进行缩短优化的工作，优化过程中发现，浏览器响应报文压缩方法为br的情况会比gzip的时间要长11-13s，具体表现如下</p>
<p>服务端响应用时45s</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmZmZTIyZmEzZWRkZDQ2OGZmODc5YmM5ZmJkMGM0ZGRfUGF4OE1qUElncThDQXd6SkpqVWFNY3g1MDNTcXBTdUlfVG9rZW46TW5namJPWnZ1b2F2MWZ4VFRQUmNuVXRnbk9oXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>但是浏览器<strong>等</strong>服务端返回却花了58s</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OWNkYzA0ODEyYTlmMmE3ZTQ4OGM2MTc3ZDAwZTY2MzZfS3VBYVlKNDcwWTgxSklXSTRqQVdkcW1UZHd6NWR4STJfVG9rZW46Tm80M2I4Smd2b0pmamV4QkhGdWMxU3JXbmxlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTBiZTE2NDk3ZDg1YWFmYTQ0OTM3ODYwNGZhZjIzODlfOEtIaGNvbXc4NXhDbWNHbG1oWmtXSXVaWTBKa2tRNmFfVG9rZW46RUhlV2J1UWRqb3JUN094WWRoMWNCaE5ibmJoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>这样浏览器就会比服务器响应<strong>多等</strong>了58-45= <strong>13s</strong>，不是很正常</p>
<p>现在直接拿浏览器请求的cUrl 发起请求</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ODcyYjM3NTk3MjMxYzRiNzUyYzY3MDI3ZGIyY2Y1MmFfaEJFVDNmUHFxUXlzckgxUTV5dXZ5cFZBZUhpN1Jpck5fVG9rZW46QkVpV2JrWVBlb05kYlh4R0NnNmNyQWtHbncyXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDU4ZDI1YjUzOWFmYTZkOWU0Y2U5NGJiOTJhZGMxODBfN3lDakIwSklNVnRMbmxCc2JaZkgzYzRLbzIwQW9RUThfVG9rZW46SzdCT2JVekpYb3VwcWd4VjM4SGNMcDBJbmZkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NmQ2NjE1NDk2M2NlNzMyNDkyNDgzNWE5ZDY4Yzk1YzFfWEZFVDVDZVpjSVVQMjkzbHRqZk96TFhpVDAxcGxYYktfVG9rZW46TXJiZGJCOG9zb1N4eFp4WUFlRmMwRjJobkpkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>可以看到非浏览器请求的响应使用了gzip压缩，总用时48s, 服务端用时46s, 耗时差2s</p>
<p>可见使用gzip压缩算法耗时是远优于br压缩的</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>想办法禁用掉br压缩方法</p>
<ol>
<li>指定service Mesh压缩方法</li>
</ol>
<p>第一步，检查服务集群是否开启了service mesh，开启后指定才有效</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NDQ0OGQ2OWUxZDJlNGViNTJkMDMyY2I1M2Q0YjJkOWJfcms4d0dMb0ZSSnlJYk9Nb2pVWVl4a1dDMlJwellPNTVfVG9rZW46QWdNNmJXU1gzb2ljUGZ4S1ZzUWNJTUVhbjJyXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>第二步，直接在【通用流量平台-&gt;稳定性管理】指定压缩方法</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmQwYjNiODQ2YTQ2MDM1Nzg5OGJjN2I1YzE3M2Y3NzNfM2pRbTJvOTRVblpFWDg1V3FTeUlyVkRBUWZkZ2NLT2NfVG9rZW46VlVvZWJ4NGU3bzFDd2d4blpab2M1OHdibjNkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>Service mesh 在指定压缩方法后，会对所有请求按指定的压缩算法进行压缩，不管content-length 大小，也不管上游是否已经指定了其他压缩方法，简单粗暴，适合快速解决问题</p>
<ol>
<li>TLB + 项目配置</li>
</ol>
<p>该方法是在探究原因过程中发现，过程比较曲折，需要排查修改两个地方，着急解决问题不适宜</p>
<ol>
<li>确认下自己的服务是否为node服务且有使用koa-compress插件(<strong>注意排查框架是否有默认注入</strong>)，需要将br 压缩算法关闭，具体关闭形式可能因框架不同配置姿势不同，但可以参考下插件<a href="https://github.com/koajs/compress" target="_blank" rel="noopener">官方配置</a></li>
<li>关闭TLB 路由Ngnix默认br 压缩算法配置，禁止使用br算法</li>
</ol>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MjE0NjZiZDAwOWViMmJmYjgwYjgzZmRhMWU5OGZmNzdfQUtKenJndjJZMmQySXdvdFlyRUFoeFVPNWZGSzRFSEtfVG9rZW46Q05TdmJMQml0b0NFQkd4aWx0bmNnYUZEbkZoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>虽然复杂，但是方案会比方法一更合理一些</p>
<h2 id="为什么不在发起请求时直接更改accept-encoding？"><a href="#为什么不在发起请求时直接更改accept-encoding？" class="headerlink" title="为什么不在发起请求时直接更改accept-encoding？"></a>为什么不在发起请求时直接更改accept-encoding？</h2><p>解决这个问题的另一条途径就是从源头，请求发起端就去掉相关br的设置，也就是更改accept-encoding, 让它不包含br，如果客户端不支持br 压缩，那请求响应自然是不能使用br 压缩的，但是天有不测风云，accept-encoding 是一个不能通过代码去修改的请求报文(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name" target="_blank" rel="noopener">详见</a>)，所以这条路是行不通的。</p>
<h1 id="这到底是怎么回事？"><a href="#这到底是怎么回事？" class="headerlink" title="这到底是怎么回事？"></a>这到底是怎么回事？</h1><p>虽然使用方法一可以快速彻底的解决掉问题，但是不应用方法一时，可以发现的一个明显问题就是不同请求的压缩方法不同，而且存在不使用压缩方法的情况，这就激起了作者尘封已久的好奇心，到底是谁在指定content-encoding呢？</p>
<p>接下来就需要看一下从服务端到客户端，到底是哪个环节在决定content-encoding</p>
<h2 id="Koa-compress"><a href="#Koa-compress" class="headerlink" title="Koa-compress"></a>Koa-compress</h2><p>鉴于本人node服务项目基于ACE1.X构建，在搜索代码进行排查时，并没有在配置文件中搜到相关的配置，重新查阅框架文档的时候，才注意到框架有进行<a href="https://iesfe.bytedance.net/ace-v1/fullstack/basic/middleware/#compress" target="_blank" rel="noopener">默认注入</a>，这就从服务端源头找到了一个会更改content-encoding的地方，俗话说，灯下黑，不过如此。</p>
<p>既然有使用koa-compress, 而且<a href="https://github.com/koajs/compress/tree/master/lib" target="_blank" rel="noopener">源码</a>不是很复杂，那就简单探索下它的压缩原理</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTgyZTg5MmY1NWUyMTYzNGQ1NzUxZTBiM2EzYjk4N2ZfdGRzZ3lxQW1iVTdER21JYUxzQm9iWGFGbjFlSnA4bERfVG9rZW46SUVBMGJmaWJKb2xGQkh4U0JXM2NVYmVBbkNMXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>查看源码可知，当content-length大于1024b时，会根据Accept-encoding进行压缩</p>
<p>在Accept-Encoding值是’gzip, deflate, br’情况下</p>
<p>压缩方法的选择逻辑就是accept-encoding有br 会优先使用br，如果br被禁用就使用gzip</p>
<p>由于默认注入时，没有指定压缩阈值，所以当我们的请求数据过大, 大于1024b时，自然就会触发koa-compress进行br压缩，也就是说上面问题的出现，罪魁祸首就是koa-compress</p>
<p>但是当数据量小于1024b时，又会出现br，甚至不进行压缩又是怎么回事呢？</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTk5ZjMxMTIwOTgwMTc3YzY5MjRmMjRkYjMyNDdlOGRfMHA4SlJNbDdaalBzQ1dWSXhuQXNJcXZJQTFjV2U3b0NfVG9rZW46VHBDSGJDNWZ0b2VxUW14cnFJWWNXa0ZnbkdnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDIyZTAwZjdkYmI1YTg1OWY3OGFlOTI4MzFhOWVmNzdfMmFlZGZ4S25DekNnUzhSZTB4Z2NDUVY3dVpZMWs5SFpfVG9rZW46VmV1V2JlNnZzb2hHald4M0RGTWNMYk1hbk1nXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<h3 id="whisle插曲"><a href="#whisle插曲" class="headerlink" title="whisle插曲"></a>whisle插曲</h3><p>在排查过程中，相同条件请求，在本地开启whistle代理，通过域名进行本地访问，出现了响应始终是gzip 的情况，这对于大于1024b的响应就不对了，按上面koa-compress逻辑，应该是br才对</p>
<p>经过在http\://localhost:8899/#network 抓包，可以发现whistle给本地服务的请求报文accept-encoding是不带br的</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OWVkMWNjYzMwZDE2N2ExMjNmNzFkOTk2NTgyM2U4YWJfZ1BYSnFNUGNZVkpvaGVRamZaenp0b2hKZHFqOEt2TU1fVG9rZW46UWxDRmIwT1Vqb3ViY2R4VFQwcGNDMDlwbnNiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>经过与whistle开发者请教(<a href="https://github.com/avwo/whistle/issues/950" target="_blank" rel="noopener">issue</a>)，whistle确实会篡改我们的报文，把accept-encoding中的br 去掉，这样就实现了响应始终是gzip压缩的效果，因此，在本地的测试推荐大家直接使用localhost访问，避免代理的干扰</p>
<p>以下在本地进行的测试也均是在关闭代理情况下进行</p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>根据请求响应链路，响应从node服务返回后，会依次经过Mesh, TLB然后到浏览器</p>
<p>由于mesh 在不指定压缩算法的情况下是<strong>不参与</strong>压缩的，所以对于小于1024的数据压缩，矛头指向了TLB</p>
<p>在开始验证前，先来了解下TLB的压缩原理<a href="https://bytedance.feishu.cn/docx/CgO6dfGYOo86eYxILLPcMc2MnRc" target="_blank" rel="noopener">TLB压缩问题oncall排查手册</a></p>
<p>文中对我们比较重要的信息是这部分</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjZmMDE3ZmJjNzYxNThjZjk5Mzc2MDBlNmVkYjk4YzRfODVpZm9jSDFKUnUwUUJzZ2hVbnIyZEJoa3lZZWo4Z2ZfVG9rZW46QVFRTWJpRXJSb0dKTHF4d25qY2NaaHpTblJkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>文中配置与tlb同学确认后就是默认配置，这样对于我们验证就有了参照物</p>
<p>在关掉koa-compress 的br 压缩后，我进行了如下实验</p>
<ol>
<li>构造响应不同content-length的接口</li>
<li>分别通过本地localhost 访问，域名访问，以及关掉tlb 的br 压缩后再通过域名访问以上接口（保证经过tlb）</li>
</ol>
<p>得到如下结果（no表示不压缩）</p>
<table>
<thead>
<tr>
<th style="text-align:left">content-length</th>
<th style="text-align:left">localhost:3000</th>
<th style="text-align:left">域名访问</th>
<th style="text-align:left">tlb 设置 brotli = off</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">117</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">152</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">958</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">1208</td>
<td style="text-align:left">gzip</td>
<td style="text-align:left">gzip</td>
<td style="text-align:left">gzip</td>
</tr>
</tbody>
</table>
<p>从koa-compress 压缩原理我们可以知道从服务端响应的数据，大于1024采用gzip，小于则不压缩</p>
<p>所以本地访问是符合预期的</p>
<p>经过域名访问，我们可以看到小于1024大于150的响应被用br进行压缩了, 符合br 大于150就压缩</p>
<p>当把tlb 上nginx的br开启指令关掉，我们可以看到小于1024大于200的响应被用gzip压缩了，符合gzip 大于200就压缩的逻辑</p>
<p>再看大于1024的最后一行，当服务端已经指定content-encoding的时候，tlb 是不会进行压缩的，会沿用上游指定压缩算法</p>
<p>综上看来，<strong>TLB 会在上游响应未指定content-encoding的时候进行小于1M响应数据的压缩, 默认大于150b时会使用br压缩，大于200b且禁用br情况下才会使用gzip，如果上游指定了content-encoding, 就沿用上游压缩算法</strong></p>
<p>至此，响应报文的content-encoding 来源我们搞清楚了，接下来回到解决办法一，验证下service mesh指定压缩方法后报文变化</p>
<h3 id="集群插曲"><a href="#集群插曲" class="headerlink" title="集群插曲"></a>集群插曲</h3><p>虽然<a href="https://bytedance.feishu.cn/docx/CgO6dfGYOo86eYxILLPcMc2MnRc" target="_blank" rel="noopener">文档</a>中指令是默认指令，但不并是<strong>所有</strong>TLB集群的默认Ngnix 配置，如果出现了与上述结论异常的情况，需要邀请TLB 的同学帮忙查一下域名依赖的<strong>TLB 集群</strong>是否就是文档中的默认配置（因为只有TLB同学有权限可以查）</p>
<p>比如，相同600B请求，Boe 环境是br压缩，但是线上则变成了gzip</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZjFjMTkwMTg2NzkzNDA3MDZmOTZlNGEzMGYzOTc2OGVfdFY3ZUhMN0tIU2lFdTRuaDFDbzl6bWNOTEtDUEwyRWtfVG9rZW46RERKdmI0azFPbzJQdjd4TkpNQ2NDd2JobmVkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YzE1YWJjZTNjZWNhNDA4NDk0ODNjNjg0MTNlMGFlMTRfVmJ1VVA0M1pMZm5hQ0hqcDJQOVVwd3lwZUFlUm5rUHpfVG9rZW46VTVoeGJlNXhsb3g2SWN4SXBZbmNFakxGbmtBXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>按上面的结论，服务器不会对小于1024的请求进行压缩，经过tlb 默认配置会使用br，boe 环境是正常的，线上是不正常的，经过排查发现，线上tlb 依赖的<strong>集群默认</strong>配置没有开启br ，所以再走默认配置会进行gzip压缩</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzQzNDk5NGQyMDc0YTE4NzA1MGU5YzJkN2ZlOGM2MDlfNGtDdVNGYTUxMTdBUUR2em9aS1lpcERXN3FsNFFqRkhfVG9rZW46R2VlZWJ0TTU0b2VxcWN4OXNtM2MyQ0hibmZkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YzUzZGYyNDkyOTE4YjQxZGVhMWU3ZDIyZmNlYWYwNjNfdzNvWUtFT0U4amcyeXdTT3U5TE51UlJoVFlPS1pFTDVfVG9rZW46SUZPY2JtamJ6b0RmQ014YWtjdmM2UWJSbjBlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<h3 id="Cloud-IDE"><a href="#Cloud-IDE" class="headerlink" title="Cloud IDE"></a>Cloud IDE</h3><p>这里需要注意一点的是，上面我们在发现小于1024的压缩算法异常时，访问的是cloud IDE 上启动项目后帮我们生成的域名，我们在本地请求接口是没有进行压缩的，也就是说cloud IDE生成的域名是有经过TLB的，而且其集群默认开启了br压缩</p>
<h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p>实验条件(复现问题)：</p>
<p>TLB nginx 不禁用br</p>
<p>不禁用koa=compress的br压缩算法</p>
<table>
<thead>
<tr>
<th style="text-align:left">content-length</th>
<th style="text-align:left">localhost:3000</th>
<th style="text-align:left">域名访问</th>
<th style="text-align:left">域名访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">117</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">152</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">958</td>
<td style="text-align:left">no</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
<tr>
<td style="text-align:left">1208</td>
<td style="text-align:left">br</td>
<td style="text-align:left">br</td>
<td style="text-align:left">gzip</td>
</tr>
</tbody>
</table>
<p>我们从浏览器发起请求</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=M2IyNDRhOTRhNDk3Yzg3ZWMxOWY2NWQ1NWQzYjYzZDNfWWVyY2toZjFxWDJqRlE4aGtOM25BRE5XQTU3cEpjVGNfVG9rZW46VlhJSmJDOUhtb01GREp4UzJHSmNzaTdzbkpiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>在最后一个中间件打印响应头，说明服务器没有参与数据压缩 (可以通过设置priority让中间件在最后一个执行)</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTJlNTA3NzA4ZTA2YjcxZjE1ZDNjMmE5ZjEzYWU1YTFfcFlUVGhlMHFyb2JwQ1JGNVRvTklaMWd1WDJoSGg2ektfVG9rZW46Wk4wMWIyUFhDb2Z6UXV4dGVUS2NqSXprbklkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>然后通过监听端口报文</p>
<p>tcpdump -i eth0 port 3000 -nn</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzAwZDkxZjUxNWQ1YWUwNGZkNzQyZmY3ZTA5MjgwNDhfYWM5TEZTZWZvQXpRTEpoT2xOdGZRU1FISmZZUFZwSFFfVG9rZW46WGdPdWJwdzZMb2ZTd1Z4NzRPRWNvOFdSbkVjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>基本上通过上述表现我们基本上是可以判断是mesh 进行了压缩</p>
<p>但是，我们现在监听的是3000配置端口(其他服务监听实例输出的端口)</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NjRjYTJiYTI1NzBmMWRlOGYzNDMxOTQ2Y2Q3MmNkYzBfMGtXMzc2c3NVQW9jUmVoNXZoV0RQVHhGOW5YZ2JqemFfVG9rZW46UGE2T2JqVjVJb2JnTDl4NXdJbGNZSG9sbjFjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>如果3000端口吐出来的是经过了mesh的话，那通信的结构应该是这样</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTc5NDRmMzRjOGY5MzkwZTQ3MTY0NGNhNjhlNzBiN2FfYjViaDYyRkNLVXdSZk9WeDkwS3ZYcnJGYVllZG0zOXJfVG9rZW46WHJjU2JVbHY0b2l1alJ4eVlZdWNrUzNHbkh6XzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p><strong>往深了想一下，上面的判断逻辑并不是非常精确</strong></p>
<ol>
<li>node 最后吐出来的数据的header 可能跟我们上面在最后一个中间件打印的header并不同，也就是说我们在最后一个中间件打印的header 并不是最终实例吐出数据的header，有一些 header 是会在最后吐数据的时候装的</li>
<li>Gzip 的请求头真的是mesh 加上去的吗？实例和mesh 之间不会还有其他服务？</li>
</ol>
<p>要解决上面两个疑问，就要想办法去抓取一下mesh 接收的数据，也就是服务吐给mesh的数据</p>
<h3 id="抓取mesh-socket"><a href="#抓取mesh-socket" class="headerlink" title="抓取mesh socket"></a>抓取mesh socket</h3><p>当给服务开启mesh 服务时，mesh 会给环境注入一些<a href="https://bytedance.feishu.cn/wiki/wikcnNBQTrQvvto4XpAtlgDtbvh" target="_blank" rel="noopener">环境变量</a></p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQyNDk2YzM4Y2ZkNTcyMTVhOGQ2ZGQ4NThlNzMyODNfaUlEV3htRTNEZVRCWEZxVXhZR0JMVEd3dTBLQ1dDUUxfVG9rZW46SWN4cWJWdHZib2JLaEN4STY4VmM1RnRObktjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZGNiZjlhY2U5NDkzZjI5NjYwN2NkNGRiZWY5MDIxNjVfRmNwb1VDVFRVRWZ6bjRKWksxZlEwd2lFb2w3SlVxREVfVG9rZW46WndZWGI0aGg3bzFJaUp4ZVBzUGNxWmtyblhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>其中SERVICE_MESH_HTTP_EGRESS_ADDR 这个变量对应的地址就是服务交给mesh 转发的数据</p>
<p>即服务会往这个地址吐数据，然后再由mesh从这里转发再吐出去</p>
<p>那我们接下来就要想办法去读这个socket</p>
<p><a href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">通过tcpdump对Unix Domain Socket 进行抓包解析</a></p>
<p>当我打算用curl 命令去执行相关方法时，却发现没有相应地址的socket</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MTBlNWU4ZTVhNGUxZmFhNmY4NzBhMTRhMmQxYzk2ODZfVlgzRHdpZGVGbTllQnBXaVZZNVlyaTFyajRyOTBXYVdfVG9rZW46UGE3dmJIZGJlb25YVHJ4OUFaOWNaWFlGbmxUXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>ok，拉mesh 同学onCall 说这种情况是因为服务器和mesh之间不是用的uds通信，用的ip PORT通信</p>
<p><a href="https://bytedance.feishu.cn/wiki/wikcn4bvZsBkZMpUVC2WQ0lUzPg#OqPeFE" target="_blank" rel="noopener">ByteMesh HTTP 出流量接入</a></p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YTk1YzA0YjJmNmYxODc4ZDcwMjcxMDY2MzY3MTg1OWJfcVVsa2M1WUFxN3dtelJnQzJTbHJZNTI3cVpjWGtya3JfVG9rZW46SHJUemJRV2xwbzFrdWx4QWRDSWN1NEVvblZoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<h3 id="抓取PORT-9507"><a href="#抓取PORT-9507" class="headerlink" title="抓取PORT 9507"></a>抓取PORT 9507</h3><p>&#x20;那我现在需要找到MESH_EGRESS_PORT具体是什么</p>
<p>无论是通过打印环境变量</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTM3NTkyNGJhZmIxOWVhNTcyZmFkODhhMDJmZmFmNzlfcXk2dkRFZ3E3SUtKWVFVTkQ4ZkR2c3ZVNUw4VDBZS3dfVG9rZW46UmN3QWJ0Y0l2b1lqT2d4MWhnbGNScUJnbm1iXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>还是通过 cat /proc/\${pid}/environ 查看配置文件，以及通过查看监听端口</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTkxMWI0YTIxYzJkOWI4NzgxNjdlNzg1N2Q0MmU2MDdfSU1MRnNDRjFLdDNya0t6bWFoMzB0Yk5uREhlSjVZVkJfVG9rZW46SlpVZ2IwR0pVbzlSbnp4RkpoQ2NtbWVSbkJoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>基本都确定lookback通信的port 是9507</p>
<p>Ok 那我们再回到用tcpdump 抓包的方式,会发现什么也抓不到</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTA2ZGY0ZmY5MTA0YWRmZDUwM2Y4ZWRmYzllMmUxNTdfMW9zdGE2bVp0cWMyWnpJYnhnSUNyYXZwQW16VXRISW1fVG9rZW46TE5URmJFY0g1b3ZyYkx4SkRlVmNJWFJWbkdjXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>陷入死胡同, 那就是说没有数据包经过mesh 接收数据的端口</p>
<h3 id="重新认识Service-Mesh"><a href="#重新认识Service-Mesh" class="headerlink" title="重新认识Service Mesh"></a>重新认识Service Mesh</h3><h4 id="入流量"><a href="#入流量" class="headerlink" title="入流量"></a>入流量</h4><p>我们之前是通过入流量开启压缩算法的</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ODJjMTdiYmU4MjExZmJiMGFmYjlkYzYyZDM5NTg1NTNfeDNjR2dwYm9neHR6OVNhOGs5eTVWMXhibkg5TWIzVE5fVG9rZW46UFFvdmJieDBtb2tiMUV4ZURmaWMxVGI1blhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>入流量在整个通信链路中的作用是这样的</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzYwYjFhOTE5YWUyM2M1MjU0NGU1NTIwODQ0NTJlNTJfTVcxUFZTcHpGM2U2a1YyUHJ2cHZJdkZ0NUNkbm5nc3BfVG9rZW46STFERGJzY2dXb3dRVGV4WExWbWNLQXVvbnVEXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>&#x20;所以现在需要抓取的是入流量的端口<a href="https://bytedance.feishu.cn/wiki/wikcntxkGyIyWhfQ2ZZiqCmOj4c" target="_blank" rel="noopener">ByteMesh WebSocket &amp; HTTP/1.1 &amp; HTTP/2协议接入约定</a></p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NmY1NDM1ODcyNDZiNDJhMjk3YTIxMjEyODJlMTIzNDNfVnlvM1hRMEVwY0RzRW0xYXFXR3hjUTdlWUNBNkowclhfVG9rZW46R2d6T2I3ZURjb0l3NEd4VHNsYmNzMnpubmRkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>需要找到MESH_INGRESS_PORT 通过查看pid 下面 environ 文件可以看到port 为3000，也就是配置端口</p>
<p>然后尝试监听 <a href="https://www.cnblogs.com/zgq123456/articles/10251860.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq123456/articles/10251860.html</a></p>
<p>tcpdump -i any -A -s 0 ‘tcp port 3000 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)’</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NTk1NjI5ZTgzMjBlZjQ0MmY3MjNkZTM2OWI0NzRmZTBfQ1ZJM3JCcFhvamFaOGhrZXNGT0w2MUd6cVFRcnY5d2RfVG9rZW46R2tKTGJQRmlob2JqSjh4dWFLYWM1QmtjbmdkXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NGU2ZWI0MzMzN2MxYWIwNjU0NDgzMTc1NTc2MmEyNWZfTDdvSmpVNk9xbXFpQmJFTFBNbTdsV3ZLZXRQa29JcVpfVG9rZW46WGp2NmJCeUhJbzlGMUl4UDFEZWNjTlpzbnhiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>这一次看到了报文的整个变化过程如上两图</p>
<h4 id="出流量"><a href="#出流量" class="headerlink" title="出流量"></a>出流量</h4><p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQ3YjQ2NGZhZDU2NzY0MTRkNmRlZDAxN2FlNzRjODlfNVJIOW11d1cyWlFNZ1JYQWVMZ2t2WWw5dWg3VENlTDFfVG9rZW46WXlVa2J4R1Fsb1Jva0F4RktMZGNjWW5WbnNmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGQyOGI1OGFhNjlmNDlhZThkZWJjZWY1ZjVmMDNlMThfeUxHQ0w2anc5Zjc4MTU4RUlKOW1qS2NTYWJoUFlrRkNfVG9rZW46V2Y0S2JCVHZ1b2Nndml4TTB2a2NvSUtDbjhnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>通过给服务开启出流量代理，可以看到两种通信地址</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjIxMDQzZjNjNTE5ZTEyYTcxMjU4NTY1NTRkMWRmZDFfRmZBRWYwc2RnT0xMUkVrZ01DNmw1NmNhUjJ0QWxUNmVfVG9rZW46Vk5BbWJzVHR5b3JnUVh4SjYwS2NSREUwbkxnXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>SERVICE_MESH_EGRESS_ADDR 即如果node 跟下游服务通信会走dsl 通信</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTg1NmYwMDdmNTJjNjk2MTNkNTVkYWM4M2MwYmIzYTJfZVR5VFFxNXNGM2REaXppZkpwQ1BlOWpranA3S2RRWnlfVG9rZW46STl1Y2JUUEhjb2FwcjJ4VVA3c2M1U2JIbkllXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>MESH_EGRESS_PORT 即如果node 发起http 请求会通过这个端口与mesh 进行http 通信，过程同上面入流量过程</p>
<h5 id="看一下UDS报文长啥样"><a href="#看一下UDS报文长啥样" class="headerlink" title="看一下UDS报文长啥样"></a>看一下UDS报文长啥样</h5><p>还是参考这篇<a href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">文章</a>的方法</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTExN2NmOGE1ZDQ2MmU4ODllMzdmZWUxNzE0MjNlY2JfZ2hua29rcnN3WnFKSXY5SDZrWmViZ0t5U0RIdTBFZ1VfVG9rZW46QkhyWGJjZ2JRbzJDajN4V1ZtaGN6TXZYbmFiXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<ol>
<li>为方便后续指令执行，切到rpc.egress.sock所在文件夹，</li>
</ol>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZTM0YTFmNTRkOTQwMzY2ZWUyMzdlODA4MGViYzlkNGNfWVQ2Y3FWRk5LVU93Y2xmWGEzeUU3V1pwYWd4aHlCOVpfVG9rZW46T252V2JVRGs3b29sSUh4dzRNN2NrSWNLbnFmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGE2ZDE0ZmYxMjA1ODU1MWQyN2RhNjc5YjUzZWJmYzFfQ2w0eGpCN3F4SHFDUTROdjFZWGtqeDkwb042YW5NbTZfVG9rZW46R3B3SWJQbm9Tb3lvN2V4T0kxOWNnWHozbk9nXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<ol>
<li>将给到rpc.egress.sock 的数据转发到 8089</li>
</ol>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmY1YTlkYTI3ZWFhZGM0NDZlMWIzYzM1YzExN2NjMzdfa0NISWFuZDEyeHVqR281ZzJybWRzdE55V2lsb2FPUEdfVG9rZW46UmNtQ2JZeUdob3AwVWt4SEpJWWNWQ1c1blVlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<ol>
<li>用curl 发起请求，并用tcpdump 对8089进行抓包</li>
</ol>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=OTljZjM4MjdmYjRhZmFmZmJlZmE4M2ZkNjU5NDYyYWFfcUQ5QXc1cEdwMGNpZmxTdngxVG5ZaUV2VVFoZW1rWXlfVG9rZW46QlZkbGJUR0tOb2ZCVnJ4bkdGM2NnVUlKbnpoXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>注意使用curl –-unix-socket /rpc.egress.sock 时 如果不支持–-unix-socket 参数，需要使用apt-get 升级curl 版本，如无法升级，可能是linux 版本不再维护，可尝试替换基础镜像(指定高版本linux 的)进行部署后再测试 虽然位于rpc.egress.sock 所在文件夹下执行，但是前面的/ 不能省</p>
<p>先用tcpdump -i any -netvv port 8089 看看能不能</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=ZDYzMGQxYTI3OWRjZTljYjZiMmE4ZjkxYjIzMWRkY2Ffd0lOelN3Sk9COFc0TjRhSWhxamxqNmZSTGVleFNEampfVG9rZW46SGo0U2I3MjBUb2hxRUt4SnZMVmM0aGJxbjRlXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<p>加上-A -s , ===&gt; tcpdump -i any -A -s 0 -netvv port 8089 看看具体报文</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=N2MxNTE1ZjliYTE4ZDNhYzUzNTVmMzk3NjBmODg4MGVfc0hxdFdkTjJJRU04QVMwbURUVWNzSGZ0a1BOaDZrZDZfVG9rZW46Wk15S2J3WTZqb2RMZmp4UVBFTGNmaDdhblRmXzE3MDcyMDIyODI6MTcwNzIwNTg4Ml9WNA" alt></p>
<h1 id="知识收获"><a href="#知识收获" class="headerlink" title="知识收获"></a>知识收获</h1><h2 id="cUrl"><a href="#cUrl" class="headerlink" title="cUrl"></a>cUrl</h2><p>cUrl <a href="https://curl.se/docs/manual.html" target="_blank" rel="noopener">命令相关参数</a></p>
<p>-v/–verbose 用于打印更多信息，包括发送的请求信息</p>
<p>-o /dev/null 把输出写到该文件中，保留远程文件的文件名</p>
<p>-w ‘%{size_download}\n’ 获取下载大小</p>
<p>--unix-socket 测试socket 地址，注意要求curl 版本7.50+，如果webshell 不支持，需要考虑更换tce基础镜像</p>
<h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>tcpdump -i eth0 port 3000 -nn</p>
<p>tcpdump -i eth0 -nn -vv</p>
<p>tcpdump -i lo -nn -vv</p>
<p><a href="https://www.cnblogs.com/zgq123456/articles/10251860.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq123456/articles/10251860.html</a></p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>lsof -i | grep LISTEN</p>
<p>ps -le</p>
<p>ps -ef | grep node</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>apt/apt-get update</p>
<p>apt/apt-get install 包名</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/historySearchDesign.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/historySearchDesign.html" itemprop="url">
                  历史记录功能设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-03T15:17:37+08:00">
                2024-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>根据用户反馈，查询条件多个时，想要重新看一下上次的查询结果，操作比较繁琐，希望可以有历史查询的功能，将最近查询的n次记录可以找到，方便回溯问题</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>在用户点击查询按钮的时候，将当前页面链接调接口保存起来，查询时链接会携带查询条件</p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>&#x20;历史记录需要跟用户身份做绑定，当前天级uv可达75人，不适宜用tcc或者wcc平台进行数据存储</p>
<p>&#x20;所以需要申请资源进行数据存储</p>
<p><strong>容量</strong></p>
<p>&#x20;一个连接大小按照500Byte算，如果只保存最近10条记录，那么一个用户需要5000b ==&gt; 5kb</p>
<p>目前平台用户数以1000为底计算,一开始平台会需要 5kb * 1000 ==&gt;5000kb ==&gt; 5mb</p>
<p>(目前纯个人用户有530，加上以部门为单位申请的权限，各部门人数不确定)</p>
<p>假设半年后用户量翻倍那么存储空间需要增加一倍也就是10MB</p>
<p><strong>负载</strong></p>
<p>目前平台日pv 350,日uv 50, 大致计算一个用户一天会访问页面7次，四舍五入假设1天会进行10次查询</p>
<p>1个用户1天会进行10次数据库读写</p>
<p>那整个平台1天平均会进行500次读写，高峰假设1000次读写(75四舍五入)</p>
<p>平均 500 * 500 /(3600*24) ~~ 0.003kb/s 高峰1000*500/(3600*24) ~~~0.006kb/s</p>
<p>很低</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本来想如果数据库有数组的话，表结构就是用户id + 记录数组；</p>
<p>没有的话，我现在想了两种方案，</p>
<p>一个就是用字符串存这个数组，用户id + 记录数组字符串形式，相当于更新时要先获得这个字符串，转成数组后，看有没有10条，没有的话直接push,有的话，把时间最早的那条删除，push进数组，再转成字符串更新数据库，这样缺点就是展示的时候也得字符串转数组一下；</p>
<p>另一种就是用户id只和一条记录存在一起，不用一个字符串存整个10条记录，更新的时候我去拿数据的时候拿整个用户id所有的，超过10条的话就用数据库删除方法把时间早的删除了，再存进去最新的</p>
<p>看起来都挺麻烦</p>
<p>而且在实际接入数据库的过程中，还要手动执行命令行产生model相关文件</p>
<p>通过调研公司存储系统的各种方式，觉得redis可以更好的解决存储问题，redis支持List类型存储，</p>
<p>而且LPUSH, LPOP,EXPIRE方法可以很好的帮助实现数据存取更新缓存等问题,省了数据库建表等过程</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>redis可以很好的支持数据删除，在更新数据的时候重新设置过期时间即可保证删除不活跃用户的记录</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>申请redis服务，用户工号做redis的key值，key值的value即用户的查询历史记录list,</p>
<p>写接口: 查记录，更新记录</p>
<p>前端在点击查询的时候调接口更新记录</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://bytedance.feishu.cn/wiki/wikcnfEUcTwW8A3bUUQNtqUlsUd" target="_blank" rel="noopener">存储系统对比 （草稿）Storage System Comparision（Draft）</a> #</p>
<p><a href="https://bytedance.feishu.cn/wiki/wikcnKKISdh4ftbAj6FG24gAwCb" target="_blank" rel="noopener">数据结构与命令一览 List of data structure and commands</a> #</p>
<p><a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/mobxlearn.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/mobxlearn.html" itemprop="url">
                  Mobx 运行机制深入研究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-03T15:17:37+08:00">
                2024-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="追踪原理"><a href="#追踪原理" class="headerlink" title="追踪原理"></a><strong>追踪原理</strong></h1><p><a href="https://cn.mobx.js.org/best/react.html" target="_blank" rel="noopener">官方文档</a></p>
<p>MobX 会对在执行 <strong>跟踪函数 期间</strong> 读取的任何现有的<strong>可观察属性</strong>做出反应</p>
<p>“<strong>读取</strong>” 是对象属性的间接引用，可以用过 . (例如 user.name) 或者 [] (例如 user[‘name’]) 的形式完成。</p>
<p>“<strong>追踪函数</strong>” 是 <strong>computed 表达式、observer 组件的 render() 方法和 when、reaction 和 autorun 的第一个入参函数。</strong></p>
<p>“<strong>过程(during)</strong>” 意味着只追踪那些在函数执行时被读取的 observable 。这些值是否由追踪函数直接或间接使用并不重要。</p>
<p>换句话说，MobX 不会对其作出反应:</p>
<p>从 observable 获取的值，但是在追踪函数之外</p>
<p>在异步调用的代码块中读取的 observable</p>
<p>Mobx 5 以下 MobX 不会追踪还不存在的索引或者对象属性(当使用 observable 映射(map)时除外)。</p>
<p>所以建议总是使用 .length 来检查保护基于数组索引的访问。</p>
<p>所有数组的索引分配都可以检测到，但前提条件必须是提供的索引小于数组长度。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h2><p>追踪属性访问，而不是值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let message = observable(&#123;</span><br><span class="line">    title: &quot;Foo&quot;,</span><br><span class="line">    author: &#123;</span><br><span class="line">        name: &quot;Michel&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    likes: [</span><br><span class="line">        &quot;John&quot;, &quot;Sara&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YjI2YjAxNTdhOWZkMmM1ZjFkOThlOTRhM2RlMWJkYjdfcnliUm9PSXdJWFZseExRcFdxNDhNaHNUcEh4dURwQ0pfVG9rZW46Ym94Y250QmJzT2ZWZkh3QzZVd05mNjlWSExmXzE3MDcxOTA3Mzk6MTcwNzE5NDMzOV9WNA" alt></p>
<p>mobx会追踪箭头有没有变化</p>
<p>如果箭头发生变化，就会执行追踪函数</p>
<h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><strong>使用注意</strong></h1><h2 id="处理数据时"><a href="#处理数据时" class="headerlink" title="处理数据时"></a><strong>处理数据时</strong></h2><p>1.更改没有被obserable的箭头，追踪函数不执行</p>
<p>2.追踪函数里使用间接引用指向obserable属性，追踪函数不执行</p>
<p>3.对新增的属性，可以使用set,get实现obserable</p>
<p>4.在异步代码中访问的obserable属性，不会引起追踪函数执行</p>
<pre><code>1.更改没有被obserable的箭头，追踪函数不执行
autorun(() =&gt; {
    console.log(message.title)
})
message = observable({ title: &quot;Bar&quot; }) //指向message的箭头没有被obervable
autorun(() =&gt; {
    message.likes;//箭头没变，又没有访问数组里面的属性
})
message.likes.push(&quot;Jennifer&quot;);

2.追踪函数里使用间接引用指向obserable属性，追踪函数不执行
var title = message.title;
autorun(() =&gt; {
    console.log(title) //访问箭头没有变，还是指向老值的位置
})
message.title = &quot;Bar&quot; //箭头改了，但autorun里没有用到
const author = message.author;
autorun(() =&gt; {
    console.log(author.name) 
})
message.author.name = &quot;Sara&quot;;//会执行跟踪函数，autorun里有访问name属性，这里指向name值得箭头改了
message.author = { name: &quot;John&quot; };//不会执行，没有访问author属性的箭头

正确使用

A:
autorun(() =&gt; {
    console.log(message.author.name)
})
message.author.name = &quot;Sara&quot;;
message.author = { name: &quot;John&quot; };
B:
function upperCaseAuthorName(author) {
    const baseName = author.name;
    return baseName.toUpperCase();
}
autorun(() =&gt; {
    console.log(upperCaseAuthorName(message.author))
})
message.author.name = &quot;Chesterton&quot;

3.异步
const message = observable({ title: &quot;hello&quot; })
autorun(() =&gt; {
    console.log(message) //会执行两次，因为console.log是异步的，请确保始终传递不变数据 ( immutable data ) 或防御副本给 console.log。
})
message.title = &quot;Hello world&quot;
autorun(() =&gt; {
    setTimeout(
        () =&gt; console.log(message.likes.join(&quot;, &quot;)), //异步执行，访问原始数据打印一次
        10
    )
})
message.likes.push(&quot;Jennifer&quot;);//不会引起autorun执行

4.MobX 5 可以追踪还不存在的属性
autorun(() =&gt; {
    console.log(message.postDate)
})
message.postDate = new Date()
</code></pre><h2 id="组件使用时"><a href="#组件使用时" class="headerlink" title="组件使用时"></a><strong>组件使用时</strong></h2><h3 id="子组件问题"><a href="#子组件问题" class="headerlink" title="子组件问题"></a><strong>子组件问题</strong></h3><p><strong>MobX 只会为数据是直接通过 render 存取的 observer 组件进行数据追踪</strong></p>
<p>所以当需要将数据传递给子组件时，要保证子组件也是一个obserable组件，可以做出反应</p>
<p>解决办法：</p>
<p>1.将子组件使用obserable函数处理</p>
<p>它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件</p>
<p>2.使用mobx-react的Obserable组件包裹子组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">方法一：将子组件使用obserable函数处理</span><br><span class="line"><span class="keyword">const</span> MyComponent = observer(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span></span><br><span class="line">    &lt;SomeContainer</span><br><span class="line">        title = &#123;() =&gt; &lt;TitleRenderer message=&#123;message&#125; /&gt;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> TitleRenderer = observer(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span></span><br><span class="line">    &lt;div&gt;&#123;message.title&#125;&lt;<span class="regexp">/div&gt;&#125;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">message.title = "Bar"</span></span><br><span class="line"><span class="regexp">方法二：使用mobx-react的Obserable组件包裹子组件</span></span><br><span class="line"><span class="regexp">const MyComponent = (&#123; message &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">    &lt;SomeContainer</span></span><br><span class="line"><span class="regexp">        title = &#123;() =&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Observer&gt;</span></span><br><span class="line"><span class="regexp">                &#123;() =&gt; &lt;div&gt;&#123;message.title&#125;&lt;/</span>div&gt;&#125;</span><br><span class="line">            &lt;<span class="regexp">/Observer&gt;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;</span><br><span class="line">message.title = <span class="string">"Bar"</span></span><br></pre></td></tr></table></figure>
<h3 id="避免在本地字段中缓存-observable"><a href="#避免在本地字段中缓存-observable" class="headerlink" title="避免在本地字段中缓存 observable"></a><strong>避免在本地字段中缓存 observable</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@observer class MyComponent extends React.component &#123;</span><br><span class="line">    author;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.author = props.message.author;//message.author发生变化时不会引起render</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;&#123;this.author.name&#125;&lt;/div&gt; //.name可以引起render</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化，使用计算属性，或者在render函数中进行间接引用</p>
<pre><code>@observer class MyComponent extends React.component {
    @computed get author() {
        return this.props.message.author
    }
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.从性能上考虑，越晚进行间接引用越好</p>
<p>2.数组里面的是对象而不是字符串，那么对于发生在某个具体的对象中发生的变化，渲染数组的父组件将不会重新渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Message = observer((&#123; message &#125;) =&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;message.title&#125;</span><br><span class="line">        &lt;Author author=&#123; message.author &#125; /&gt;</span><br><span class="line">        &lt;Likes likes=&#123; message.likes &#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">const Author = observer((&#123; author &#125;) =&gt;</span><br><span class="line">    &lt;span&gt;&#123;author.name&#125;&lt;/span&gt;</span><br><span class="line">)</span><br><span class="line">const Likes = observer((&#123; likes &#125;) =&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;likes.map(like =&gt;</span><br><span class="line">            &lt;li&gt;&#123;like&#125;&lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">变化</th>
<th style="text-align:left">重新渲染组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">message.title = “Bar”</td>
<td style="text-align:left">Message</td>
</tr>
<tr>
<td style="text-align:left">message.author.name = “Susan”</td>
<td style="text-align:left">Author (.author 在 Message 中进行间接引用, 但没有改变)*</td>
</tr>
<tr>
<td style="text-align:left">message.author = { name: “Susan”}</td>
<td style="text-align:left">Message, Author</td>
</tr>
<tr>
<td style="text-align:left">message.likes[0] = “Michel”</td>
<td style="text-align:left">Likes</td>
</tr>
</tbody>
</table>
<h1 id="一些-对比"><a href="#一些-对比" class="headerlink" title="一些 对比"></a>一些 对比</h1><h1 id="autorun-vs-compute"><a href="#autorun-vs-compute" class="headerlink" title="autorun vs compute"></a><strong>autorun vs compute</strong></h1><p>当使用 autorun 时，所提供的函数总是立即被触发一次，然后每次它的依赖关系改变时会再次被触发</p>
<p>computed(function) 创建的函数只有当它有自己的观察者时才会重新计算，否则它的值会被认为是不相关的</p>
<p>如果一个计算值不再被观察了，例如使用它的UI不复存在了，MobX 可以自动地将其垃圾回收。</p>
<p>而 autorun 中的值必须要手动清理才行</p>
<h1 id="autorun-vs-reaction"><a href="#autorun-vs-reaction" class="headerlink" title="autorun vs reaction"></a><strong>autorun vs reaction</strong></h1><p>reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?)</p>
<p>它接收两个函数参数，第一个(<strong>数据</strong>函数)是用来追踪并返回数据作为第二个函数(<strong>效果</strong>函数)的输入。</p>
<p>传入 reaction 的第二个函数(副作用函数)当调用时会接收两个参数。</p>
<p>第一个参数是由 data 函数返回的值。</p>
<p>第二个参数是当前的 reaction，可以用来在执行期间清理 reaction</p>
<p>reaction 返回一个清理函数。</p>
<p>不同于 autorun 的是当创建时 **效果 **函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。</p>
<p>在执行 <strong>效果</strong>函数时访问的任何 observable 都不会被追踪。</p>
<p><strong>效果</strong>函数仅对<strong>数据</strong>函数中访问的数据作出反应，这可能会比实际在<strong>效果</strong>函数使用的数据要少。</p>
<p>此外，<strong>效果</strong> 函数只会在表达式返回的数据发生更改时触发。 换句话说: reaction需要你生产 <strong>效果</strong>函数中</p>
<p>所需要的东西。</p>
<h1 id="useObserver-vs-Observer-vs-observer"><a href="#useObserver-vs-Observer-vs-observer" class="headerlink" title="useObserver vs Observer vs observer"></a><strong>useObserver vs Observer vs observer</strong></h1><p><a href="https://juejin.im/post/6844904137167994893" target="_blank" rel="noopener">相关文档</a></p>
<p>1.虽然只是在返回DOM的地方使用 useObserver(), 但是，当dom中数据改变的时候，整个component都会重新render</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">  console.log(&apos;in useObserver&apos;);//点击按钮会触发执行</span><br><span class="line">  const person = useLocalStore(() =&gt; (&#123; name: &apos;John&apos; &#125;));</span><br><span class="line">  return useObserver(() =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;person.name&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; (person.name = &apos;Mike&apos;)&#125;&gt;No! I am Mike&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Observer 标签组件可以更精准的控制想要重新渲染的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default function ObservePerson() &#123;</span><br><span class="line">    console.log(&apos;in Observer&apos;);//点击按钮不会执行</span><br><span class="line">    const person = useLocalStore(() =&gt; (&#123;name: &apos;John&apos;&#125;))</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The old name is: &#123;person.name&#125; //点击按钮不会更新</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Observer&gt;&#123;() =&gt; &lt;div&gt;&#123;person.name&#125;&lt;/div&gt;&#125;&lt;/Observer&gt; //点击按钮会更新</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; (person.name = &apos;Mike&apos;)&#125;&gt;</span><br><span class="line">                    I want to be Mike</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.与useObserver相比，除了使用方法不同，目前不知道区别在哪，有时间需要探究一下</p>
<pre><code>const ObserverLowercasePerson: React.FC&lt;any&gt; = observer(() =&gt; {
    console.log(&apos;in Observer&apos;) //点击按钮也会执行
    const person = useLocalStore(() =&gt; ({name: &apos;John&apos;}));
    return (
        &lt;div&gt;
            &lt;div&gt;The name is: {person.name}&lt;/div&gt;
            &lt;button onClick={() =&gt; (person.name = &apos;Mike&apos;)}&gt;
                Change name
            &lt;/button&gt;
        &lt;/div&gt;
    )
})
```
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/trendCard.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/trendCard.html" itemprop="url">
                  趋势图卡片实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-02T15:17:37+08:00">
                2024-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>春节看板项目中有对数据进行趋势分析的展示，其中一种卡片的展示形式经过思考后可以提炼成组件向外提供服务，于是进行封装上传<a href="https://semi.bytedance.net/material/zh-CN/playground/219" target="_blank" rel="noopener">Semi物料市场</a></p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YmE3Y2ExN2NlYzhlNDI5NWMxODIxODEyZjhkMjVmMjJfMm5HZG1OSVF0aUx1b2NBWGUwUm1iN0txcDkzTWJWZ0RfVG9rZW46Ym94Y25LYkFuYkhSQ3ZUMDRMbzl4SUtJdmhlXzE3MDcyMDQ3MDk6MTcwNzIwODMwOV9WNA" alt></p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ol>
<li>既要支持一个卡片的展现，也要支持多个卡片的展示，所以数据源应该是一个数组 list</li>
<li>每个卡片的大小应该是一样的，所以应该给一个统一设置卡片大小的属性 size</li>
<li>卡片可以静态展示，也可以有响应事件，这里先支持一个点击事件 onClick</li>
<li>单个卡片的功能需要展示趋势折线图，标题，提示，数量，还要支持定制颜色</li>
</ol>
<p>所以单个卡片的数据结构应该是这样的</p>
<table>
<thead>
<tr>
<th style="text-align:left">name</th>
<th style="text-align:left">标题名</th>
<th style="text-align:left">string 或者 ReactNode</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">tip</td>
<td style="text-align:left">提示（可选）</td>
<td style="text-align:left">string 或者 ReactNode</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">tipNormalShow</td>
<td style="text-align:left">提示图标展示方式,默认值false,鼠标滑过才展示</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">FALSE</td>
</tr>
<tr>
<td style="text-align:left">hoverLayer</td>
<td style="text-align:left">鼠标hover是否展示蒙层效果,默认false,不展示</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">FALSE</td>
</tr>
<tr>
<td style="text-align:left">lineColor</td>
<td style="text-align:left">折线的颜色,涉及渐变色计算,配置成十六进制格式</td>
<td style="text-align:left">string</td>
<td style="text-align:left">#E91E63 或者 #00B3A1根据卡片位置奇偶情况切换默认颜色</td>
</tr>
<tr>
<td style="text-align:left">value</td>
<td style="text-align:left">标题下的数据</td>
<td style="text-align:left">string 或者 ReactNode</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">xData</td>
<td style="text-align:left">折线图x轴数据</td>
<td style="text-align:left">Array[string或者number]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">yData</td>
<td style="text-align:left">折线图y轴数据</td>
<td style="text-align:left">Array[string或者number]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">loading</td>
<td style="text-align:left">数据加载状态开启,默认false,不开启</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">noDataTip</td>
<td style="text-align:left">没有数据时的提示</td>
<td style="text-align:left">string 或者 ReactNode</td>
<td style="text-align:left">抱歉，没有数据可展示</td>
</tr>
<tr>
<td style="text-align:left">errorInfo</td>
<td style="text-align:left">错误展示</td>
<td style="text-align:left">{text: ‘xxx’, color: ‘xxxx’}</td>
</tr>
</tbody>
</table>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>将List 传进来的数据，循环成多个卡片，将单个卡片信息，onClick 和size都传递给卡片组件</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=YWRmY2QyZWQxNmYwM2ZhZGM1N2QyYTcxODQyYzYxOWRfTlRJZ01PaGJSbDBKNlJlcld0Z0NMZ1Bma2ppYTJjQkFfVG9rZW46Ym94Y255U0dhcGU2N2JkT29WQ25YNjc4RFpkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p>
<p>卡片根据传递进来属性的不同状态，展示相关信息</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MGYzNGFmOGZiNTI0Yzg3YjRiMjg2ZmVjZGFjYTZlY2NfZ0hhdFc2SHNzQnRiUHpNTXF0NzFUQm1NUzU0M0xGOFZfVG9rZW46Ym94Y241allXOWUwOGVwVGs4a2x1Y3pPeTZiXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p>
<p>另外折线图依靠echart来画，所以需要根据颜色和卡片位置生产曲线配置，这里依靠getChartOption</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=NzA2YmRlODRkMjBhMjE3M2JjNGZhOTIwNjhjMDQ1ZjhfTk81QTQ0WExwQTQ2TWdaaGE5NHVnSWd6ZmdYdzVTRHFfVG9rZW46Ym94Y24wZUVYeDIzZExjWEVla3ZWd0FxcVRkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p>
<p>计算渐变颜色同转换成rgb格式，设置透明度来实现渐变</p>
<p><img src="https://bytedance.larkoffice.com/space/api/box/stream/download/asynccode/?code=MzU1YzI0YjVhMWExNWU4Nzk1MjFhOWI4M2E1ZWU2NmFfckFaNk41aURobmE2V1FOcGxuUm5pWWlVQjMydHZZT0FfVG9rZW46Ym94Y244djl1bkxXVjllaVlPWU1JMTFQR1JkXzE3MDcyMDQ3MTA6MTcwNzIwODMxMF9WNA" alt></p>
<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><p>在线体验地址：<a href="https://semi.bytedance.net/material/zh-CN/playground/219" target="_blank" rel="noopener">https://semi.bytedance.net/material/zh-CN/playground/219</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/dragthink.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/dragthink.html" itemprop="url">
                  拖拽渲染问题的深入研究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-01T15:17:37+08:00">
                2024-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用拖拽组件进行拖拽排序<br>1.原展示模块内容需要进行缩略展示，具备收缩展开的能力<br>2.排序的内容复杂，需要异步获取数据，循环的时候传进去的关键值(如id)作为参数拉取数据，渲染图表</p>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>保留原组件渲染逻辑，同时将数据源传入排序组件（排序组件显示标题类信息代表原模块），<br>然后根据是否进入排序状态，保留二者其一，就是排序时展示排序组件，非排序时展示模块内容<br>问题</p>
<p>从排序状态回到正常展示状态时，因为正常展示的组件DOM在进入排序状态时被销毁<br>这时再回来，相当于从无到有要重新创建，会引起数据重新请求</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>将原展示模块组件作为排序组件项进行渲染，在进入排序状态时将展示模块高度减小，仅保留标题部分充当缩略信息展示<br>因为展示模块DOM始终存在，所以可以解决掉方案一展示模块DOM消失再创建的数据拉取问题<br>原理</p>
<p>DOM的新建跟更新流程不同，在这种情况下，新建过程会需要去请求接口拉数据，而如果仅仅是更新的话，可以依赖react的key的关键作用减少DOM 的重建过程，只是进行调换顺序即可<br>这里在将数据源列表渲染出来的时候，将数据的特征值赋值给key，即排序前后，展示模块key不变就不会被重新新建渲染， 只是进行排序处理<br>解决方案一产生的问题</p>
<p>在进入排序状态时，将展示模块组件高度设置为0，overflow：hidden，就看不到展示组件，但DOM 依然存在<br>这时再使用排序组件展示缩略信息即可</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论哪种方案，在结束排序后，都要更新数据源，但数据源里面的对象不能变，因为展示模块会依赖其中的具体对象里的信息进行数据拉取<br>即</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/product.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/product.html" itemprop="url">
                  学习关于产品的一些思维
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-09-03T17:57:25+08:00">
                2022-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>产品经理决策力工具</p>
<p>象限法：<br>把想做的事情拆成两个指标去做<br>让这个两个指标做xy轴<br>在xy轴包围的空间内，分成四个象限<br>把要做的事情按照xy轴的值分布在四个象限中<br>然后决定要在四个象限中寻找最优解</p>
<p>假设思维: 把未来要做的事情一步一步的假设出来<br>用户思维： 用使用者的思维设计功能</p>
<p>产品路线图roadmap4个核心要素</p>
<ol>
<li>里程碑是要有意义的</li>
<li>跟各个方向的工作协同进行</li>
<li>可能不是串行的而是并行的，需要准备多种方案</li>
<li>基于产品框架</li>
</ol>
<p>五张图说明产品</p>
<ol>
<li>核心功能体验图，主要功能的流程图</li>
<li>模块图，将功能具体的实现划分不同模块，即可以概览具备的的功能，也方便进行任务分配</li>
<li>功能树，一个模块具体具备的功能内容，相当于再细分</li>
<li>页面关系图，页面的操作流程，可以跟功能树对比查看是否有功能遗漏，上面提到的模块功能树都会最终落到页面上</li>
<li>交互设计图，不是最重要的，但要有自解释性，每个人都能看懂</li>
</ol>
<p>用户留存率—-&gt; 指标之王<br>算法</p>
<ol>
<li>新增留存率 所有新用户中有多少比例下个时间周期会出现</li>
<li>活跃留存率 所有用户中（活跃用户），包括新用户，有多少比例会在下个时间周期出现，即有多少人会成为下个周期的活跃用户<br>统计分析<br>用户活跃度<br>cohort， 横纵都是第1-n周<br>每一行代表当前周用户留存率再往后几周的留存率请款<br>每一列代表当前周中，阁用户留存率情况，可以看到每周留存率在这一周的变化情况<br>对角线从左上到右下，上面数据表示次周留存率，如果呈下降趋势，说明产品在新客中粘性在下降，留存率整体在下降<br>将对角线数据处理形成折线图可直观看到用户留存趋势</li>
</ol>
<p>RFM,用户贡献值（下了多少单，总消费金额…），根据用户贡献值可采取不同的营销策略</p>
<p>DAU,WAU,MAU,日、周、月活跃用户，一般让DAY/MAU的值作为一个用户粘性的指标<br>以DAY/MAU为y轴，DAU为x轴，形成折线趋势图，让趋势保持稳定上升是一个产品的发展方向</p>
<p>如何提升留存？<br>不要去想现有总用户如何去留存，去观察哪些用户值得留存，想办法让这些用户实现留存提升</p>
<p>设计一套CRM系统<br>CRM系统： 维护公司与客户关系 ===&gt; 用户运营战略执行系统</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/redis.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/redis.html" itemprop="url">
                  redis 学习的一些笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-09T21:30:15+08:00">
                2022-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基础常识<br>磁盘<br>寻址：ms<br>带宽： G/M<br>内存<br>寻址：ns(纳秒级)<br>带宽：byte/s<br>秒&gt;毫秒&gt;微秒&gt;纳秒<br>磁盘寻址上比内存少了10w倍</p>
<p>I/O BUffer：成本问题<br>磁盘有磁道和扇区，一个扇区512byte<br>会造成索引成本增大<br>因此进行4K对齐，操作系统无论读多少都最少从磁盘里面拿4k出来</p>
<p>数据库的表很大，性能会下降吗？<br>如果表有索引，<br>那么对于增删改的操作肯定会变慢<br>查询速度<br>如果是1个或者少量查询依然很快<br>但如果是并发大的时候会受到硬盘带宽的影响，从而影响速度</p>
<p>数据在内存和磁盘中体积不一样</p>
<p>redis出现原因：<br>内存 ==&gt;  贵<br>磁盘 ==&gt;  慢<br>两个基础设施限制：<br>冯诺依曼体系的硬件制约 ===&gt; 硬盘io带宽问题<br>以太网，tcp/ip的网络 ===&gt; 不稳定</p>
<p><a href="https://db-engines.com/en/" target="_blank" rel="noopener">https://db-engines.com/en/</a></p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<p>上述数据类型是指value的数据类型<br>memcache 和redis区别在于，memcache value没有类型<br>将返回value所有数据到client端，会受到server 网卡IO的限制，而且client要有解码的逻辑<br>redis因为value有类型，所以对于数据的请求根据不同情况直接调用相应类型方法返回少量数据即可<br>做到了计算向数据移动</p>
<p>redis是单进程，单线程，单实例的，通过epoll快速处理并发请求<br>epoll是同步非阻塞的多路复用机制<br>jvm: 一个线程成本是1MB<br>线程多了会增加调度成本，从而使CPU浪费，也会增加内存成本<br>BIO—&gt;NIO（同步非阻塞）—&gt;多路复用—&gt;epoll(引入共享空间避免fd相关数据考来考去)</p>
<p>redis 对不同数据类型不同encoding类型的数值具有不同的方法<br>key有两个属性：<br>type标识值的类型<br>encoding标识值的编码类型<br>二者决定对值的操作可以使用哪些方法，从而加速计算</p>
<p>String 类型<br>字符串的相关操作：<br>set,get,append,setRange,getRange,strlen<br>适用场景：<br>使用内存存储的session，对象，小文件</p>
<p>数值的相关操作：<br>incr,decr<br>适用场景：<br>限流，计数<br>秒杀一般会用数据库</p>
<p>bitmap的相关操作：<br>setbit, bitcount,bitpos,bittop<br>使用场景：web, 离线数据<br>1.用户系统，统计用户登录天数，且窗口随机<br>key标识用户，每个用户准备365位，每一位表示当天是否登录，登录置一<br>setbit sean 1 1<br>setbit sean 7 1<br>setbit sean 364 1<br>STRLEN sean ===&gt;46 每个用户只需要46个字节来存储这些信息<br>BITCOUNT sean -2 -1 计算多少天范围内一共登录了几天</p>
<ol start="2">
<li><p>电商做618活动，需要给活跃用户登录后送礼物，请问应该备货多少礼物<br>假设这里活跃用户统计规则为20220901-20220903三天内登录的用户，三天内只要登录一次就算活跃用户<br>key标识当天用户登录情况，将用户编号映射到二进制位的相应位置上，每一位二进制代表一位用户是否登录<br>setbit 20220901 1 1<br>setbit 20220902 1 1<br>setbit 20220902 7 1<br>bittop or destkey 20220901 20220902<br>bitcount destkey 0 -1</p>
</li>
<li><p>存储oa权限信息</p>
</li>
<li>布隆过滤器，模块调用</li>
</ol>
<p>List 类型相关操作<br>按不同放入顺序排列<br>栈：同向命令<br>队列：反向命令<br>数组<br>阻塞，单播队列<br>ltrim<br>使用场景：<br>数据共享，迁出<br>无状态</p>
<p>Hash类型<br>对filed进行数值计算<br>场景：<br>点赞，收藏，详情页<br>聚合场景</p>
<p>Set类型<br>无序去重集合<br>元素变多扩容，会触发rehash，造成原顺序颠倒不稳定<br>集合操作多<br>随机事件：<br>RANDMEMBER key count<br>正数：取出一个去重的结果集(不能超过已有集)<br>负数：取出一个带重复的结果集，一定满足你要的数量<br>如果是0，不返回<br>应用场景：<br>随机事件==&gt;抽奖：<br>10个精品，参与人数&gt; 10 时，传正数，得到10个随机不重复值<br>10个精品，参与人数&lt; 10 时，传负数，得到10个可重复的值<br>中奖是否重复<br>Spop 不重复取出一个<br>推荐系统：<br>共同好友：交集<br>推荐好友：差集</p>
<p>Sorted set<br>排序<br>物理内存左小右大（根据分值从左到右从小到大）<br>不随命令发生变化<br>集合操作（并集，交集）权重、聚合指令<br>排序是怎么实现的。 ==&gt; skip List 跳跃表<br>增删改查的速度<br>场景：<br>排行榜，<br>有序事件<br>评论+分页</p>
<p>redis持久化<br>持久化意味着性能会下降<br>两个指标<br>快照：rdb,恢复的速度快，但缺失的多<br>日志：aof, ，<br>满足完整性好，恢复速度变慢，===&gt;采用不同日志策略避免<br>指令追加造成冗余量比较大 ===&gt; 使用重写</p>
<p>redis 分布式集群<br>可用性：<br>单点故障可通过主从主备一变多集群构建镜像，需要同步<br>强一致性，会破坏使用性<br>弱一致性，可用性强，但同步一致性低（默认）<br>最终一致性，使用黑盒可靠集群做中间缓存，保证主从数据最终一致性<br>数据存储压力问题(装不下)，采用分片式集群代理集群，也是一变多，但不需要同步</p>
<p>AkF拆分原则<br>根据业务划分数据到不同redis实例</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/systemDesign.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/systemDesign.html" itemprop="url">
                  系统设计案例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-02T09:31:06+08:00">
                2022-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>案例：用户将存储内容粘贴到站点，站点给用户返回一个短地址，用户通过短地址，可以访问之前粘贴的内容或者跳转之前的原始站点</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol>
<li><p>对于用户来说操作要简单，生成的短地址要简单，而且要唯一，不同用户即使内容一样也要生成唯一的短地址</p>
</li>
<li><p>时间有效性，从存储角度来说，不可能一直帮用户存储所有生成的短地址，不然存储会越来越大，所以通过设置短地址有效的访问时间，可以减少存储成本</p>
</li>
</ol>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ol>
<li>可用性(high Availability)， 保障用户功能可用</li>
<li>低延时(low latency)，用户拿到短地址或者通过短地址跳转其他网站时，重定向时间不宜过长</li>
<li>安全性（non guessable），不能被猜出来，用户在生成一定短地址时如果携带一些个人信息，不应体现在短地址中，否则会造成用户信息泄露</li>
<li>对于ins/微博/小红书之类的社交功能还要保障一致性，博主发的照片，follower看到的内容应该是一样的</li>
</ol>
<h1 id="容量负载能力假设"><a href="#容量负载能力假设" class="headerlink" title="容量负载能力假设"></a>容量负载能力假设</h1><p>对一个用户来说，可以抽象出两个主要请求</p>
<ol>
<li>请求生成短url，我们要把请求参数或者原始信息存储起来 inbound</li>
<li>请求访问url，把生成的url返回给用户使用，进行重定向 outbound</li>
</ol>
<p>假设一个短地址按500byte大小存储</p>
<h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>假设一个月会有100万个新短地址生成，<br>那么5年会产生</p>
<p>100万<em>5年</em>12个月 ==&gt; 约等于60亿个短地址</p>
<p>60亿*500byte ==&gt; 3TB 会有需要3TB大小的容量存储</p>
<h2 id="负载能力"><a href="#负载能力" class="headerlink" title="负载能力"></a>负载能力</h2><p>假设一个月有100个用户，每个用户会进行100万次访问短地址进行重定向的操作</p>
<p>那么每秒钟会有<br>（100 <em> 100万）/（30D </em> 24H * 3600s） ==&gt; 约等于4000个短url 要给到用户<br>同时会有<br>4000/ 100 ==&gt; 大概40个短url 需要被生成</p>
<p>那么服务所需要的带宽就可以计算出来</p>
<p>inbound : 40<em> 500 byte 约等于 20kb/s<br>outbound: 4000</em> 500 byte 约等于 20MB/s</p>
<h1 id="API-数据库设计"><a href="#API-数据库设计" class="headerlink" title="API 数据库设计"></a>API 数据库设计</h1><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>假设会用到简单的增删<br>生成短url createURL(api-key, originUrl, expired-Date, userId)<br>删除url  deleteURL(api-key,shortUrl)</p>
<h2 id="DataBase"><a href="#DataBase" class="headerlink" title="DataBase"></a>DataBase</h2><p>对于shortUrl</p>
<p>pk: hash<br>originUrl,<br>expired-date,<br>userId<br>…</p>
<p>对于user<br>pk: userId<br>name<br>…</p>
<h2 id="生成shortUrl"><a href="#生成shortUrl" class="headerlink" title="生成shortUrl"></a>生成shortUrl</h2><p>假如计划生成一个6个字符的短url，使用base64的加密算法的话可以生成64 ^ 6 大约640个短url,</p>
<p>满足之前5年会产生60个亿的唯一性需求</p>
<h1 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h1><p>用户 —&gt;request shortUrl generation —&gt; app</p>
<p>app —&gt; base64 encoding + 从key generation DB中拿一个nonUse 的key —&gt; 得到shortUrl —&gt;DB</p>
<p>DB —&gt; app –&gt;用户</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>2-8原则</p>
<p>用存储的20% 的url做cache内容，可以满足80% 的访问需求</p>
<h2 id="load-balance"><a href="#load-balance" class="headerlink" title="load balance"></a>load balance</h2><p>均衡流量</p>
<h2 id="过期后的url处理，key的处理"><a href="#过期后的url处理，key的处理" class="headerlink" title="过期后的url处理，key的处理"></a>过期后的url处理，key的处理</h2><h2 id="分布式存储，分片"><a href="#分布式存储，分片" class="headerlink" title="分布式存储，分片"></a>分布式存储，分片</h2><h2 id="对于社交功能的newFeed的推送"><a href="#对于社交功能的newFeed的推送" class="headerlink" title="对于社交功能的newFeed的推送"></a>对于社交功能的newFeed的推送</h2><p>pull / push / pull + push hybrid</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/question.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/question.html" itemprop="url">
                  一些其他小问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-29T16:20:02+08:00">
                2021-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.<br>在 useEffect 中如果使用了某些变量，却没有在依赖项中指定，会发生什么呢？</p>
<p>依赖那里没有传任何参数的话，会每次render都执行。<br>依赖项有传值但是，有部分依赖没有传，那么没有传的那部分，数据即使变化也不会执行副作用。</p>
<p>对于这节课中显示的 Blog 文章的例子，我们在 useEffect 中使用了 setBlogContent 这样一个函数，本质上它也是一个局部变量，那么这个函数需要被作为依赖项吗？为什么？</p>
<p>函数应该是不会变化的，所以不需要监听。</p>
<p>2.<br>useState 其实也是能够在组件的多次渲染之间共享数据的，那么在 useRef 的计时器例子中，能否用 state 去保存 window.setInterval() 返回的 timer 呢？</p>
<p>可以，只是没有 useRef 更优，因为在更新 state 值后会导致重新渲染，而 ref 值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。</p>
<p>3.<br>componentWillUnmount 近似的实现：组件销毁和文章 id 变化时执行。那么在函数组件中如果要实现严格的 componentWillUnmount，也就是只在组件销毁时执行，应该如何实现？\</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    // 这里只会在组件销毁前（componentWillUnmount）执行一次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<p>4.<br>每次调用 useArticle 这个 Hook 的时候都会触发副作用去获取数据。<br>但是有时候，我们希望在有些组件自动获取，但有的组件中需要点击某个按钮才去获取数据，那么你会如何设计这个 Hook？（可能这道题有一点难度。）</p>
<p>useArticle Hook 可以提供一个参数，用来标记本地调用是否默认触发副作用去获取数据；对于点击按钮才触发请求的功能，可以在 Hook 中将获取数据的方法 retrn 出去，供外部自由调用。</p>
<ol start="5">
<li>Hook 一般都是使用的 useState 保存了状态数据，也就意味着状态的范围限定在组件内部，组件销毁后，数据就没了。那么如果希望数据直接缓存到全局状态，应该如何做呢？</li>
</ol>
<p>可以借助 redux，配合 useContext 等 api ，将状态数据存储至全局中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/react/hooks/1129.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/react/hooks/1129.html" itemprop="url">
                  如何提升应用打开速度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-29T16:20:02+08:00">
                2021-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用-import-语句，定义按需加载的起始模块"><a href="#使用-import-语句，定义按需加载的起始模块" class="headerlink" title="使用 import 语句，定义按需加载的起始模块"></a>使用 import 语句，定义按需加载的起始模块</h1><p>对于这个需求，ECMA Script 标准有一个提案，专门用于动态加载模块，语法是 import(someModule)。<br>注意，这里的 import 和我们一般用于引入模块的静态声明方式不同，比如 import something from ‘somemodule’ 。<br>但这里的 import 是作为一个函数动态运行的，这个 import() 函数会返回一个 Promise。<br>这样，在模块加载成功后，就可以在 Promise 的 then 回调函数中去使用这个模块了。</p>
<p>虽然这只是一个提案，并没有成为标准，但是 Webpack 等打包工具利用了这样的语法去定义代码的分包。</p>
<p>也就是说，Webpack 实现了这样的语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ProfilePage() &#123;</span><br><span class="line">  // 定义一个 state 用于存放需要加载的组件</span><br><span class="line">  const [RealPage, setRealPage] = useState(null);</span><br><span class="line">  </span><br><span class="line">  // 根据路径动态加载真正的组件实现</span><br><span class="line">  import(&apos;./RealProfilePage&apos;).then((comp) =&gt; &#123;</span><br><span class="line">    setRealPage(Comp);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 如果组件未加载则显示 Loading 状态</span><br><span class="line">  if (!RealPage) return &apos;Loading....&apos;;</span><br><span class="line">  </span><br><span class="line">  // 组件加载成功后则将其渲染到界面</span><br><span class="line">  return &lt;RealPage /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import() 这个语句完全是由 Webpack 进行处理的。</p>
<p>按需加载的实现原理：Webpack 利用了动态 import 语句，自动实现了整个应用的拆包。<br>而在实际开发中，其实并不需要关心 Webpack 是如何做到的，<br>而只需要考虑：该在哪个位置使用 import 语句去定义动态加载的拆分点。</p>
<p>总体需要采用的策略是：按业务模块为目标去做隔离，尽量在每个模块的起始页面去定义这个拆分点。</p>
<p><b>react-loadable</b>，专门用于 React 组件的按需加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from &quot;react-loadable&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个显示加载状态的组件</span><br><span class="line">function Loading(&#123; error &#125;) &#123;</span><br><span class="line">  return error ? &apos;Failed&apos; : &apos;Loading&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// 创建加载器组件</span><br><span class="line">const HelloLazyLoad = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&quot;./RealHelloLazyLoad&quot;),</span><br><span class="line">  loading: Loading,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到 Loadable 这个高阶组件主要就是两个 API。</p>
<p>loader：用于传入一个加载器回调，在组件渲染到页面时被执行。<br>在这个回调函数中，我们只需要直接使用 import 语句去加载需要的模块就可以了。</p>
<p>loading：表示用于显示加载状态的组件。在模块加载完成之前，加载器就会渲染这个组件。<br>如果模块加载失败，那么 react-loadable 会将 errors 属性传递给 Loading 组件，方便你根据错误状态来显示不同的信息给用户。</p>
<p>按需加载可以说是减少首屏加载时间最为有效的手段，它可以让用户在打开应用时，无需加载所有代码就能开始使用，从而提升用户体验。</p>
<h1 id="使用-service-worker-缓存前端资源"><a href="#使用-service-worker-缓存前端资源" class="headerlink" title="使用 service worker 缓存前端资源"></a>使用 service worker 缓存前端资源</h1><p>和浏览器自动的资源缓存机制相比，Service Worker 加上 Cache Storage 这个缓存机制，具有更高的准确性和可靠性。</p>
<p>因为它可以确保两点：<br>缓存永远不过期。你只要下载过一次，就永远不需要再重新下载，除非主动删除。<br>永远不会访问过期的资源。换句话说，如果发布了一个新版本，那么你可以通过版本化的一些机制，来确保用户访问到的一定是最新的资源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">262</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
