<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/8/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/8/">





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/cssPosition.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/cssPosition.html" itemprop="url">
                  absolute应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T07:54:58+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题-背景"><a href="#问题-背景" class="headerlink" title="问题/背景"></a>问题/背景</h1><p>table 的 td 内容在内容较多时会自动进行省略处理，然后鼠标滑过弹层显示具体内容</p>
<p>td内容还可以配置在线编辑，鼠标滑过，可以显示小笔图标，点击小笔图标或者td块都可以进行在线编辑然后回车或者鼠标点击输入框之外的地方都可以提交发送给后台</p>
<p>table被包裹在一个div1中,只允许出现水平方向滚动条，不出现垂直方向滚动条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">  overflow-x: auto;</span><br><span class="line">  overflow-y: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出现的问题就是，如果最后几行的内容过多，弹层显示具体内容时弹层会被遮挡，不能正常飘出来<br><img src="/image/position1.png" alt="position1.png"></p>
<h1 id="原理知识"><a href="#原理知识" class="headerlink" title="原理知识"></a>原理知识</h1><p>父元素设置position:relative,子元素设置position:absolute,配套使用时，子元素才会会在z轴上相对父元素进行xy面的定位<br>如果最近父元素没有设置position:relative，那么会往父元素的父元素找，看是否设置，如果设置，则相对爷爷元素进行XY面定位，如果没有继续往上找，以此类推<br>即会相对父元素及以上元素中靠近自己最近的，设置了position:relative的长辈元素进行相对定位</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>弹层没有按照预期可以弹到div1以外的地方,被困在div1里面，加上div1不能垂直方向滚动，说明弹层没有相对div1定位,<br>解除div1垂直方向的滚动限制，弹层把div1在垂直方向上撑起来了，滚动滚动条，可以看完整的弹层内容，说明弹层相对div1的子元素定位了，<br>即从盛装省略内容的标签到div1的标签中，有标签设置了position:relative，</p>
<p>通过查找发现，在线编辑功能的小笔图标使用了position:absolute相对定位，在它最近的div2标签上设置了position:relative，<br>而div2标签包含了弹层所在标签，属于div1子元素，所以弹层就会相对div2定位，沿Z轴飘在div2这一层上面，就弹不到div1以外了</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>将div2上position:relative去掉，给在线编辑功能的小笔图标设置position:absolute的标签div3外加div4,设置position:relative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">解决前：</span><br><span class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;</span><br><span class="line">      &lt;div2 style=&apos;position:relative&apos;&gt;</span><br><span class="line">        &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</span><br><span class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</span><br><span class="line">      &lt;/div2&gt;</span><br><span class="line">      &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/div1&gt;</span><br><span class="line"></span><br><span class="line">解决后：</span><br><span class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;</span><br><span class="line">      &lt;div2&gt;</span><br><span class="line">        &lt;div4 style=&apos;position:relative&apos;&gt;</span><br><span class="line">          &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</span><br><span class="line">        &lt;/div4&gt;</span><br><span class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</span><br><span class="line">      &lt;/div2&gt;</span><br><span class="line">      &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/div1&gt;</span><br></pre></td></tr></table></figure>
<p>普通省略内容鼠标滑过<br><img src="/image/position2.png" alt="position2.png"><br>在线编辑内容省略时，鼠标滑过<br><img src="/image/position3.png" alt="position3.png"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/webpackTheory.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/webpackTheory.html" itemprop="url">
                  webpack原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-14T17:17:02+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>bundle.js能直接运行在浏览器中的原因是：<br>在输出文件中通过<strong>webpack_require</strong>函数，定义了一个可以在浏览器中执行的加载函数，来模拟Nodejs中的require语句</p>
<p><strong>webpack_require</strong> 函数将所有模块挂载一个对象上，通过判断该对象是否存在该模块实现模块缓存，防止二次加载</p>
<p>原来一个个独立的模块文件被合并到了一个单独的bundle.js的原因是<br>浏览器不能像Nodejs那样快速的在本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件，<br>如果模块的数量很多，则加载时间会很长，因此将所有模块都存放在了数组中，执行一次网络加载<br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack/outputFile.js" target="_blank" rel="noopener">输出文件分析</a></p>
<h1 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h1><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="获取loader配置的options"><a href="#获取loader配置的options" class="headerlink" title="获取loader配置的options"></a>获取loader配置的options</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const loaderUtils = require(&apos;loader-utils&apos;)</span><br><span class="line">module.exports = function(source)&#123;</span><br><span class="line">	//获取用户为当前loader传入的options</span><br><span class="line">	const options = loaderUtils.getOptions(this)</span><br><span class="line">	return source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回除了内容之外的东西"><a href="#返回除了内容之外的东西" class="headerlink" title="返回除了内容之外的东西"></a>返回除了内容之外的东西</h3><p>this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。 this.callback 的详细使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.callback( </span><br><span class="line">    // 当无法转换原内容时，给 Webpack 返回一个 Error </span><br><span class="line">    err: Error | null, </span><br><span class="line">    // 原内容转换后的内容 </span><br><span class="line">    content: string | Buffer, </span><br><span class="line">    // 用于把转换后的内容得出原内容的 Source Map，方便调试 </span><br><span class="line">    sourceMap?: SourceMap, </span><br><span class="line">    // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， </span><br><span class="line">    // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 </span><br><span class="line">    abstractSyntaxTree?: AST </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>实例：用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123; </span><br><span class="line">  // 通过 this.callback 告诉 Webpack 返回的结果 </span><br><span class="line">  this.callback(null, source, sourceMaps); </span><br><span class="line">  // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， </span><br><span class="line">  // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中  </span><br><span class="line">  return; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。 为此 Webpack 为 Loader 提供了 this.sourceMap API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。</p>
<h3 id="处理异步流程"><a href="#处理异步流程" class="headerlink" title="处理异步流程"></a>处理异步流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123; </span><br><span class="line">    // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 </span><br><span class="line">    var callback = this.async(); </span><br><span class="line">    someAsyncOperation(source, function(err, result, sourceMaps, ast) &#123; </span><br><span class="line">        // 通过 callback 返回异步执行后的结果 </span><br><span class="line">        callback(err, result, sourceMaps, ast); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123; </span><br><span class="line">    // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 </span><br><span class="line">    source instanceof Buffer === true; </span><br><span class="line">    // Loader 返回的类型也可以是 Buffer 类型的 </span><br><span class="line">    // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 </span><br><span class="line">    return source; </span><br><span class="line">&#125;; </span><br><span class="line">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据  </span><br><span class="line">module.exports.raw = true; //没有该行 Loader 只能拿到字符串。</span><br></pre></td></tr></table></figure>
<h3 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h3><p>在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。<br>如果想让Webpack 不缓存该 Loader 的处理结果，可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123; </span><br><span class="line">  // 关闭该 Loader 的缓存功能 </span><br><span class="line">  this.cacheable(false); </span><br><span class="line">  return source; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><p>this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。</p>
<p>this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。</p>
<p>this.resourcePath：当前处理文件的路径，例如 /src/main.js。</p>
<p>this.resourceQuery：当前处理文件的 querystring。</p>
<p>this.target：等于 Webpack 配置中的 Target。</p>
<p>this.loadModule：当 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。</p>
<p>this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。</p>
<p>this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。</p>
<p>this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。</p>
<p>this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。</p>
<p>this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。</p>
<h2 id="加载本地loader"><a href="#加载本地loader" class="headerlink" title="加载本地loader"></a>加载本地loader</h2><h3 id="方法一-Npm-link"><a href="#方法一-Npm-link" class="headerlink" title="方法一 Npm link"></a>方法一 Npm link</h3><p>Npm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。 由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。</p>
<p>完成 Npm link 的步骤如下：</p>
<p>1.确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好；<br>2.在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局；<br>3.在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。</p>
<p>链接好 Loader 到项目后就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。</p>
<h3 id="方法二-ResolveLoader"><a href="#方法二-ResolveLoader" class="headerlink" title="方法二 ResolveLoader"></a>方法二 ResolveLoader</h3><p>ResolveLoader用于配置 Webpack 如何寻找 Loader,默认情况下只会去 node_modules 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 resolveLoader.modules。<br>假如本地的 Loader 在项目目录中的 ./loaders/loader-name 中，则需要如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">  resolveLoader:&#123; </span><br><span class="line">    // 去哪些目录下寻找 Loader，有先后顺序之分 </span><br><span class="line">    modules: [&apos;node_modules&apos;,&apos;./loaders/&apos;], </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>plugin内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class BasicPlugin&#123; </span><br><span class="line">  // 在构造函数中获取用户给该插件传入的配置 </span><br><span class="line">  constructor(options)&#123; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 </span><br><span class="line">  apply(compiler)&#123; </span><br><span class="line">    compiler.plugin(&apos;compilation&apos;,function(compilation) &#123; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// 导出 Plugin </span><br><span class="line">module.exports = BasicPlugin;</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const BasicPlugin = require(&apos;./BasicPlugin.js&apos;); </span><br><span class="line">module.export = &#123; </span><br><span class="line">  plugins:[ </span><br><span class="line">    new BasicPlugin(options), </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Webpack 启动后，在读取配置的过程中会先执行 new BasicPlugin(options) 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 basicPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。</p>
<h2 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h2><p>Compiler 和 Compilation 的含义如下：</p>
<p>1.Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p>
<p>2.Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</p>
<p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。<br>Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p>
<p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ </span><br><span class="line"> 广播出事件 </span><br><span class="line"> event-name 为事件名称，注意不要和现有的事件重名 </span><br><span class="line"> params 为附带的参数 </span><br><span class="line">/ </span><br><span class="line">compiler.apply(&apos;event-name&apos;,params); </span><br><span class="line"> </span><br><span class="line">/ </span><br><span class="line"> 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。 </span><br><span class="line"> 同时函数中的 params 参数为广播事件时附带的参数。 </span><br><span class="line">*/ </span><br><span class="line">compiler.plugin(&apos;event-name&apos;,function(params) &#123; </span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>compilation.apply 和 compilation.plugin 使用方法和上面一致。</p>
<p>在开发插件时，还需要注意以下两点：</p>
<p>1.只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。<br>2.传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。<br>3.有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(&apos;emit&apos;,function(compilation, callback) &#123; </span><br><span class="line">    // 支持处理逻辑 </span><br><span class="line"> </span><br><span class="line">    // 处理完毕后执行 callback 以通知 Webpack  </span><br><span class="line">    // 如果不执行 callback，运行流程将会一直卡在这不往下执行  </span><br><span class="line">    callback(); </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h2><h3 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h3><p> Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时， 就会触发一次新的 Compilation。<br> 通过【watch-run】 事件可以知道是哪个文件发生变化导致了新的 Compilation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ 当依赖的文件发生变化时会触发 watch-run 事件 </span><br><span class="line">compiler.plugin(&apos;watch-run&apos;, (watching, callback) =&gt; &#123; </span><br><span class="line">    // 获取发生变化的文件列表 </span><br><span class="line">    const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes; </span><br><span class="line">    // changedFiles 格式为键值对，键为发生变化的文件路径。 </span><br><span class="line">    if (changedFiles[filePath] !== undefined) &#123; </span><br><span class="line">      // filePath 对应的文件发生了变化 </span><br><span class="line">    &#125; </span><br><span class="line">    callback(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(&apos;after-compile&apos;, (compilation, callback) =&gt; &#123; </span><br><span class="line">  // 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译 </span><br><span class="line">    compilation.fileDependencies.push(filePath); </span><br><span class="line">    callback(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h3><p>在 【emit】 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Plugin &#123; </span><br><span class="line">  apply(compiler) &#123; </span><br><span class="line">    compiler.plugin(&apos;emit&apos;, function (compilation, callback) &#123; </span><br><span class="line">      // compilation.chunks 存放所有代码块，是一个数组 </span><br><span class="line">      compilation.chunks.forEach(function (chunk) &#123; </span><br><span class="line">        // chunk 代表一个代码块 </span><br><span class="line">        // 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块 </span><br><span class="line">        chunk.forEachModule(function (module) &#123; </span><br><span class="line">          // module 代表一个模块 </span><br><span class="line">          // module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组 </span><br><span class="line">          module.fileDependencies.forEach(function (filepath) &#123; </span><br><span class="line">          &#125;); </span><br><span class="line">        &#125;); </span><br><span class="line"> </span><br><span class="line">        // Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件 </span><br><span class="line">        // 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时， </span><br><span class="line">        // 该 Chunk 就会生成 .js 和 .css 两个文件 </span><br><span class="line">        chunk.files.forEach(function (filename) &#123; </span><br><span class="line">          // compilation.assets 存放当前所有即将输出的资源 </span><br><span class="line">          // 调用一个输出资源的 source() 方法能获取到输出资源的内容 </span><br><span class="line">          let source = compilation.assets[filename].source(); </span><br><span class="line">        &#125;); </span><br><span class="line">      &#125;); </span><br><span class="line"> </span><br><span class="line">      // 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。 </span><br><span class="line">      // 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。 </span><br><span class="line">      callback(); </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h3><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 emit 事件，因为发生 emit 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 emit 事件是修改 Webpack 输出资源的最后时机。</p>
<p>所有需要输出的资源会存放在 compilation.assets 中，compilation.assets 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p>
<p>设置 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </span><br><span class="line">  // 设置名称为 fileName 的输出资源 </span><br><span class="line">  compilation.assets[fileName] = &#123; </span><br><span class="line">    // 返回文件内容 </span><br><span class="line">    source: () =&gt; &#123; </span><br><span class="line">      // fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer </span><br><span class="line">      return fileContent; </span><br><span class="line">      &#125;, </span><br><span class="line">    // 返回文件大小 </span><br><span class="line">      size: () =&gt; &#123; </span><br><span class="line">      return Buffer.byteLength(fileContent, &apos;utf8&apos;); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">  callback(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>读取 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </span><br><span class="line">  // 读取名称为 fileName 的输出资源 </span><br><span class="line">  const asset = compilation.assets[fileName]; </span><br><span class="line">  // 获取输出资源的内容 </span><br><span class="line">  asset.source(); </span><br><span class="line">  // 获取输出资源的文件大小 </span><br><span class="line">  asset.size(); </span><br><span class="line">  callback(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="判断-Webpack-使用了哪些插件"><a href="#判断-Webpack-使用了哪些插件" class="headerlink" title="判断 Webpack 使用了哪些插件"></a>判断 Webpack 使用了哪些插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 判断当前配置是否使用了 ExtractTextPlugin， </span><br><span class="line">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数 </span><br><span class="line">function hasExtractTextPlugin(compiler) &#123; </span><br><span class="line">  // 当前配置所有使用的插件列表 </span><br><span class="line">  const plugins = compiler.options.plugins; </span><br><span class="line">  // 去 plugins 中寻找有没有 ExtractTextPlugin 的实例 </span><br><span class="line">  return plugins.find(plugin=&gt;plugin.proto.constructor === ExtractTextPlugin) != null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class EndWebpackPlugin &#123; </span><br><span class="line"> </span><br><span class="line">  constructor(doneCallback, failCallback) &#123; </span><br><span class="line">    // 存下在构造函数中传入的回调函数 </span><br><span class="line">    this.doneCallback = doneCallback; </span><br><span class="line">    this.failCallback = failCallback; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  apply(compiler) &#123; </span><br><span class="line">    //done：在成功构建并且输出了文件后，Webpack 即将退出时发生；</span><br><span class="line">    compiler.plugin(&apos;done&apos;, (stats) =&gt; &#123; </span><br><span class="line">        // 在 done 事件中回调 doneCallback </span><br><span class="line">        this.doneCallback(stats); </span><br><span class="line">    &#125;); </span><br><span class="line">    //failed：在构建出现异常导致构建失败，Webpack 即将退出时发生；</span><br><span class="line">    compiler.plugin(&apos;failed&apos;, (err) =&gt; &#123; </span><br><span class="line">        // 在 failed 事件中回调 failCallback </span><br><span class="line">        this.failCallback(err); </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">// 导出插件  </span><br><span class="line">module.exports = EndWebpackPlugin; </span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">module.exports = &#123; </span><br><span class="line">  plugins:[ </span><br><span class="line">    // 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数； </span><br><span class="line">    new EndWebpackPlugin(() =&gt; &#123; </span><br><span class="line">      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作 </span><br><span class="line">    &#125;, (err) =&gt; &#123; </span><br><span class="line">      // Webpack 构建失败，err 是导致错误的原因 </span><br><span class="line">      console.error(err);    &#125;) </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>（启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。）<br>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3.确定入口：根据配置中的 entry 找出所有的入口文件；<br>4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>1.初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。<br>2.编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。<br>3.输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</p>
<h2 id="初始化阶段事"><a href="#初始化阶段事" class="headerlink" title="初始化阶段事"></a>初始化阶段事</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>初始化参数</td><td>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td></tr><tr><td>实例化 Compiler</td><td>用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。</td></tr><tr><td>加载插件</td><td>依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。</td></tr><tr><td>environment</td><td>开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。</td></tr><tr><td>entry-option</td><td>读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。</td></tr><tr><td>after-plugins</td><td>调用完所有内置的和配置的插件的 apply 方法。</td></tr><tr><td>after-resolvers</td><td>根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。</td></tr></tbody></table>

<h2 id="编译阶段事件"><a href="#编译阶段事件" class="headerlink" title="编译阶段事件"></a>编译阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>build-module</td><td>使用对应的 Loader 去转换一个模块。</td></tr><tr><td>normal-module-loader</td><td>在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</td></tr><tr><td>program</td><td>从配置的入口模块开始，分析其 AST，当遇到 <code>require</code> 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</td></tr><tr><td>seal</td><td>所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk</td></tr></tbody></table>

<h2 id="输出阶段事件"><a href="#输出阶段事件" class="headerlink" title="输出阶段事件"></a>输出阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>should-emit</td><td>所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td></tr><tr><td>emit</td><td>确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td></tr><tr><td>after-emit</td><td>文件输出完毕。</td></tr><tr><td>done</td><td>成功完成一次完成的编译和输出流程。</td></tr><tr><td>failed</td><td>如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td></tr></tbody></table>

<p>在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 Chunk。 在输出阶段会根据 Chunk 的类型，使用对应的模版生成最终要要输出的文件内容</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/webpackOptimization.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/webpackOptimization.html" itemprop="url">
                  webpack优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-29T16:21:02+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h1><p>目的是提升开发效率</p>
<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><p>解决项目庞大时构建的耗时加长的问题</p>
<h3 id="缩小文件查找范围"><a href="#缩小文件查找范围" class="headerlink" title="缩小文件查找范围"></a>缩小文件查找范围</h3><p>1.由于Loader对文件转换很耗时，所以应该让尽可能少的文件被处理，适当调整项目目录结构，在配置loader时通过【include】属性缩小处理命中文件范围<br>2.当安装第三方模块都放在项目根目录的./node_module目录下时，通过指明【resolve.modules】为存放第三方模块的绝对路径，减少寻找第三方模块的递归查找<br>3.在项目中所有第三方模块都采用main字段去描述入口文件时，只给【resolve.mainFileds】配置main字段，不使用默认值，减少搜索步骤<br>4.使用【resolve.alias】进行路径映射时，将导入模块的语句，替换成直接使用模块中完整文件的语句，减少耗时的对于lib中文件的解析工作<br>5.优化【resolve.extension】配置，减少尝试次数<br>a.后缀列表尽可能小，不要将项目中不可能存在的情况写到后缀列表中<br>b.频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程<br>c.在源码中写导入语句时，尽可能带上后缀，从而避免寻找过程<br>6.合理使用【module.noparse】属性，排除不需要进行模块解析处理的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">rules:&#123;</span><br><span class="line">	//只对项目根目录下src目录中文件采用配置的loader</span><br><span class="line">	include:path.resolve(__dirname,&apos;src&apos;)</span><br><span class="line">&#125;</span><br><span class="line">2.</span><br><span class="line">resolve:&#123;</span><br><span class="line">	//使用绝对路径指明第三方模块存放的位置，减少搜索步骤</span><br><span class="line">	modules:[path.resolve(__dirname,&apos;node_module&apos;)]</span><br><span class="line">&#125;</span><br><span class="line">3.</span><br><span class="line">resolve:&#123;</span><br><span class="line">	//减少入口查找</span><br><span class="line">	mainFilds:[&apos;main&apos;]</span><br><span class="line">&#125;</span><br><span class="line">4.</span><br><span class="line">resolve:&#123;</span><br><span class="line">	//减少第三方模块递归解析</span><br><span class="line">	alias:&#123; </span><br><span class="line">		&apos;react&apos;:path.resolve(__dirname,&apos;./node_module/react/dist/react.min.js&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用DLLPlugin"><a href="#使用DLLPlugin" class="headerlink" title="使用DLLPlugin"></a>使用DLLPlugin</h3><p>一个动态链接库文件可以包含为其他模块调用的函数和数据<br>提升构建速度的原理：<br>包含大量复用模块的动态链接库只需被编译一次，在之后的构建过程中被动态链接库包含的模块将不会重新编译，而是直接使用动态链接库的代码，<br>由于动态链接库中大多数包含的是常用的第三方模块，例如react,react-dom,所以只要不升级这些模块的版本，动态连接库就不用重新编译</p>
<p>DllPlugin:打包出一个个单独的动态链接库文件<br>DllReferencePlugin:用于在主要的配置文件中引入DllPlugin打包好的动态连接库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//webpack_dll.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const DllPlugin = require(&apos;webpack/lib/DllPlugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // JS 执行入口文件</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 把 React 相关的放到一个单独的动态链接库</span><br><span class="line">    react: [&apos;react&apos;, &apos;react-dom&apos;],</span><br><span class="line">    // 把项目需要所有的 polyfill 放到一个单独的动态链接库</span><br><span class="line">    polyfill: [&apos;core-js/fn/object/assign&apos;, &apos;core-js/fn/promise&apos;, &apos;whatwg-fetch&apos;],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，也就是 entry 中配置的 react 和 polyfill</span><br><span class="line">    filename: &apos;[name].dll.js&apos;,</span><br><span class="line">    // 输出的文件都放到 dist 目录下</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</span><br><span class="line">    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突</span><br><span class="line">    library: &apos;_dll_[name]&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 接入 DllPlugin</span><br><span class="line">    new DllPlugin(&#123;</span><br><span class="line">      // 动态链接库的全局变量名称，需要和 output.library 中保持一致</span><br><span class="line">      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span><br><span class="line">      // 例如 react.manifest.json 中就有 &quot;name&quot;: &quot;_dll_react&quot;</span><br><span class="line">      name: &apos;_dll_[name]&apos;,</span><br><span class="line">      // 描述动态链接库的 manifest.json 文件输出时的文件名称</span><br><span class="line">      path: path.join(__dirname, &apos;dist&apos;, &apos;[name].manifest.json&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">webpack_dll.config.js文件中，DllPlugin中的name参数必须和output</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const DllReferencePlugin = require(&apos;webpack/lib/DllReferencePlugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 定义 入口 Chunk</span><br><span class="line">    main: &apos;./main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 输出文件的名称</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    // 输出文件都放到 dist 目录下</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [&apos;babel-loader&apos;],</span><br><span class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 告诉 Webpack 使用了哪些动态链接库</span><br><span class="line">    new DllReferencePlugin(&#123;</span><br><span class="line">      // 描述 react 动态链接库的文件内容</span><br><span class="line">      manifest: require(&apos;./dist/react.manifest.json&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">    new DllReferencePlugin(&#123;</span><br><span class="line">      // 描述 polyfill 动态链接库的文件内容</span><br><span class="line">      manifest: require(&apos;./dist/polyfill.manifest.json&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devtool: &apos;source-map&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行构建流程：<br>先编译出动态链接库相关的文件，执行webpack –config webpack_dll.config.js<br>在确保动态链接库存在时才能正常编译入口文件，webpack.config.js中的DllReferencePlugin会依赖动态链接库相关文件，执行webpack命令</p>
<h3 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h3><p>提升构建速度原理：<br>将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，从而让webpack在同一时刻处理多个任务<br>实际表现就是<br>所有通过Loader处理的文件都先交给happypack/loader去处理，在收集到这些文件的处理权后，HappyPack就可以统一分配了<br>每通过new HappyPack() 去实例化一个HappyPack,其实就是告诉HappyPack核心调度器如何通过一系列Loader去转换一类文件，<br>并且可以指定如何为这类转换操作分配子进程<br>核心调度器的逻辑代码在主进程中，也就是运行着webpack的进程中，核心调度器会将一个个任务分配给当前空闲的子进程，<br>子进程处理完毕后将结果发送给核心调度，他们之间的数据交换是通过进程间的通信API实现的<br>核心调度器收到来自子进程处理完毕的结果后，会通知WebPack该文件已处理完毕</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // JS 执行入口文件</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./main.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    // 输出文件都放到 dist 目录下</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</span><br><span class="line">        use: [&apos;happypack/loader?id=babel&apos;],</span><br><span class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span><br><span class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [&apos;happypack/loader?id=css&apos;],</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span><br><span class="line">      id: &apos;babel&apos;,</span><br><span class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</span><br><span class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</span><br><span class="line">    &#125;),</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      id: &apos;css&apos;,</span><br><span class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</span><br><span class="line">      loaders: [&apos;css-loader&apos;],</span><br><span class="line">    &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: `[name].css`,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在实例化 HappyPack 插件的时候，除了可以传入 id 和 loaders 两个参数外，HappyPack 还支持如下参数：<br>threads: 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。<br>verbose: 是否允许 HappyPack 输出日志，默认是 true。<br>threadPool :代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line">// 构造出共享进程池，进程池中包含5个子进程</span><br><span class="line">const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span><br><span class="line">      id: &apos;babel&apos;,</span><br><span class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</span><br><span class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</span><br><span class="line">      // 使用共享进程池中的子进程去处理任务</span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">    &#125;),</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      id: &apos;css&apos;,</span><br><span class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</span><br><span class="line">      loaders: [&apos;css-loader&apos;],</span><br><span class="line">      // 使用共享进程池中的子进程去处理任务</span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">     &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: `[name].css`,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h3><p>提升构建速度原理：<br>当webpack有多个JS文件需要输出和压缩时，原本会使用UglifyJS去一个一个压缩再输出，但是ParallelUglifyPlugin会开启多个子进程，<br>将对多个文件的压缩工作分配给多个子进程完成，每个子进程其实还是通过UglifyJS去压缩代码，单变成了并行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path = require(‘path’);</span><br><span class="line">const DefinePlugin = require(‘webpack/lib/DefinePlugin’);</span><br><span class="line">const ParallelUglifyPlugin = require(‘webpack-parallel-uglify-plugin’);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      // 传递给 UglifyJS 的参数</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          // 最紧凑的输出</span><br><span class="line">          beautify: false,</span><br><span class="line">          // 删除所有的注释</span><br><span class="line">          comments: false,</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          // 在UglifyJs删除没有用到的代码时不输出警告</span><br><span class="line">          warnings: false,</span><br><span class="line">          // 删除所有的 console 语句，可以兼容ie浏览器</span><br><span class="line">          drop_console: true,</span><br><span class="line">          // 内嵌定义了但是只用到一次的变量</span><br><span class="line">          collapse_vars: true,</span><br><span class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</span><br><span class="line">          reduce_vars: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在通过 new ParallelUglifyPlugin() 实例化时，支持以下参数：<br>test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/，也就是默认压缩所有的 .js 文件。<br>include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。<br>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。<br>sourceMap：是否输出 Source Map，这会导致压缩过程变慢。<br>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</p>
<p>其中的 test、include、exclude 与配置 Loader 时的思想和用法一样<br>UglifyES 是 UglifyJS 的变种，专门用于压缩 ES6 代码，它们两都出自于同一个项目，并且它们两不能同时使用。<br>UglifyES 一般用于给比较新的 JavaScript 运行环境压缩代码，例如用于 ReactNative 的代码运行在兼容性较好的 JavaScriptCore 引擎中，为了得到更好的性能和尺寸，采用 UglifyES 压缩效果会更好。<br>ParallelUglifyPlugin 同时内置了 UglifyJS 和 UglifyES，也就是说 ParallelUglifyPlugin 支持并行压缩 ES6 代码。<br>如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。</p>
<h2 id="优化使用体验"><a href="#优化使用体验" class="headerlink" title="优化使用体验"></a>优化使用体验</h2><p>通过自动化手段完成一些重复工作，让我们专注于解决问题本身</p>
<h3 id="优化文件监听"><a href="#优化文件监听" class="headerlink" title="优化文件监听"></a>优化文件监听</h3><p>通过配置watchOption进行优化<br>ignored:/node_module/ 不监听node_module下文件 监听更少文件<br>agregatetionTimeout:值越大，降低构建频率<br>poll:值越小，降低检查频率<br>后面两项的配置会使监听模式的反应和灵敏度降低</p>
<h3 id="优化自动刷新性能"><a href="#优化自动刷新性能" class="headerlink" title="优化自动刷新性能"></a>优化自动刷新性能</h3><p>1.使用devserver开启inline时，devserver因为不知道某个网页依赖哪几个Chunk,所以会向每个输出的chunk中注入代理客户端代码<br>当项目输出多个chunk时，就会导致构建缓慢，因此关闭inline进行优化<br>如果不想以iframe方式去访问，但同时想让网页保持自动刷新功能，则需要手动向网页中注入代理客户端的脚本，<br>向index.html中注入webpack-dev-server.js,但要注意发布到线上时要删掉这段用于开发的代码</p>
<p>2.开启热替换时，控制台打印信息不能标明模块信息，可以使用NameModulesPlugin插件解决，从而在控制台打印出被修改的模块名称<br>注意关闭默认inline模式并手动注入客户端的方法，不能用于模块热替换的情况，原因在于模块热替换的运行依赖每个chunk中都包含代理客户端的代码</p>
<h1 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h1><p>目的是为用户呈现体验更好的网页</p>
<h2 id="减少用户能够感知到的加载时间-首屏时间"><a href="#减少用户能够感知到的加载时间-首屏时间" class="headerlink" title="减少用户能够感知到的加载时间(首屏时间)"></a>减少用户能够感知到的加载时间(首屏时间)</h2><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><p>问题：<br>开发过程会涉及到调试的代码,没必要发到线上给到用户<br>开发环境和线上接口地址不同，使用不同环境数据<br>线上代码会进行压缩，开发代码不需要、</p>
<p>解决：<br>当代码中使用了process模块的语句时，webpack会自动打包加入process模块代码来支持非nodejs运行环境<br>当代码中没有使用时，就不会打包加入<br>可以在源码中使用process.env.NODE_ENV环境变量去判断执行开发/线上环境的代码<br>环境变量的设置通过DefinePlugin设置<br>设置后，环境变量的值在webpack处理过程中会被代入源码中，替换掉process.env.NODE_ENV<br>访问proces的语句被替换，webpack也就不会在打包时加入process模块了</p>
<p>注意：DefinedPlugin定义的环境变量只对Webpack需要处理的代码有效，而不会影响Nodejs运行时的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new DefinePlugin(&#123;</span><br><span class="line">      // 定义 NODE_ENV 环境变量为 production </span><br><span class="line">      &apos;process.env&apos;: &#123;</span><br><span class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)//环境变量的值需要一个由双引号包裹的字符串&apos;&quot;production&quot;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>提升网页加载速度，减少网络传输流量，混淆代码以防有人下载代码进行代码分析和改造<br>通过插件形式引入UglifyJs，利用UglifyJs分析JS代码语法树，理解代码含义，<br>从而去掉无效代码，去掉日志输出代码，缩短变量名等优化,仅用于es5<br>UglifyJsPlugin:封装UglifyJs实现压缩<br>ParallelUglifyPlugin：多进行并行处理压缩<br>uglifyjsWebpackPlugin:引入UglifyES，压缩es6，要去掉.babelrc文件中的babel-preset-env，否则会将es6转es5<br>css-loader?minimize:压缩CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">1.UglifyJsPlugin</span><br><span class="line">const UglifyJSPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);//使用内置插件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">     new UglifyJSPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        // 在 UglifyES 删除没有用到的代码时不输出警告</span><br><span class="line">        warnings: false,</span><br><span class="line">        // 删除所有的 `console` 语句，可以兼容ie浏览器</span><br><span class="line">        drop_console: true,</span><br><span class="line">        // 内嵌定义了但是只用到一次的变量</span><br><span class="line">        collapse_vars: true,</span><br><span class="line">        // 提取出出现多次但是没有定义成变量去引用的静态值</span><br><span class="line">        reduce_vars: true,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        // 最紧凑的输出，默认会保留空格</span><br><span class="line">        beautify: false,</span><br><span class="line">        // 删除所有的注释</span><br><span class="line">        comments: false,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.uglifyjs-webpack-plugin</span><br><span class="line">const UglifyESPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">     new UglifyESPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;//相比UglifyJSPlugin 多了一层</span><br><span class="line">        compress: &#123;</span><br><span class="line">          // 在 UglifyES 删除没有用到的代码时不输出警告</span><br><span class="line">          warnings: false,</span><br><span class="line">          // 删除所有的 `console` 语句，可以兼容ie浏览器</span><br><span class="line">          drop_console: true,</span><br><span class="line">          // 内嵌定义了但是只用到一次的变量</span><br><span class="line">          collapse_vars: true,</span><br><span class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</span><br><span class="line">          reduce_vars: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">          // 最紧凑的输出</span><br><span class="line">          beautify: false,</span><br><span class="line">          // 删除所有的注释</span><br><span class="line">          comments: false,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.压缩CSS</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css/,// 增加对 CSS 文件的支持</span><br><span class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 用 WebPlugin 生成对应的 HTML 文件</span><br><span class="line">    new WebPlugin(&#123;</span><br><span class="line">      template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</span><br><span class="line">      filename: &apos;index.html&apos; // 输出的 HTML 的文件名称</span><br><span class="line">    &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h3><p>webpack接入CDN需要满足：<br>1.静态资源的导入URL需要变成指向CDN服务的绝对路径URL，而不是相对于HTML文件的URL<br>2.静态资源的文件名需要带上由文件内容算出来的Hash值，以防止被缓存<br>3.将不同类型资源放到不同域名CDN服务上，以防止资源的并行加载阻塞<br>实现主要依赖publicPath设置存放静态资源的CDN目录URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</span><br><span class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // Chunk app 的 JS 执行入口文件</span><br><span class="line">    app: &apos;./main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 给输出的 JavaScript 文件名称加上 Hash 值</span><br><span class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">    // 指定存放 JavaScript 文件的线上目录</span><br><span class="line">    publicPath: &apos;//js.cdn.com/id/&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [&apos;babel-loader&apos;],</span><br><span class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span><br><span class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 增加对 CSS 文件的支持</span><br><span class="line">        test: /\.css/,</span><br><span class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          // 压缩 CSS 代码</span><br><span class="line">          use: [&apos;css-loader?minimize&apos;],</span><br><span class="line">          // 指定存放 CSS 中导入的资源（例如图片）的线上目录</span><br><span class="line">          publicPath: &apos;//img.cdn.com/id/&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 增加对 PNG 文件的支持</span><br><span class="line">        test: /\.png/,</span><br><span class="line">        // 给输出的 PNG 文件名称加上 Hash 值</span><br><span class="line">        use: [&apos;file-loader?name=[name]_[hash:8].[ext]&apos;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 WebPlugin 自动生成 HTML，会根据publicPath用线上地址替换原来相对地址</span><br><span class="line">    new WebPlugin(&#123;</span><br><span class="line">      // HTML 模版文件所在的文件路径</span><br><span class="line">      template: &apos;./template.html&apos;,</span><br><span class="line">      // 输出的 HTML 的文件名称</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      // 指定存放 CSS 文件的线上目录</span><br><span class="line">      stylePublicPath: &apos;//css.cdn.com/id/&apos;,</span><br><span class="line">    &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      // 给输出的 CSS 文件名称加上 Hash 值</span><br><span class="line">      filename: `[name]_[contenthash:8].css`,</span><br><span class="line">    &#125;),</span><br><span class="line">    new DefinePlugin(&#123;</span><br><span class="line">      // 定义 NODE_ENV 环境变量为 production 去除开发时才需要的部分</span><br><span class="line">      &apos;process.env&apos;: &#123;</span><br><span class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 压缩输出的 JS 代码</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用tree-Shaking剔除用不上的代码"><a href="#使用tree-Shaking剔除用不上的代码" class="headerlink" title="使用tree Shaking剔除用不上的代码"></a>使用tree Shaking剔除用不上的代码</h2><p>Tree Shaking可以分析出那些代码被用上了，哪些没有<br>Tree Shaking正常工作的前提是，提交给webpack的js代码必须采用了ES6的模块化语法，因为es6模块化语法是静态的<br>（在导入，导出语句中的路径必须是静态字符串，而且不能放入其他代码块中），这让webpack可以简单地分析出那些export被import了。<br>实现：<br>1.修改.babelrc文件，保留ES6语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;:[</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;module&quot;:false//关闭模块转换功能，保留ES6语法</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用webpack –display-used-exports查看分析结果<br>2.使用uglifyJS剔除用不上的代码<br>可以在直接在配置文件中配置<br>也可以使用命令行执行<br>webpack –display-used-exports –optimize-minimize</p>
<p>处理但第三方库时，利用mainField告诉webpack采用那份入口文件，<br>当指定入口于文件采用es6模块化语法时，从而可以使用treeShaking进行代码优化</p>
<h3 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h3><p>问题：<br>相同资源被重复加载，浪费用户的流量和服务器成本<br>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验</p>
<p>解决：<br>将多个页面公共代码部分抽离成单独文件，用户在第一次访问后，公共文件代码被浏览器缓存<br>在用户切换其他页面时，则不会再重新加载存放公共代码的文件，而是直接从缓存中获取<br>从而<br>减少网络传输流量，降低服务器成本<br>虽然用户第一次打开网站的速度得不到优化，但之后访问其他页面的速度将提高</p>
<p>实现：<br>–根据网站所使用的技术栈，找出网站所有页面都需要用到的基础库(第三方库)，将他们提取到一个单独的文件base.js中<br>该文件包含了所有网页的基础运行环境，用于长期缓存，提高响应速度</p>
<p>–剔除了各个页面中被base.js包含的部分代码后，再找出所有页面都依赖的公共部分的代码，将他们提取到commom.js</p>
<p>–再为每个网页都生成一个单独的文件，不包含base.js和common.js中包含的部分，只包含各页面单独需要的部分代码</p>
<p>– 依赖CommonsChunkPlugin插件<br>CommonsChunkPlugin实例会生成一个新的Chunk，这个chunk中包含了被提取的代码<br>通过name属性告诉插件新生成的chunk的名称，chunks属性指明从哪些已有chunk中提取公共部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</span><br><span class="line">const CommonsChunkPlugin = require(&apos;webpack/lib/optimize/CommonsChunkPlugin&apos;);</span><br><span class="line">const &#123;AutoWebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 使用 AutoWebPlugin，自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用</span><br><span class="line">const autoWebPlugin = new AutoWebPlugin(&apos;pages&apos;, &#123;</span><br><span class="line">  template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</span><br><span class="line">  // 提取出所有页面公共的代码</span><br><span class="line">  commonsChunk: &#123;</span><br><span class="line">    name: &apos;common&apos;,// 提取出公共代码 Chunk 的名称</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</span><br><span class="line">  // autoWebPlugin.entry 方法可以获取到生成入口配置</span><br><span class="line">  entry: autoWebPlugin.entry(&#123;</span><br><span class="line">    // 这里可以加入你额外需要的 Chunk 入口</span><br><span class="line">    base: &apos;./base.js&apos;</span><br><span class="line">  &#125;),</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,// 给输出的文件名称加上 hash 值</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [&apos;babel-loader&apos;],</span><br><span class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span><br><span class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css/,// 增加对 CSS 文件的支持</span><br><span class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    autoWebPlugin,</span><br><span class="line">    // 为了从 common 中提取出 base 也包含的部分,减小common体积</span><br><span class="line">    new CommonsChunkPlugin(&#123;</span><br><span class="line">      // 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span><br><span class="line">      chunks: [&apos;common&apos;, &apos;base&apos;],</span><br><span class="line">      // 把公共的部分放到 base 中</span><br><span class="line">      name: &apos;base&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</span><br><span class="line">    &#125;),</span><br><span class="line">    new DefinePlugin(&#123;</span><br><span class="line">      // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分</span><br><span class="line">      &apos;process.env&apos;: &#123;</span><br><span class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 压缩输出的 JS 代码</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>common.js没有内容的时候解决<br>1.CommonsChunkPlugin的minChunks属性表示文件要被提取出来时需要在指定的Chunks中出现的最小次数，值越小，被提到common中的文件越多<br>2.根据各个页面之间的相关性选取其中的部分页面时，可用CommonChunkPlugin提取这部分被选出的页面的公共部分，<br>而不是提取所有页面的公共部分，而且这样的操作可以叠加多次，缺点是配置复杂，需要根据页面之间关系去思考如何配置<br>但该方法不通用</p>
<h3 id="分割代码按需加载"><a href="#分割代码按需加载" class="headerlink" title="分割代码按需加载"></a>分割代码按需加载</h3><p>问题<br>单页面应用一次性加载所有功能代码，实际在每个阶段只可能使用其中一部分</p>
<p>解决<br>将整个网站划分成一个个小功能，再按照每个功能的相关程度将他们分成几类<br>将每一类合并成一个Chunk,按需加载对应的Chunk<br>不要按需加载用户首次打开网站时需要看到的画面所对应的功能，将其放到执行入口所在的chunk中，<br>以减少用户能感知的网页加载时间<br>对于不依赖大量代码的功能点，可对其进行按需加载</p>
<p>实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//oneName.js</span><br><span class="line">module.exports= function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//加载语句</span><br><span class="line">import(/* webpackChunkName:&quot;oneName&quot; */ &apos;./oneName&apos;).then((oneName)=&gt;&#123;</span><br><span class="line">  oneName()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>webpack内置了对import(*)语句的支持，当webpack遇到类似的语句时会这样处理<br>以oneName.js为入口重新生成一个Chunk<br>当代码执行到import所在的语句时才去加载由Chunk对应生成的文件<br>import返回一个Promise,当文件加载成功时可以在Promise的then方法中获取oneName.js导出的内容</p>
<p>/* webpackChunkName:”oneName” */ 含义是为动态生成的Chunk赋予一个名称，以方便我们追踪和调试代码<br>如果不指定，则其默认的名称将会是[id].js<br>同样需要在webpack中配置chunkFilename属性，来指定动态生成的Chunk在输出时文件名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // JS 执行入口文件</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./main.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 为从 entry 中配置生成的 Chunk 配置输出文件的名称</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    // 为动态加载的 Chunk 配置输出文件的名称</span><br><span class="line">    chunkFilename: &apos;[name].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [&apos;babel-loader&apos;],</span><br><span class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//在.babellrc中需要引入组件来识别import(*)语法</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;:[</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;:[</span><br><span class="line">    &quot;syntax-dynamic-import&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">//实际应用</span><br><span class="line">import React, &#123;PureComponent, createElement&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;render&#125; from &apos;react-dom&apos;;</span><br><span class="line">import &#123;HashRouter, Route, Link&#125; from &apos;react-router-dom&apos;;</span><br><span class="line">import PageHome from &apos;./pages/home&apos;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步加载组件</span><br><span class="line"> * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve</span><br><span class="line"> * @returns &#123;AsyncComponent&#125; 返回一个高阶组件用于封装需要异步加载的组件</span><br><span class="line"> */</span><br><span class="line">function getAsyncComponent(load) &#123;</span><br><span class="line">  return class AsyncComponent extends PureComponent &#123;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      // 在高阶组件 DidMount 时才去执行网络加载步骤</span><br><span class="line">      load().then((&#123;default: component&#125;) =&gt; &#123;</span><br><span class="line">        // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          component,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123;component&#125; = this.state || &#123;&#125;;</span><br><span class="line">      // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例</span><br><span class="line">      return component ? createElement(component) : null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根组件</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">          &lt;Link to=&apos;/&apos;&gt;Home&lt;/Link&gt; | &lt;Link to=&apos;/about&apos;&gt;About&lt;/Link&gt; | &lt;Link to=&apos;/login&apos;&gt;Login&lt;/Link&gt;</span><br><span class="line">        &lt;/nav&gt;</span><br><span class="line">        &lt;hr/&gt;</span><br><span class="line">        &lt;Route exact path=&apos;/&apos; component=&#123;PageHome&#125;/&gt;</span><br><span class="line">        &lt;Route path=&apos;/about&apos; component=&#123;getAsyncComponent(</span><br><span class="line">          // 异步加载函数，异步地加载 PageAbout 组件</span><br><span class="line">          () =&gt; import(/* webpackChunkName: &apos;page-about&apos; */&apos;./pages/about&apos;)</span><br><span class="line">        )&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Route path=&apos;/login&apos; component=&#123;getAsyncComponent(</span><br><span class="line">          // 异步加载函数，异步地加载 PageAbout 组件</span><br><span class="line">          () =&gt; import(/* webpackChunkName: &apos;page-login&apos; */&apos;./pages/login&apos;)</span><br><span class="line">        )&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 渲染根组件</span><br><span class="line">render(&lt;App/&gt;, window.document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure></p>
<h2 id="提升流畅度"><a href="#提升流畅度" class="headerlink" title="提升流畅度"></a>提升流畅度</h2><p>提升代码性能<br>1.使用prepack优化代码运行时效率<br>通过在编译阶段预先执行源码来得到执行结果，再直接将运行结果放到编译后的代码中，而不是在代码运行时才去求值</p>
<p>prepack工作原理和流程大致如下：<br>通过Babel将JS源码解析成抽象语法树(AST)，以更细粒度地分析源码<br>PrePack实现了一个JS解释器，用于执行源码，借助这个解释器，Prepack才能理解源码具体是如何执行的<br>并将执行过程中的结果返回到输出中</p>
<p>因为还处于开发阶段，不能识别DOM api和部分nodejs API 代码，优化后文件尺寸可能大大增加，性能可能更差所以目前还不适合用于处理线上代码</p>
<p>2.开启Scope Hoisting<br>分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中，大前提是不能造成代码冗余，<br>因此只有那些被引用了一次的模块才能被合并<br>由于Scope Hosting需要分析模块之间的依赖关系，因此源码必须采用ES6语句，不然它将无法生效<br>对于非ES6模块化语法的代码，webpack会降级处理且不使用Scope Hoisting优化。<br>为了知道webpack对哪些代码做了降级处理，可以在启动webpack时带上–display-optimization-bailout参数<br>这样输出的日志就会告知是什么原因导致了降级处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const ModuleConcatenationPlugin = require(&apos;webpack/lib/optimize/ModuleConcatenationPlugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // JS 执行入口文件</span><br><span class="line">  entry: &apos;./main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    // 输出文件都放到 dist 目录下</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</span><br><span class="line">    mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 开启 Scope Hoisting</span><br><span class="line">    new ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>好处：<br>代码体积更小，因为函数申明语句会产生大量代码<br>代码在运行时因为创建的函数作用域变少，所以内存开销也变小了</p>
<h1 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h1><p>执行命令<br>webpack –profile –json &gt;stats.json<br>可以将构建相关的信息输出到stats.json文件中<br>1.打开http:\//webpack.github.io/analyse/ 上传stats文件，使用官方Webpack Analyse分析输出结果<br>2.使用webpack-bundle-analyzer进行分析<br>安装webpack-bundle-analyzer到全局<br>在项目根目录中执行webpack-bundle-analyzer，浏览器会打开对应网页并展现打包结果</p>
<p><a href="https://github.com/YooHannah/algorithm/blob/master/webpack-dist.config.js" target="_blank" rel="noopener">侧重优化输出质量的配置</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack.config.js" target="_blank" rel="noopener">侧重优化开发体验的配置</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/vue/vueCompile.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/vue/vueCompile.html" itemprop="url">
                  Vue编译初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T18:07:15+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/image/lifecycle.png" alt="Vue声明周期"><br>初始化之后调用$mount会挂载组件编译template</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>compile编译可以分成parse,optimize与generate三个阶段，最终得到render function<br>parse<br>parse 会用正则等方式循环切割字符串，解析template模板中的指令，class，style等数据，形成AST<br>optimize<br>标记static静态结点，这是编译过程的一处优化<br>generate<br>将AST转化成render function字符串的过程，得到的结果是render的字符串以及staticRenderFns</p>
<p>当render function 被调用的时候，因为会读取所需对象的值，所以会触发getter函数进行【依赖收集】<br>【依赖收集】的目的是将观察者Watcher对象存放到当前闭包中的订阅者Dep的subs中<br>在修改对象的值的时候，会触发对应的setter，setter通知之前【依赖收集】得到的Dep中的每一个Watcher<br>告诉他们自己的值改变了，需要重新渲染视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = function()&#123;</span><br><span class="line">	//挂在组件 已生成渲染函数,被调用</span><br><span class="line">	return mountComponent(this,el,hydrating) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//缓存 mount</span><br><span class="line">var mount = Vue.prototype.$mount;</span><br><span class="line"></span><br><span class="line">//重新覆盖 编译的功能</span><br><span class="line">Vue,prototype.$mount = function()&#123;</span><br><span class="line">	//挂在组件 生成render function</span><br><span class="line">	return mount.call(this,el)</span><br><span class="line">&#125;</span><br><span class="line">编译过程：字符串模板转成渲染函数</span><br><span class="line">运行时：调用渲染函数</span><br><span class="line">独立构建 = 编译+运行时</span><br><span class="line">运行时构建 = 运行时</span><br><span class="line"></span><br><span class="line">//模板的编译 分成parse,optimize与generate三个阶段，最终得到render function</span><br><span class="line">compileToFunctions(template)</span><br><span class="line">//render function生成通过new Function，可以将函数功能通过字符串传递进去生成新函数</span><br><span class="line">var render = new Function(参数,函数主体内容字符串)</span><br><span class="line">其中函数主体字符串的功能就是返回parse生成的抽象语法树AST</span><br><span class="line"></span><br><span class="line">渲染函数在哪被调用</span><br><span class="line">mountComponen()&#123;</span><br><span class="line">	//模板编译完成，实例挂载之前调用生命周期函数</span><br><span class="line">	callHook(vm,&apos;beforeMount&apos;) </span><br><span class="line"></span><br><span class="line">	初始化 updateComponent函数</span><br><span class="line">		在非生产环境下config.performance为true,</span><br><span class="line">		初始化 updateComponent时有进行性能追踪的相关代码</span><br><span class="line">		(进行性能追踪4个场景：</span><br><span class="line">		组件【初始化】时</span><br><span class="line">		【编译】时模板转渲染函数时</span><br><span class="line">		通过【渲染】函数生成虚拟DOM时</span><br><span class="line">		【打补丁】，虚拟DOM转真实Dom时)</span><br><span class="line">		vm.update(vm._render(),hydrating)</span><br><span class="line">		vm._render() === vm.$options.render() //生成虚拟节点vnode</span><br><span class="line">		vm.update() 把vm._render()生成的虚拟节点渲染成真实的DOM</span><br><span class="line">	updateComponent 用作参数生成Watcher，即数据发生变化时，可以重新渲染DOM节点</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="vm-option-render-渲染函数生成"><a href="#vm-option-render-渲染函数生成" class="headerlink" title="vm.$option.render 渲染函数生成"></a>vm.$option.render 渲染函数生成</h1><p>1.生成<br>vm.$option.render = render 构造器函数调用parse,generate生成函数主体字符串，<br>再调用new Function返回函数<br>2.探究渲染函数this指向<br>initProxy<br>【渲染函数的作用域代理】<br>    Proxy在目标对象之前架设一层拦截，拦截啥？<br>    读取get;设置set;key in proxyObject 属性检测；with(){}<br>    对一个new Proxy生成的对象进行上述操作时就会引发has钩子函数<br>vnode = render.call(vm._renderProxy,vm.$creatElement)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（function anonymous()&#123;//一个渲染函数</span><br><span class="line">//vm.renderProxy 访问变量A就会进行拦截 </span><br><span class="line">//调用proxy的has钩子函数 ，钩子函数中进行依赖收集，与生成的watcher进行绑定</span><br><span class="line">	with(this)&#123;return ...变量A...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="vue-对象生成"><a href="#vue-对象生成" class="headerlink" title="vue 对象生成"></a>vue 对象生成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//vue 对象生成</span><br><span class="line">(function(global,factory)&#123;</span><br><span class="line">	typeof exports === &apos;object&apos; &amp;&amp; typeof module !==&apos;undefinded&apos; ?module.export = factory():</span><br><span class="line">	typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory):</span><br><span class="line">	(global.Vue = factory());//window.Vue cmd AMD Comonjs</span><br><span class="line">&#125;)(this,function()&#123;</span><br><span class="line">	var ASSET_TYPES = [</span><br><span class="line">		&apos;components&apos;,</span><br><span class="line">		&apos;directives&apos;,</span><br><span class="line">		&apos;filters&apos;</span><br><span class="line">	]</span><br><span class="line">	//全局配置对象 挂载在Vue对象上，用作接口，进行自定义策略</span><br><span class="line">	(怎样处理自定义挂载在vue上的属性，和vue自身的同名属性，二者合并options时的处理方案)</span><br><span class="line">	//Vue.config.optionMergeStrategies.xxxx = function()&#123;&#125;</span><br><span class="line">	var config = &#123;</span><br><span class="line">		optionMergeStrategies:Object.create(null)</span><br><span class="line">	&#125;</span><br><span class="line">	//自定义策略</span><br><span class="line">	var strats = config.optionMergeStrategies</span><br><span class="line">	strats.data = function(parentVal,childVal,vm,key)&#123;</span><br><span class="line">        return function mergedInstanceDataFn()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//默认策略</span><br><span class="line">	function defaultStrats(parentVal,childVal,vm)&#123;</span><br><span class="line">		return childVal === undefined? parentVal:childVal</span><br><span class="line">	&#125;</span><br><span class="line">	var has = function(obj,key)&#123;</span><br><span class="line">		return obj != null &amp;&amp; Object.hasOwnProperty.call(obj,key)</span><br><span class="line">	&#125;</span><br><span class="line">	function mergeOption(parent,child,vm)&#123;</span><br><span class="line">		var options = &#123;&#125;</span><br><span class="line">		var key</span><br><span class="line">		for(key in parent)&#123; //parent=&gt;component directive filters 本身具备的</span><br><span class="line">			mergeFild(key)</span><br><span class="line">		&#125;</span><br><span class="line">		for(key in child)&#123; //child =&gt;el data component 外部传参进来</span><br><span class="line">			if(!has(parent,key))&#123; //拦截重复操作</span><br><span class="line">				mergeFild(key)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//选项的处理celve</span><br><span class="line">		function mergeFild(key)&#123;</span><br><span class="line">			//生成最终需要数据</span><br><span class="line">			//合并策略 自定义策略 默认策略</span><br><span class="line">			console.log(key)</span><br><span class="line">			var strat = strats[key] || defaultStrats</span><br><span class="line">			options[key] = strat(parent[key],child[key],vm)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return options</span><br><span class="line">	&#125;</span><br><span class="line">	function initMixin(vue)&#123;</span><br><span class="line"></span><br><span class="line">		Vue.prototype._init = function(options)&#123;</span><br><span class="line">			var vm = this</span><br><span class="line">			//合并选项 VUE.option option</span><br><span class="line">			vm.$options = mergeOption(Vue.options,options||&#123;&#125;,vm)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	function initGlobalAPI(Vue)&#123;</span><br><span class="line">		var configDef = &#123;&#125;;</span><br><span class="line">		configDef.get = function()&#123;</span><br><span class="line">			return config</span><br><span class="line">		&#125;</span><br><span class="line">		configDef.set = function(val)&#123;</span><br><span class="line">			console.error(&apos;不要修改config&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">		//Vue.config = config 对修改config做拦截,但可以对config的属性进行操作</span><br><span class="line">		//Vue.config.optionMergeStrategies 可以进行扩展自定义策略</span><br><span class="line">		Object.defineProperty(Vue,&apos;config&apos;,configDef)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function Vue(options)&#123;</span><br><span class="line">		if(!(this instanceof Vue))&#123;</span><br><span class="line">			console.error(&apos;....&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">		this._init(options)</span><br><span class="line">	&#125;</span><br><span class="line">	Vue.options = Object.create(null);</span><br><span class="line">	ASSET_TYPES.foreach(function(type)&#123;</span><br><span class="line">		Vue.options[type] = Object.create(null)</span><br><span class="line">	&#125;)</span><br><span class="line">	initMixin(Vue)</span><br><span class="line">	initGlobalAPI(Vue)initGlobalAPI(Vue)</span><br><span class="line">	return Vue</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/reactNativeNavigation.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/reactNativeNavigation.html" itemprop="url">
                  react-navigation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-02T21:11:37+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-navigation</span><br><span class="line">yarn add react-native-gesture-handler</span><br><span class="line">react-native link react-native-gesture-handler //Link 所有的原生依赖</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">APP.js</span><br><span class="line">import React from &quot;react&quot;; </span><br><span class="line">import &#123; View, Text &#125; from &quot;react-native&quot;;</span><br><span class="line">import &#123; createStackNavigator, createAppContainer &#125; from &quot;react-navigation&quot;; </span><br><span class="line">class HomeScreen extends React.Component &#123;</span><br><span class="line">     render() &#123;</span><br><span class="line">          return (</span><br><span class="line">               &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125;&gt; </span><br><span class="line">                    &lt;Text&gt;Home Screen&lt;/Text&gt; </span><br><span class="line">               &lt;/View&gt; ); </span><br><span class="line">    &#125; &#125; </span><br><span class="line">const AppNavigator = createStackNavigator(</span><br><span class="line">    &#123;</span><br><span class="line">        HomeComponent: &#123; screen: HomeScreenComponent &#125; //screen属性设置组件路由,HomeScreen只是一个组件</span><br><span class="line">        Home: HomeScreen,//直接配置页面路由</span><br><span class="line">        Details: DetailsScreen</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        initialRouteName: &quot;Home&quot;//指定默认路由</span><br><span class="line">        defaultNavigationOptions: &#123; //指定全局默认标题样式</span><br><span class="line">            headerStyle: &#123;</span><br><span class="line">                backgroundColor: &apos;#f4511e&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">            headerTintColor: &apos;#fff&apos;,</span><br><span class="line">            headerTitleStyle: &#123;</span><br><span class="line">                fontWeight: &apos;bold&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">const AppContainer = createAppContainer(AppNavigator);</span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  someEvent() &#123;</span><br><span class="line">    // call navigate for AppNavigator here:</span><br><span class="line">    this.navigator &amp;&amp;</span><br><span class="line">      this.navigator.dispatch( //在 App 容器中使用 dispatch，可以使用 ref 来调用 dispatch 方法</span><br><span class="line">        NavigationActions.navigate(&#123; routeName: someRouteName &#125;)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;AppContainer</span><br><span class="line">        //每当导航器管理的 navigation state 发生变化时，都会调用该函数 </span><br><span class="line">        onNavigationStateChange=&#123;handleNavigationChange&#125; </span><br><span class="line">        uriPrefix=&quot;/app&quot;//应用可能会处理的 URI 前缀， 在处理一用于提取传递给 route 的一个 深度链接时将会用到</span><br><span class="line">        ref=&#123;nav =&gt; &#123;</span><br><span class="line">          this.navigator = nav;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>this.props.navigation.navigate(路由名,传参对象)//跳转其他页，如果跳转本页，没反应<br>this.props.navigation.push(路由名)//可以重新加载当前页<br>每次调用 ‘ push ‘ 时, 我们会向导航堆栈中添加新路由。<br>当你调用 ‘ navigate ‘ 时, 它首先尝试查找具有该名称的现有路由, 并且只有在堆栈上没有一个新路由时才会推送该路由。<br>读取页面组件中的参数的方法：<br>this.props.navigation.state.params<br>this.props.navigation.getParam(key值)</p>
<p>如果当前页面可以执行返回操作，则 stack navigator 会自动提供一个包含返回按钮的标题栏<br>如果导航堆栈中只有一个页面，则没有任何可返回的内容，因此也不存在返回键。<br>this.props.navigation.goBack() //手动返回上一页</p>
<p>如果处在堆栈深处，上面有多个页面，此时想要将上面所有的页面都销毁，并返回第一个页面。<br>在这种情况下，我们知道我们要回到’ Home ‘，所以我们可以使用’ navigate(‘Home’) ‘,而不是<code>push</code><br>另一个选择是’ navigation.popToTop() ‘，它可以返回到堆栈中的第一个页面。</p>
<p>如何发现用户离开和回来的某页面？<br>一个包含 页面 A 和 B 的 StackNavigator ，当跳转到 A 时，componentDidMount 方法会被调用； 当跳转到 B 时，componentDidMount 方法也会被调用，但是 A 依然在堆栈中保持 被加载状态，他的 componentWillUnMount 也不会被调用。<br>当从 B 跳转到 A，B的 componentWillUnmount 方法会被调用，但是 A 的 componentDidMount方法不会被调用，应为此时 A 依然是被加载状态。<br>React Navigation 将事件发送到订阅了它们的页面组件： 有4个不同的事件可供订阅：willFocus、willBlur、didFocus 和 didBlur。</p>
<h2 id="标题栏"><a href="#标题栏" class="headerlink" title="标题栏"></a>标题栏</h2><p>使用 组件静态属性navigationOptions</p>
<h3 id="内容配置"><a href="#内容配置" class="headerlink" title="内容配置"></a>内容配置</h3><p>title属性<br>方式一:对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = &#123;</span><br><span class="line">    title: &apos;Home&apos;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>方式二：返回对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = (&#123; navigation &#125;) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: navigation.getParam(&apos;otherParam&apos;, &apos;A Nested Details Screen&apos;),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>尝试在navigationOptions中使用this.props可能很诱人，但因为它是组件的静态属性，所以this不会指向一个组件的实例，因此没有 props 可用。 相反，如果我们将navigationOptions作为一个函数，那么React Navigation将会用包含{navigation，navigationOptions，screenProps}的对象调用它 – 在这种情况下，我们只用关心navigation，它是与传递给页面的this.props.navigation相同的对象</p>
<p>从已加载的页面组件本身更新当前页面的navigationOptions配置<br>this.props.navigation.setParams({otherParam: ‘Updated!’})</p>
<h3 id="标题样式"><a href="#标题样式" class="headerlink" title="标题样式"></a>标题样式</h3><p>headerStyle：一个应用于 header 的最外层 View 的 样式对象， 如果设置 backgroundColor ，他就是header 的颜色。对象<br>headerTintColor：返回按钮和标题都使用这个属性作为它们的颜色。字符串<br>headerTitleStyle：如果想为标题定制fontFamily，fontWeight和其他Text样式属性，我们可以用它来完成。对象</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>配置路由时利用defaultNavigationOptions配置<br>当全局设置了默认样式，具体页面也设置了static navigationOptions，则优先使用具体页面</p>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><p>headerTitle：配置一个组件，自定义标题的样式<br>headerRight：自定义右侧按钮<br>headerLeft：自定义左侧/返回按钮<br>headerBackImage：自定义返回按钮图片<br>注意在navigationOptions中this绑定的不是 HomeScreen 实例，所以你不能调用setState方法和其上的任何实例方法。 这一点非常重要，因为标题栏中的按钮与标题栏所属的页面进行交互是非常常见的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/vue/vuesubmenu.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/vue/vuesubmenu.html" itemprop="url">
                  二级菜单实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T16:38:15+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>page A是一个管理页面，数据通过table 展示<br>page B是一个详情页面，通过page A 中的一条数据跳转链接进来<br>page B数据获取时的参数需要在page A跳转时带进来<br>page B 本来只是一个简单页面,现在要在page B中添加一列菜单，可以导航多个不同内容详情<br>即现在page A要跳转的是一个带菜单的页面，点击每个菜单跳转不同的页面</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>1.vue-router配置时，children属性配置的子页面，在访问时，会在父页面的router-view标签部分进行填充<br>如果父页面没有router-view标签子页面内容就没地方展示<br>菜单就放在父页面，点击跳转子页面路由<br>2.因为页面跳转完成后，当前路由对象不会携带自己的children属性，给子路由配置title，父页面拿不到<br>所以父页面的菜单映射关系需要在其他地方配置，传递进来</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>子菜单名和对应路由的映射，放在page A跳转配置中，page A 配置的点击跳转的页面是其中一个子路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;title: &apos;名称&apos;, value: &apos;name&apos;, display: true,</span><br><span class="line">      shadow: &#123;path: &apos;Adetail_C&apos;, key: &apos;&apos;,title:&apos;AAAA&apos;,submenu:[&#123;</span><br><span class="line">        path:&apos;Adetail_C&apos;,name:&apos;C&apos;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        path:&apos;Adetail_D&apos;,name:&apos;D&apos;</span><br><span class="line">      &#125;]&#125;, </span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>新增子菜单路由页面page A-detail-router,子菜单映射页面page C和page D</p>
<p>页面page A-detail-router中，可以通过this.$route对象拿到page A配置的菜单映射关系，从而渲染菜单<br>切换子页面时,需要增加把参数传递到子页面中的逻辑</p>
<p>page C和page D根据路由中传递过来的page A点击数据的信息进行数据请求和页面渲染</p>
<p>在项目路由配置文件中配置路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;A&apos;,  name: &apos;A&apos;, title: &apos;XX管理&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/pageA&apos;) &#125;,</span><br><span class="line">&#123; path: &apos;AdetailRouter&apos;,  name: &apos;AdetailRouter&apos;, title: &apos;XX详情&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/A-detail-router&apos;), </span><br><span class="line">    children:[&#123;</span><br><span class="line">    path:&apos;/Adetail_C&apos;,name: &apos;Adetail_C&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;, component: () =&gt; import(&apos;@/Adetail_C&apos;)</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    path:&apos;/Adetail_D&apos;,name: &apos;Adetail_D&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;,component: () =&gt; import(&apos;@/Adetail_D&apos;)</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>children配置path时，以‘/’开头和不以‘/’开头区别：<br>以’/‘开头最终访问路径就是配置路径‘#/子path’，相当于子路由当一级路由<br>但不以‘/’开头最终的访问路径是‘#/父path/子path’,<br>这里使用‘/’开头是因为更外层菜单，在跳转page A同级路由时使用的是push({path:xxx})<br>如果使用不以‘/’开头的配置，跳转page A同级路由，路径就会变成‘#/父path/xxx’，即父路径下跳转<br>会因为没有相应配置路由找不到页面，所以使用‘/’开头，当作父路由跳转<br>其实在跳转page A同级路由时使用的是push({name:xxx}),就可以直接解决‘#/父path/xxx’问题，<br>跳转正确页面</p>
<p>缺点：<br>直接通过浏览器刷新子页面时，路由对象的params属性数据清空，<br>路由页面菜单映射没有数据支持，菜单没有内容<br>子页面路由因此也拿不到参数，无法请求数据<br>动作流向只有利用路由对象的meta属性的previousMenu跳转回page A</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>子菜单名和对应路由的映射放在单独json文件中，利用子菜单名字获取映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//submenu.json</span><br><span class="line">&#123;</span><br><span class="line">    Adetail:&#123;</span><br><span class="line">        title:&apos;AAAA&apos;</span><br><span class="line">        submenu:[&#123;</span><br><span class="line">            name:&apos;Adetail_C&apos;,//路由里配置的name</span><br><span class="line">            label:&apos;C&apos;,</span><br><span class="line">            show:true //之后根据路由参数query决定是否显示该菜单</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:&apos;Adetail_  D&apos;,</span><br><span class="line">            label:&apos;D&apos;,</span><br><span class="line">            show:true</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在路由页面page A-detail-router中根据访问的子菜单路由名获取二级菜单,这样解决刷新页面菜单数据无处获取的问题</p>
<p>使用动态路由传递参数id保证页面刷新时子页面params至少有一个属性可以依赖来获取数据<br>更改路由配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;A&apos;,  name: &apos;A&apos;, title: &apos;XX管理&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/pageA&apos;) &#125;,</span><br><span class="line">&#123; path: &apos;Adetail&apos;,  name: &apos;Adetail&apos;, title: &apos;XX详情&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/A-detail-router&apos;), </span><br><span class="line">    children:[&#123;</span><br><span class="line">    path:&apos;C/:id&apos;,name: &apos;Adetail_C&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;, component: () =&gt; import(&apos;@/Adetail_C&apos;)</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    path:&apos;D/:id&apos;,name: &apos;Adetail_D&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;,component: () =&gt; import(&apos;@/Adetail_D&apos;)</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>‘：id’对应路由对象中params属性的id属性，所以访问时，一定要在跳转的路由中配置{params:{id:xxxxxx}}<br>更改路由页面page A-detail-router中跳转其他路由页面时,参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gotoPage (val,index) &#123;</span><br><span class="line">    this.active = index</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">        name: val.name,</span><br><span class="line">        params:&#123;id:this.$route.params.id&#125;, //给其他子页面传递id</span><br><span class="line">        query:this.$route.query//其他自定义参数</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>这样访问子页面时路径就变成’#/Adetail/C/xxxxxxxxxxxxxxxx’<br>以上处理基本解决掉方案一问题</p>
<p>后续需要根据page A 数据的其他属性值决定菜单显示,所以在配置跳转时配置要传递的属性key<br>在跳转时，根据KEY获取值，组装成都对象，放在query中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//配置：</span><br><span class="line">&#123;title: &apos;名称&apos;, value: &apos;dbname&apos;, display: true,link: &#123;path: &apos;databaseDetail_outline&apos;, key: &apos;dbinstance_id&apos;,query:[&apos;dbtype.dbtype&apos;]&#125;&#125;</span><br><span class="line">link属性即与跳转相关的配置，</span><br><span class="line">path:跳转路由名</span><br><span class="line">key:以数据哪个属性当id，字符串</span><br><span class="line">query:需要传递的其他参数，字符串数组</span><br><span class="line">//列表点击跳转</span><br><span class="line">jump (item, val) &#123;</span><br><span class="line">     //根据key获取值，key对应的可能不是子属性，而是孙属性，或者更深层次属性，valueFromExpression函数用于获取深层属性值</span><br><span class="line">    let id = valueFromExpression(item, val.link.key) </span><br><span class="line">    let router = &#123;</span><br><span class="line">        name: val.link.path,</span><br><span class="line">        params: &#123;id: id&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(val.link.query)&#123;//根据key值组装传参对象</span><br><span class="line">        router.query = val.link.query.map(key=&gt;&#123;return &#123;[key]:valueFromExpression(item, key)&#125;&#125;).reduce((result,item)=&gt;&#123;return Object.assign(result,item)&#125;,&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.$router.push(router)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>因为打算将路由页面page A-detail-router作为公共页面，page A同级页面的其他页面也可以使用<br>所以将判断子菜单是否显示的逻辑放在跳转的那个子页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">//page A-detail-router</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;subcontainer&quot; v-if=&quot;submenuConfig&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;submenu&quot;&gt;</span><br><span class="line">        &lt;!-- &lt;div  class=&quot;subTitle&quot; @click=&quot;goBack()&quot;&gt;&#123;&#123;submenuConfig.title&#125;&#125;&lt;/div&gt; --&gt;</span><br><span class="line">        &lt;div  class=&quot;subTitle&quot; @click=&quot;goBack()&quot;&gt;&lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt;&lt;/div&gt;</span><br><span class="line">        &lt;template v-for=&quot;(item,index) in submenuConfig.submenu&quot;&gt;</span><br><span class="line">          &lt;div v-if=&apos;item.show&apos; @click=&quot;gotoPage(item,index)&quot; :key=&quot;index&quot; class=&quot;subbtn&quot; :class=&quot;active===index?&apos;subactive&apos;:&apos;&apos;&quot;&gt;</span><br><span class="line">            &lt;a&gt;&#123;&#123;item.label&#125;&#125;&lt;/a&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import submenuText from &apos;../../../common/submenu&apos;</span><br><span class="line">  export default &#123; </span><br><span class="line">    name: &apos;submenu_detail&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        submenuConfig:null,</span><br><span class="line">        active:0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      let routeName = this.$route.name</span><br><span class="line">      this.submenuConfig = submenuText[routeName.split(&apos;_&apos;)[0]] //获取菜单配置</span><br><span class="line">      this.active = this.submenuConfig.submenu.findIndex((item)=&gt;&#123;return item.name === routeName&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      gotoPage (val,index) &#123;</span><br><span class="line">        this.active = index</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">          name: val.name,</span><br><span class="line">          params:&#123;id:this.$route.params.id&#125;,</span><br><span class="line">          query:this.$route.query</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      goBack()&#123;</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">          name:this.$route.meta.previousMenu</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">  .subcontainer&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-grow: row  nowrap;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    align-content:stretch;</span><br><span class="line">    margin: -20px;</span><br><span class="line">    .submenu&#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-flow: column;</span><br><span class="line">      align-content: center;</span><br><span class="line">      width: 200px;</span><br><span class="line">      flex:none;</span><br><span class="line">      background-color: #EAEDF1;</span><br><span class="line">      height: 100%;</span><br><span class="line">      position: absolute;</span><br><span class="line">      .subTitle&#123;</span><br><span class="line">        //内容为标题时样式</span><br><span class="line">        // font-weight: bold;</span><br><span class="line">        // text-indent: 20px;</span><br><span class="line">        // height: 70px;</span><br><span class="line">        // line-height: 70px;</span><br><span class="line">        // background: #D9DEE4;</span><br><span class="line">        // overflow: hidden;</span><br><span class="line">        // text-overflow: ellipsis;</span><br><span class="line">        // white-space: nowrap;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        height: 70px;</span><br><span class="line">        line-height: 70px;</span><br><span class="line">        background: #D9DEE4;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        color: #546478;</span><br><span class="line">        text-align: center</span><br><span class="line">      &#125;</span><br><span class="line">      .subTitle:hover&#123;</span><br><span class="line">        color: #0080FF;</span><br><span class="line">      &#125;</span><br><span class="line">      .subbtn&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        font-size: 15px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        padding: 10px 0px;</span><br><span class="line">        a&#123;</span><br><span class="line">          color:#000;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .subbtn:hover&#123;</span><br><span class="line">        background-color: #f8f8f8;</span><br><span class="line">        background: #f8f8f8;</span><br><span class="line">      &#125;</span><br><span class="line">      .subactive&#123;</span><br><span class="line">          background-color: #fff;</span><br><span class="line">        background: #fff;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">      flex:1;</span><br><span class="line">      padding: 20px;</span><br><span class="line">      margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">//子菜单页面</span><br><span class="line">mounted() &#123;</span><br><span class="line">      if(this.$route.query[&apos;dbtype.dbtype&apos;] != &apos;mysql&apos;)&#123;</span><br><span class="line">        this.$parent.submenuConfig.submenu[1].show = false</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        this.$parent.submenuConfig.submenu[1].show = true</span><br><span class="line">      &#125;</span><br><span class="line">      this.getDetail(this.$route.params.id)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/webpackconfig.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/webpackconfig.html" itemprop="url">
                  webpack应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-10T17:08:02+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.export = &#123;</span><br><span class="line">	entry:&apos;./main.js&apos;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&apos;bundle.js&apos;,</span><br><span class="line">		path:path.resolve(__dirname,&apos;./dist&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接入babel"><a href="#接入babel" class="headerlink" title="接入babel"></a>接入babel</h1><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置.babelrc</h2><p>需要额外配置.babelrc文件，该文件是一个JSON格式文件<br>plugins属性，告诉Babel要使用哪些插件，这些插件可以控制如何转换代码<br>babel-plugin-transform-runtime：减少冗余代码<br>babel-runtime:可以导入babel-plugin-transform-runtime依赖的辅助函数<br>以上二者需要配套使用<br>presents属性，告诉Babel要转换的源码使用了那些新的语法特性，其值是一组plugins数组，<br>每一项，<br>如果不需要配置参数则使用字符串，表示插件名；<br>如果需要配置参数则使用数组，数组第一项为插件名，第二项为配置项组成的对象；<br>可以分为三大类：<br>1.已经被写入ES标准的特性：ES2015,ES2016,ES2017,Env (包含当前所有ES标准里的新特性)<br>2.社区提出但还未写入ES标准的特性：stage0,stage1,stage2,stage3,stage4,分别表示被纳入es标准的进度<br>3.特定场景下的语法特性，和es标准没有关系，例如要支持JSX，则使用babel-preset-react</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;plugins&quot;:[[&quot;transform-runtime&quot;,&#123;&quot;polyfill&quot;:false&#125;]]</span><br><span class="line">	&quot;presents&quot;:[[&quot;es2015&quot;,&#123;&quot;modules&quot;:false&#125;],&quot;stage-4&quot;,&quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>Babel是转换代码功能，所以要配置相应loader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.js$/,</span><br><span class="line">    use:[&apos;babel-loader&apos;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="安装依赖模块"><a href="#安装依赖模块" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-core babel-loader //webpack配置相关依赖</span><br><span class="line">npm i -D babel-preset-env</span><br><span class="line">npm i -D babel-preset-* //配置文件中的相关依赖</span><br></pre></td></tr></table></figure>
<h1 id="使用TypeScript"><a href="#使用TypeScript" class="headerlink" title="使用TypeScript"></a>使用TypeScript</h1><h2 id="配置-tsconfig-json文件"><a href="#配置-tsconfig-json文件" class="headerlink" title="配置 tsconfig.json文件"></a>配置 tsconfig.json文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;compilerOptions&quot;:&#123;</span><br><span class="line">	&quot;module&quot;:&quot;commonjs&quot;,//编译的代码采用的模块规范</span><br><span class="line">	&quot;target&quot;:&quot;es5&quot;,//编译出的代码采用es哪个版本</span><br><span class="line">	&quot;sourceMap&quot;:true,//输出Source Map 以方便调试</span><br><span class="line">	&quot;importHelpers&quot;:true//禁止辅助函数重复出现在多个文件</span><br><span class="line">&#125;,</span><br><span class="line">&quot;exclude&quot;:[</span><br><span class="line">	&quot;node_modules&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="webpack配置-1"><a href="#webpack配置-1" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用loader做转换；修改文件查找规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">	extension:[&apos;.ts&apos;,&apos;.js&apos;]</span><br><span class="line">&#125;</span><br><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.ts$/,</span><br><span class="line">    loader:&apos;awesome-typescript-loader&apos;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安装依赖模块-1"><a href="#安装依赖模块-1" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D typescript awesome-typescript-loader</span><br></pre></td></tr></table></figure>
<h1 id="使用Flow检查器"><a href="#使用Flow检查器" class="headerlink" title="使用Flow检查器"></a>使用Flow检查器</h1><h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//@flow /*告诉检查器这个文件需要被检查*/</span><br><span class="line">function squarel(n:number):number&#123;</span><br><span class="line">	return n*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h2><p>1.全局使用<br>npm i -g flow-bin 将可执行文件安装在全局，直接在项目根目录下使用flow命令执行代码检查<br>2.局部使用<br>npm i -D flow-bin 在项目中生成可执行文件，仅在某个项目中使用，<br>在package.json中配置使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">	&quot;flow&quot;:&quot;flow&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 npm run flow 执行代码检查</p>
<h2 id="去除静态语法"><a href="#去除静态语法" class="headerlink" title="去除静态语法"></a>去除静态语法</h2><p>采用flow静态语法的js无法在引擎中运行，所要去掉<br>1.使用flow-remove-types<br>2.一般使用flow的项目会使用es6,所以集成到babel配置中，<br>安装依赖模块：npm i -D babel-preset-flow<br>修改.babelrc,在preset中加入’flow’：”presets”:[…[],”flow”]</p>
<h1 id="使用SCSS"><a href="#使用SCSS" class="headerlink" title="使用SCSS"></a>使用SCSS</h1><p>SCSS又叫做SASS，可以使用一定语法编写css样式<br>转换方式<br>1.全局单文件转换<br>全局安装node-sass:npm i -g node-sass<br>执行命令：node-sass main.scss main.css  //main.css即main.scss编译后的css文件</p>
<p>2.使用sass-loader</p>
<h2 id="webpack配置-2"><a href="#webpack配置-2" class="headerlink" title="webpack配置"></a>webpack配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.scss$/,</span><br><span class="line">    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安装依赖模块-2"><a href="#安装依赖模块-2" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><p>npm i -D style-loader css-loader sass-loader //webpack loader<br>npm i -D node-sass //sass-loader 依赖node-sass</p>
<h2 id="具体处理流程"><a href="#具体处理流程" class="headerlink" title="具体处理流程"></a>具体处理流程</h2><p>sass-loader将scss源码转换为css,再将css代码交给css-loader<br>css-loader会找出css代码中@import 和 url()这样的导入语句，告诉webpack依赖这些资源，同时支持CSS modules,压缩CSS等功能<br>处理完后将结果给到style-loader<br>style-loader 会将CSS代码转换成字符串后，注入到js代码中，通过js向DOM增加样式，<br>如果想将css提取到单独文件中，可再使用ExtractTextPlugin插件提取</p>
<h1 id="使用PostCSS"><a href="#使用PostCSS" class="headerlink" title="使用PostCSS"></a>使用PostCSS</h1><p>使用相应的loader 可以为css样式增加兼容浏览器的前缀，可以配置相应的配置文件，兼容下一代CSS语法</p>
<h2 id="配置postcss-config-js文件"><a href="#配置postcss-config-js文件" class="headerlink" title="配置postcss.config.js文件"></a>配置postcss.config.js文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	plugins:[</span><br><span class="line">		require(&apos;postcss-cssnext&apos;) //postcss-cssnext支持下一代css语法编写</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack配置-3"><a href="#webpack配置-3" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>需要先将下一代语法转换成可识别css,同时添加前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.scss$/,</span><br><span class="line">    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;postcss-loader&apos;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="安装依赖模块-3"><a href="#安装依赖模块-3" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><p>npm i -D style-loader css-loader postcss-loader //webpack loader 依赖<br>npm i -D postcss-cssnext // postcss-loader 依赖 </p>
<h1 id="使用react"><a href="#使用react" class="headerlink" title="使用react"></a>使用react</h1><h2 id="借助Bable"><a href="#借助Bable" class="headerlink" title="借助Bable"></a>借助Bable</h2><p>1.修改配置文件.babelrc，在preset中加入’react’：”presets”:[…[],”react”]<br>2.安装依赖模块<br>npm i -D react react-dom//react 基础依赖<br>npm i -D bable-preset-react //bable转换依赖</p>
<h2 id="借助typescript"><a href="#借助typescript" class="headerlink" title="借助typescript"></a>借助typescript</h2><p>1.修改配置文件tsconfig.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;compilerOptions&quot;:&#123;</span><br><span class="line">	...,</span><br><span class="line">	&quot;jsx&quot;:&quot;react&quot;//typescript本身支持jsx,开启JSX，支持react</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>2.修改webapck配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">	extension:[&apos;.ts&apos;,&apos;.tsx&apos;,.js&apos;] //typescript 原生支持jsx语法，只不过jsx语法文件后缀必须是tsx</span><br><span class="line">&#125;</span><br><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.tsx?$/,//同时匹配ts,tsx后缀文件</span><br><span class="line">    loader:&apos;awesome-typescript-loader&apos;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.安装依赖模块<br>npm i -D react react-dom//react 基础依赖<br>npm i -D @types/react @types/react-dom //react react-dom对应的ts接口描述模块，用于编译react，react-dom</p>
<h1 id="使用VUE"><a href="#使用VUE" class="headerlink" title="使用VUE"></a>使用VUE</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>1.修改webapck配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.vue$/,</span><br><span class="line">    use:[&apos;vue-loader&apos;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.安装依赖模块<br>npm i -S vue //vue框架依赖<br>npm i -D vue-loader css-loader vue-template-compiler //构建所需依赖<br>歌loader作用<br>vue-loader:解析转换.vue文件，提取其中的逻辑代码script样式代码style以及html模板template,然后交给对应的loader去处理<br>css-loader:加载vue-loader提取的CSS代码<br>vue-template-compiler：将vue-loader提取的HTML模板编译成对应可执行的js代码。</p>
<h2 id="构建使用ts编写的vue"><a href="#构建使用ts编写的vue" class="headerlink" title="构建使用ts编写的vue"></a>构建使用ts编写的vue</h2><p>1.配置 tsconfig.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;compilerOptions&quot;:&#123;</span><br><span class="line">	&quot;target&quot;:&quot;es5&quot;,//构建es5版本的js,与VUE浏览器支持保持一致</span><br><span class="line">	&quot;module&quot;:&apos;es015&apos;,//使用es2015模块化格式</span><br><span class="line">	&quot;strict&quot;:true,//开启严格模式，对this上数据属性进行严格推断</span><br><span class="line">	&quot;moduleResolution&quot;:&apos;node&apos;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>2.webpack配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">	extension:[&apos;.ts&apos;,&apos;.js&apos;,&apos;.vue&apos;,&apos;json&apos;] //增加对.ts，.vue文件支持</span><br><span class="line">modules:&#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">    test:/\.ts$/,//匹配ts后缀文件</span><br><span class="line">    loader:&apos;ts-loader&apos;,</span><br><span class="line">    exclude:/node_modules/,</span><br><span class="line">    options:&#123;</span><br><span class="line">    	appendTsSuffixTo:[/\.vue$/] //让tsc将vue文件当成一个ts模块去处理，以解决module not found的问题，tsc本身不会处理.vue结尾文件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.新增文件vue-shims.d.ts<br>用以ts支持.vue结尾文件，可识别import 语句导入的.vue文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;*.vue&quot;&#123;</span><br><span class="line">	import Vue from &quot;vue&quot;;</span><br><span class="line">	export default Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.vue文件编写<br>script 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&apos;ts&apos;&gt;//lang指明代码语法为ts</span><br><span class="line">improt Vue from &quot;vue&quot;</span><br><span class="line">export default Vue.extend(&#123; //Vue.extend启用ts类型推断</span><br><span class="line">	data()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			msg:&apos;hello world&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script</span><br></pre></td></tr></table></figure></p>
<p>5.安装依赖<br>npm i -D ts-loader typescript</p>
<h1 id="单页自动生成html"><a href="#单页自动生成html" class="headerlink" title="单页自动生成html"></a>单页自动生成html</h1><p>利用模板文件和插件生成</p>
<h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><p>模板文件用于描述哪些资源需要被以某种方式加入到输出的HTML文件中<br>资源链接URL字符串里问号前面的部分表示资源内容来自哪里，后面的参数表示这些资源注入的方式,可用&amp;链接<br>_inline:资源是要引入动态资源<br>_dist:只在生产环境下才引入该资源<br>_dev:只在开发环境才引入该资源<br>_ie:只在IE浏览器中引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">     &lt;!--导入chunck app 中的css代码，可知要将css单独打包一个文件--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;app?_inline&quot;&gt;</span><br><span class="line">    &lt;!--在这里引入/google_analytics的js代码--&gt;</span><br><span class="line">    &lt;script src=&quot;./google_analytics.js?_inline&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&apos;app&apos;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!--导入chunck app 中的js代码--&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;app&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="webpack配置-4"><a href="#webpack配置-4" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用web-webpack-plugin的webplugin自动生成index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</span><br><span class="line">plugins:[</span><br><span class="line">	new WebPlugin(&#123;//自动生成index.html文件</span><br><span class="line">		template:&apos;./template.html&apos;,//模板文件</span><br><span class="line">		filename:&apos;index.html&apos;//输出文件名</span><br><span class="line">	&#125;)，</span><br><span class="line">	new ExtractTextPlugin(&#123;</span><br><span class="line">		filename:`[name]_[contenthas:8].css` // 为输出的css文件名称加上Hash值</span><br><span class="line">	&#125;)，</span><br><span class="line">	new DefinePlugin(&#123;</span><br><span class="line">		&apos;process.env&apos;:&#123;//定义NODE_ENV环境变量为production，去除源码中只有开发时才需要的部分</span><br><span class="line">			NODE_ENV:JSON.stringify(&apos;production&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)，</span><br><span class="line">	new UglifyJsPlugin(&#123;//压缩输出的js代码</span><br><span class="line">		beautify:false,//最紧凑的输出</span><br><span class="line">		comments:false,//删除所有注释</span><br><span class="line">		compress:&#123;</span><br><span class="line">			warnings:false,//删除没有用到的代码时，不发出警告</span><br><span class="line">			drop_console:true,//删除所有console语句，兼容IE</span><br><span class="line">			collapse_vars:true,//内嵌已定义但只用到了一次的变量</span><br><span class="line">			reduce_vars:true//提取出出现多次但没有定义成变量去引用的静态值</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h1 id="自动生成多个单页"><a href="#自动生成多个单页" class="headerlink" title="自动生成多个单页"></a>自动生成多个单页</h1><p>需要解决的问题<br>1.要能够将公共代码提取出来，并能够注入到每个单页应用中<br>2.模板文件要支持注入公共文件和各个单页独自依赖的资源</p>
<h2 id="模板文件-1"><a href="#模板文件-1" class="headerlink" title="模板文件"></a>模板文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;!--在这里注入该页面所依赖但没有手动导入的CSS--&gt;</span><br><span class="line">    &lt;!--STYLE--&gt;</span><br><span class="line">    &lt;!--在这里引入/google_analytics的js代码--&gt;</span><br><span class="line">    &lt;script src=&quot;./google_analytics.js?_inline&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&apos;app&apos;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 在这里注入该页面所依赖但没有手动导入的JS--&gt;</span><br><span class="line">    &lt;!--SCRIPT--&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此时模板文件被当作项目中所有单页的模板，因此不能直接写Chunck名称去引入资源，<br>因为需要被注入当前页面的Chunck名称不固定，每个单页都会有自己的名称<br><!--STYLE--><!--SCRIPT-->的作用在于保证该页面所依赖的资源都会被注入生成的HTML模板中<br>如果<!--STYLE-->不存在，就注入到head标签最后<br>如果<!--SCRIPT-->不存在，就注入到body标签最后</p>
<h2 id="webpack配置-5"><a href="#webpack配置-5" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用web-webpack-plugin的autoWebPlugin自动生成多个单页的index.html文件<br>但是对目录结构有要求，即所有单页各自的入口文件和依赖资源组成各自的一个文件夹，<br>多个文件夹放在同一目录A下，其他公共资源以及模板文件，webpack配置文件放在与A目录同级目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const &#123;AutoWebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</span><br><span class="line">const autoWebPlugin = new AutoWebPlugin(&apos;pages&apos;,&#123; //pages 为各个单页的父目录A</span><br><span class="line">	template:&apos;./template.html&apos;,//模板文件</span><br><span class="line">	postEntry:[&apos;./common.css&apos;],//所有页面都依赖这份通用的CSS样式文件</span><br><span class="line">	commonChunk：&#123;</span><br><span class="line">		name:&apos;common&apos;,//提取公共代码chunk的名称</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">module.exports=&#123;</span><br><span class="line">	//AutoWebPlugin会为寻找到的所有单页生成对应的入口配置，</span><br><span class="line">	//autoWebPlugin.entry可以获取所有由autoWebPlugin生成的入口配置</span><br><span class="line">	entry:autoWebPlugin.entry(&#123;//可加入额外需要的Chunk入口&#125;)，</span><br><span class="line">	plugins:[autoWebPlugin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="构建基于react的同构应用"><a href="#构建基于react的同构应用" class="headerlink" title="构建基于react的同构应用"></a>构建基于react的同构应用</h1><p>同构应用：写一份代码可同时在浏览器和服务器中运行的应用<br>能在服务器运行的原理核心是虚拟DOM<br>虚拟DOM好处：<br>1.操作DOM树是高耗时操作，可通过DOM diff算法找到两个不同Object的最小差异，得出最小的DOM操作<br>2.虚拟DOM在渲染时不仅可以通过操作DOM树表示结果，也可以有其他表示方式，例如将虚拟DOM渲染成字符串(服务器渲染)<br>或者渲染成手机APP原生UI组件（react Native）</p>
<h2 id="服务器端构建配置"><a href="#服务器端构建配置" class="headerlink" title="服务器端构建配置"></a>服务器端构建配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const nodeExternals = require(&apos;webpack-node-externals&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	entry:&apos;./main_server.js&apos;</span><br><span class="line">	target:&apos;node&apos;,//目标运行环境是node.js,源码依赖的nodejs原生模块没必要打包进去</span><br><span class="line">	externals:[nodeExternals()],//不打包node_modules中的第三方组件</span><br><span class="line">	output:&#123;</span><br><span class="line">		libraryTarget:&apos;commonjs2&apos;,//输出CommonJS2规范，供nodejs的http服务器代码调用</span><br><span class="line">		fillname:&apos;bundle.server.js&apos;,</span><br><span class="line">		path:path(resolve(__dirname,&apos;./dist&apos;))</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.js$/,</span><br><span class="line">				use:[&apos;babel-loader&apos;],</span><br><span class="line">				exclude:path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.css/,</span><br><span class="line">				use:[&apos;ignore-loader&apos;],//css文件不能打包到服务端代码，影响服务端渲染性能</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h2><p>一个仅包含根组件代码，不能包含渲染入口代码，而且需要导出根组件以供渲染入口调用的文件 rootComponent.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import react,&#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &apos;main.css&apos;</span><br><span class="line">export class RootComponent extends Component&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return &lt;h1&gt;hello world &lt;/h1&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不同环境渲染入口文件，一个环境一个<br>main_server.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import react from &apos;react&apos;;</span><br><span class="line">import RootComponent from &apos;./rootComponent&apos;</span><br><span class="line">import &#123;renderToString&#125; from &apos;react-dom/server&apos; //计算表示虚拟DOM的HTML形式字符串</span><br><span class="line">export function render()&#123;</span><br><span class="line">	return renderToString(&lt;RootComponent&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main_browser.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import react from &apos;react&apos;;</span><br><span class="line">import RootComponent from &apos;./rootComponent&apos;</span><br><span class="line">import &#123;render&#125; from &apos;react-dom&apos; //操作浏览器DOM树展示出结果</span><br><span class="line">render(&lt;RootComponent&gt;,window.document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure></p>
<p>http.server.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const &#123;render &#125; = require(&apos;./dist/bundle_server&apos;)</span><br><span class="line">const app = express();</span><br><span class="line">app.get(&apos;/&apos;,function(req.res)&#123;</span><br><span class="line">	res.send(`</span><br><span class="line">		&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">		  &lt;head&gt;</span><br><span class="line">		    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		  &lt;/head&gt;</span><br><span class="line">		  &lt;body&gt;</span><br><span class="line">		    &lt;div id=&apos;app&apos;&gt;$&#123;render()&#125;&lt;/div&gt;</span><br><span class="line">		    &lt;!--导入WEBPACK输出的用于浏览器端渲染的js文件--&gt;</span><br><span class="line">		    &lt;script src=&apos;./dist/bundle_browser.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">		  &lt;/body&gt;</span><br><span class="line">		&lt;/html&gt; </span><br><span class="line">	`)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(&apos;.&apos;));</span><br><span class="line">app.listen(3000,function()&#123;</span><br><span class="line">	console.log(&apos;app is listening 3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>webpack –config webpac_server.config.js 得到./dist/bundle_server.js<br>webpack –config webpac.config.js 得到./dist/bundle_browser.js<br>node ./http_server.js 启动 http 服务器，访问’localhost:3000’看到服务器返回了html</p>
<h1 id="基于react-的Electron应用"><a href="#基于react-的Electron应用" class="headerlink" title="基于react 的Electron应用"></a>基于react 的Electron应用</h1><p> Electron 可以使用开发web应用的技术去开发跨平台的桌面应用，例如Atom，VSCode<br> 是nodejs和Chromium浏览器的结合体，用Chromium浏览器显示出的WEB页面作为应用的GUI，通过Nodejs和操作系统交互<br> 当操作一个Electron应用的一个窗口时，实际是在操作一个网页，当操作需要操作系统完成时，网页会通过Nodejs和操作系统交互<br> 优点<br> 1.降低了开发门槛，只需掌握网页开发技术和Nodejs,大量Web开发技术和现成库可以复用于Electron<br>   而且由于Electron环境内置了浏览器和Nodejs的API，在开发网页时除了可以使用浏览器提供的API，还可以会用Nodejs的API<br> 2.由于Chromium浏览器和Nodejs都是跨平台的，所有Electron能做到在不同操作系统运行一份代码</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>Electron 应用每个窗口对应一个网页，所以相当于需要构建多单页面应用<br>在网页JS代码中可能会调用Nodejs原生模块或者Electron模块，输出的代码依赖这些模块但由于这些模块都是内置支持的，<br>所有构建出的代码不能将这些模块打包进去<br>由于webpack内置了对Electron的支持，只需要告诉webpack我要在electron环境里运行就可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target:&apos;electron-renderer&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>安装electron执行环境到项目中<br>npm i -D electron</p>
<p>在项目目录下执行electron ./就可以启动桌面应用</p>
<h1 id="构建Npm模块"><a href="#构建Npm模块" class="headerlink" title="构建Npm模块"></a>构建Npm模块</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>1.源码若采用es6编写需要转换成es5,并且要遵守commonjs规范，同时提供Source Map方便调式</p>
<p>解决:<br>使用Babel将es6转换成es5<br>通过开启devtool:’source-map’输出Source Map以发布调试<br>设置output.libraryTarget = ‘commonjs2’ 实现输出代码符合CommomJS2规范<br>2.若为UI组件，则依赖的其他资源文件如css文件也需要包含的发布的模块中</p>
<p>解决：通过css-loader,extract-text-webpack-plugin实现，将css打包到单独文件</p>
<p>3.尽量减少代码冗余，（例如，Babel将es6转换成es5时，会注入一些辅助函数，例如实现class,extend语法的辅助函数，Babel会在每个输出文件中中内嵌依赖的辅助函数，多文件依赖的话，就会造成辅助函数重复出现，造成代码冗余）减少发布出去的组件的代码文件大小</p>
<p>解决：通过引入相同函数解决重复代码<br>使用babel-plugin-transform-runtime 将嵌入辅助函数代码转成引入辅助函数<br>引入bable-runtime模块用于提供辅助函数</p>
<p>4.发布出去的组件代码中不能含有其依赖的模块代码，例如react,babel-runtime,而是让用户可选择性的安装，否则可能在其他模块也依赖相同模块时，造成重复打包</p>
<p>解决：配置externals将外部环境提供的模块屏蔽掉，不进行打包</p>
<h2 id="webpack配置-6"><a href="#webpack配置-6" class="headerlink" title="webpack配置"></a>webpack配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	entry:&apos;./src/index.js&apos;</span><br><span class="line">	output:&#123;</span><br><span class="line">		fillname:&apos;index.js&apos;,</span><br><span class="line">		path:path.resolve(__dirname,&apos;lib&apos;),</span><br><span class="line">		libraryTarget:&apos;commonjs2&apos;,</span><br><span class="line">	&#125;,</span><br><span class="line">	externals:/^(react|babel-runtime)/,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			use:[&apos;babel-loader&apos;],</span><br><span class="line">			exclude:path.resolve(__dirname,&apos;node_module&apos;),</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.css/,</span><br><span class="line">			use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">				use:[&apos;css-loader&apos;]</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		new ExtractTextPlugin(&#123;</span><br><span class="line">			fillname:&apos;index.css&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">	devtool:&apos;source-map&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.babellrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&apos;plugins&apos;:[</span><br><span class="line">		[</span><br><span class="line">			&apos;transform-runtime&apos;,//默认自动注入ES6 API的polyfill</span><br><span class="line">			&#123;</span><br><span class="line">				&apos;polyfill&apos;:false//防止使用者在其他地方注入其他polyfill库，所以关闭注入polyfill功能</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="发布到Npm"><a href="#发布到Npm" class="headerlink" title="发布到Npm"></a>发布到Npm</h2><p>修改package.json入口文件为打包后的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main:&apos;lib/index.js&apos;,//webpack使用于构建不可分割的NPM模块，不能保持同源码结构一致例如如果打包lodash，会将所有工具函数打包进去，不适合仅用几个工具函数的场景</span><br><span class="line">&apos;jsnext:main&apos;:&apos;src/index.js&apos;//指出采用ES6编写的模块入口文件位置，便于实现Tree Sharking</span><br></pre></td></tr></table></figure></p>
<h1 id="离线应用-service-workers打包"><a href="#离线应用-service-workers打包" class="headerlink" title="离线应用 service workers打包"></a>离线应用 service workers打包</h1><p><a href="/post/performance/cache/serviceworker.html">service workers了解</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.如何生成sw.js文件<br>2.sw.js文件中的cacheFileList变量(代表被缓存文件的URL)，需要根据输出文件列表所对应的URL来决定，不能写成静态值</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用serviceworker-webpack-plugin,根据自定义sw.js生成含有输出文件列表的sw.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</span><br><span class="line">const ServiceWorkerWebpackPlugin = require(&apos;serviceworker-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app:&apos;./main.js&apos; //Chunk app 的js执行入口文件</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		fillname:&apos;[name].js&apos;,</span><br><span class="line">		publicPath:&apos;&apos;,</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.css/,//增加对CSS文件支持，</span><br><span class="line">			use:ExtractTextPlugin.extract(&#123;//提取到单独文件</span><br><span class="line">				use:[&apos;css-loader&apos;]//压缩CSS代码</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		//一个WebPlugin对应一个HTML</span><br><span class="line">	    new WebPlugin(&#123;</span><br><span class="line">	    	template:&apos;./template/html&apos;,//HTML模板文件所在的文件路径</span><br><span class="line">	    	fillname:&apos;index.html&apos;//输出的HTML文件名称</span><br><span class="line">	    &#125;),</span><br><span class="line">		new ExtractTextPlugin(&#123;</span><br><span class="line">			fillname:&apos;[name].css&apos;</span><br><span class="line">		&#125;),</span><br><span class="line">		new ServiceWorkerWebpackPlugin(&#123;</span><br><span class="line">			//自定义的sw.js文件所在路径</span><br><span class="line">			//ServiceWorkerWebpackPlugin会将文件列表注入生成的sw.js</span><br><span class="line">			entry:path.join(__dirname,&apos;sw.js&apos;)</span><br><span class="line">		&#125;)</span><br><span class="line">	],</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		//Service workers依赖HTTPs,使用devServer提供https功能</span><br><span class="line">		https:true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构建出的sw.js文件会在头部注入一个变量serviceWorkerOption.assets到全局，里面存放着所有需要被缓存的文件的URL列表<br>因此需要将sw.js文件中写成静态值的cacheFileList替换成serviceWorkerOption.assets<br>var cacheFileList = global.serviceWorkerOption.assets</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm -i -D web-webpack-plugin serviceworker-webpack-plugin</p>
<h1 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			exclude:/node_module/,//不检查node_module下文件</span><br><span class="line">			loader:&apos;tslint-loader&apos;,//整合typeScript代码检查</span><br><span class="line">			enforce:&apos;pre&apos;//将执行顺序放到最前面，防止其他Loader将处理后的代码交给tslint-loader检查</span><br><span class="line">		&#125;，&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			exclude:/node_module/,//不检查node_module下文件</span><br><span class="line">			loader:&apos;eslint-loader&apos;,//整合eslint检查代码</span><br><span class="line">			enforce:&apos;pre&apos;//将执行顺序放到最前面，防止其他Loader将处理后的代码交给tslint-loader检查</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;，</span><br><span class="line">	plugin:[</span><br><span class="line">		new StyleLintPlugin() //整合stylelint，检查css代码，可以解析SCSS,Less</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导致问题"><a href="#导致问题" class="headerlink" title="导致问题"></a>导致问题</h2><p>1.执行检查步骤计算量大，或导致webpack构建变慢<br>2.整合代码检查到webpack后，输出的错误信息是通过行号来定位错误的，没有编辑器集成显示错误直观</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>1.将代码检查步骤当道代码提交时，即在代码提交前调用以上检查工具去检查代码，只有检查都通过时才提交代码，这样保证仓库内代码都经过检查<br>2.使用集成了代码检查功能的编辑器，让编辑器实时，直观的显示错误<br>安装 npm i -D husky 接入git hook,通过git 的hook功能做到在提交代码前触发执行，husky会通过Npm Script Hook自动配置好HOOK<br>但需要在package.json定义脚本，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;:&#123;</span><br><span class="line">		&quot;precommit&quot;:&quot;npm run lint&quot;,//git commit 前执行的脚本</span><br><span class="line">		&quot;prepush&quot;:&apos;lint&apos;,//git push前会执行的脚本</span><br><span class="line">		&quot;lint&quot;:&apos;eslint &amp;&amp; stylelint&apos;//调用eslint,stylelint检查工具</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="在nodejs中使用"><a href="#在nodejs中使用" class="headerlink" title="在nodejs中使用"></a>在nodejs中使用</h1><p>通过调用Webpack的API，执行构建</p>
<h2 id="一次构建"><a href="#一次构建" class="headerlink" title="一次构建"></a>一次构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">//import webpack from &apos;webpack&apos;</span><br><span class="line"></span><br><span class="line">1.使用模块方式一</span><br><span class="line">webpack(&#123;</span><br><span class="line">	//webpack配置，和webpack.config.js一样</span><br><span class="line">&#125;,(err,stats)=&gt;&#123;</span><br><span class="line">	if(err || stats.hasErrors())&#123;</span><br><span class="line">		//构建过程出错</span><br><span class="line">	&#125;</span><br><span class="line">	//成功执行完构建</span><br><span class="line">&#125;)</span><br><span class="line">2.使用模块方式二</span><br><span class="line">const config = require(&apos;./webpack.config.js&apos;)</span><br><span class="line">webpack(config,callback)</span><br></pre></td></tr></table></figure>
<h2 id="启动监听模式"><a href="#启动监听模式" class="headerlink" title="启动监听模式"></a>启动监听模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//不给webpack传递callback就会返回compiler实例，用于控制启动，而不是像上面那样立即启动</span><br><span class="line">const compiler = webpack(config)</span><br><span class="line">//调用compiler.watch并以监听模式启动，返回watching用于关闭监听</span><br><span class="line">const watching = compiler.watch(&#123;</span><br><span class="line">	//watchOptions</span><br><span class="line">	aggregateTimeout:300</span><br><span class="line">&#125;,(err,stats)=&gt;&#123;</span><br><span class="line">	//每次因文件发生变化而重新执行完/构建后</span><br><span class="line">&#125;)</span><br><span class="line">//调用watching.close关闭监听</span><br><span class="line">watching.close(()=&gt;&#123;</span><br><span class="line">	//在监听关闭后</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="加载图片相关的loader"><a href="#加载图片相关的loader" class="headerlink" title="加载图片相关的loader"></a>加载图片相关的loader</h2><p>1.file-loader<br>将js和CSS中导入图片的地址替换成 webpack输出文件的地址，输出文件名是根据内容计算出的HASH值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">	test:/\.png$/,</span><br><span class="line">	use:[&apos;fill-loader&apos;]</span><br><span class="line">	&#125;]</span><br></pre></td></tr></table></figure></p>
<p>2.url-loder<br>将图片转base64直接注入到引入的地方，<br>一般利用url-loder将网页需要用到的小图片资源注入代码中，以减少加载次数，为一个很小图片而2新建一次HTTP连接不划算<br>如果图片体积太大会导致js,CSS文件过大而带来网页加载缓慢的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">	test:&apos;/\./png$/&apos;,</span><br><span class="line">	use:[&#123;</span><br><span class="line">		loader:&apos;url-loader&apos;,</span><br><span class="line">		options:&#123;</span><br><span class="line">			//30KB以下文件采用url-loader,控制文件大小</span><br><span class="line">			limit:1024*30,</span><br><span class="line">			//否则采用file-loader,默认值是file-loader</span><br><span class="line">			fallback:&apos;file-loader&apos;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;]</span><br></pre></td></tr></table></figure></p>
<p>还可以以下方式优化，同样适用于其他二进制类型的资源，如PDF,SWF<br>A.通过imagin-webpack-plugin压缩图片<br>B.通过webpack-spritesmith插件制作雪碧图</p>
<p>以上两个loader都可用于处理svg图片，但svg文件是文本格式文件，还有其他方法</p>
<p>3.raw-loader<br>可以将文本文件内容读取出来，注入js/CSS中<br>由于会直接返回svg的文本内容，并且无法通过CSS展示SVG的文本内容，因此采用该loader后无法在CSS中导入SVG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">	test:/\./svg$/,</span><br><span class="line">	use:&apos;raw-loader&apos;</span><br><span class="line">	&#125;]</span><br></pre></td></tr></table></figure></p>
<p>4.svg-inline-loader<br>类似raw-loader，但会分析SVG内容，去除其中不必要的部分代码，以减少SVG文件大小，相当于增加了对SVG的压缩能力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">	test:/\.svg$/,</span><br><span class="line">	use:[&apos;svg-inline-loader&apos;]</span><br><span class="line">	&#125;]</span><br></pre></td></tr></table></figure></p>
<h2 id="DevServer-实现"><a href="#DevServer-实现" class="headerlink" title="DevServer 实现"></a>DevServer 实现</h2><p>webpack-dev-server本身基于webpack-dev-middleware和expressjs,而webpack-dev-middleware是一个express.js的中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const wepack = require(&apos;webpack&apos;)</span><br><span class="line">const webpackMiddleware = require(&apos;webpack-dev-middleware&apos;)</span><br><span class="line"></span><br><span class="line">const config = require(&apos;./webpack.config.js&apos;)</span><br><span class="line">const app = expree()</span><br><span class="line">const compiler = webpack(config)</span><br><span class="line">app.use(webpackMiddleware(compiler,&#123;</span><br><span class="line">	//在webpack-dev-middleware支持的所有配置项中</span><br><span class="line">	//只有publicPath属性为必填项，其他都是选填项</span><br><span class="line"></span><br><span class="line">	//webpack输出资源绑定HTTP服务器上的根目录</span><br><span class="line">	//同WEBPACK配置中的publicPath</span><br><span class="line">	publicPath:&apos;/assets/&apos;,</span><br><span class="line"></span><br><span class="line">	//不输出info类型的日志到控制台，只输出warn和error类型的日志</span><br><span class="line">	noInfo:false,</span><br><span class="line">	//不输出任何类型的日志到控制台</span><br><span class="line">	quiet:false,</span><br><span class="line">	//切换到懒惰模式，意味着不监听文件的变化，只会在有请求时再编译对应的文件，适合页面很多的项目</span><br><span class="line">	lazy:true,</span><br><span class="line">	//watchOptions,只在非懒惰模式下才有效</span><br><span class="line">	watchOptions:&#123;</span><br><span class="line">		aggregationTimeout:300,</span><br><span class="line">		poll:true</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	//默认的URL路径，默认是&apos;index.html&apos;</span><br><span class="line">	index:&apos;index.html&apos;,</span><br><span class="line">	//自定义HTTP头</span><br><span class="line">	headers:&#123;&apos;X-Custom-Header&apos;:&apos;yes&apos;&#125;,</span><br><span class="line">	//为特定后缀的文件添加HTTP mimeTypes,作为文件类型映射表</span><br><span class="line">	mimeTypes:&#123;&apos;text/html&apos;:[&apos;phtml&apos;]&#125;,</span><br><span class="line"></span><br><span class="line">	//统计信息输出样式</span><br><span class="line">	stats:&#123;</span><br><span class="line">		colors:true</span><br><span class="line">	&#125;,</span><br><span class="line">	//自定义输出日志的展示方法</span><br><span class="line">	reporter:null,</span><br><span class="line">	//开启或关闭服务端渲染</span><br><span class="line">	serverSideRender:false</span><br><span class="line"></span><br><span class="line">&#125;))</span><br><span class="line">//webpackMiddleware函数返回一个Expressjs中间件，该中间件有俩个功能</span><br><span class="line">//1.接收来自webpack compiler实例输出的文件，但不会将文件输出到硬盘中，而会保存在内存中</span><br><span class="line">//2.在express.js上注册路由，拦截HTTP收到的请求，根据请求路径响应对应文件内容</span><br><span class="line"></span><br><span class="line">//webpack-dev-middleware没有模块热替换功能，但Devserver有，</span><br><span class="line">//可通过webpack-hot-middleware中间件来支持模块热替换，响应用于替换老模块的资源</span><br><span class="line">app.use(require(&apos;webpack-hot-middleware&apos;)(compiler))</span><br><span class="line">//将项目根目录作为静态资源目录，用于服务器HTML文件</span><br><span class="line">app.use(express.static(&apos;.&apos;))</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<p>响应模块热替换功能还需要作如下配置<br>1.修改webpack.config.js文件，加入HotModuleReplacementPlugin插件<br>  相当于执行 webpack-dev-server –hot工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HotModuleReplacementPlugin= require(&apos;webpack/lib/HotModuleReplacementPlugin&apos;)</span><br><span class="line">module.exports=&#123;</span><br><span class="line">	entry:[</span><br><span class="line">		&apos;webpack-hot-middleware/client&apos;,//为了支持模块热替换注入代理客户端</span><br><span class="line">		&apos;./src/main.js&apos;</span><br><span class="line">	],</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&apos;bundle.js&apos;</span><br><span class="line">	&#125;,</span><br><span class="line">	plugin:[</span><br><span class="line">		//为了支持模块热替换，生成.hot-update.json文件</span><br><span class="line">		new HotModuleReplacementPlugin(),</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.修改入口文件main.js,加入替换逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在文件末尾加入</span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">	moudule.hot.accept()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.安装以上配置中用到的依赖<br>npm i -D webpack-dev-middleware webpack-hot-middleware express</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/reactNativeKnowledge.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/reactNativeKnowledge.html" itemprop="url">
                  react Native 基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-05T22:50:37+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h1><p>Text:用来显示文本<br>View:相当于div或者span这样的容器，常用作其他组件的容器，来帮助控制布局和样式<br>Image:显示图片，属性source指定图片地址，也可以使用style属性控制尺寸</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>props:子组件通过this.props拿到父组件使用子组件时传递进来的属性值<br>state:自定义组件控制内部逻辑的变量，同react的state,在constructor里面初始化<br>StyleSheet:使用StyleSheet.create()创建样式，相当于style标签,不过使用时在style中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry, StyleSheet, Text, View &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class LotsOfStyles extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  bigBlue: &#123;</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    fontSize: 30,</span><br><span class="line">  &#125;,</span><br><span class="line">  red: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在style属性中可以直接写驼峰式CSS属性进行样式调整<br>但设置width和height是不带单位的，React Native 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p>相当于span,但可以被’\n’换行<br>用作子元素时，<br>如果父元素为Text时，多个Text子元素尽可能放一行，一行装不下时，自动换行，子元素Text标签会继承父元素Text一部分样式<br>如果父元素为View时，每个Text子元素成为flex布局的一个块，当容器不够宽时，每个块自动换行，块与块之间不影响<br>必须把文本放在Text组件中，不能直接放在View中</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>selectable:是否可以长按选择文本，以便复制和粘贴<br>selectionColor[Andorid]：选中时高亮颜色<br>suppressHighlighting[IOS]：设为true时，当文本被按下会没有任何视觉效果。默认情况下，文本被按下时会有一个灰色的、椭圆形的高光<br>ellipsizeMode:表示当 Text 组件无法全部显示需要显示的字符串时如何用省略号进行修饰<br>————head ： 从文本内容头部截取显示省略号。例如： “…efg”<br>————middle ： 在文本内容中间截取显示省略号。例如： “ab…yz”<br>————tail ： 从文本内容尾部截取显示省略号。例如： “abcd…”<br>————clip ： 不显示省略号，直接从尾部截断。<br>numberOfLines:文本过长时，最多折叠多少行，执行ellipsizeMode设置的效果<br>onLayout：加载时或者布局变化以后调用，参数为：{nativeEvent: {layout: {x, y, width, height}}}<br>onLongPress：当文本被长按以后调用此回调函数<br>onPress：当文本被点击以后调用此回调函数。<br>llowFontScaling：制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。</p>
<h1 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h1><p>有些属性仅在multiline为true或者为false的时候有效，例如当multiline=false时，为元素的某一个边添加边框样式（例如：borderBottomColor，borderLeftWidth等）将不会生效<br>在安卓上长按选择文本会导致windowSoftInputMode设置变为adjustResize，这样可能导致绝对定位的元素被键盘给顶起来。要解决这一问题你需要在AndroidManifest.xml中明确指定合适的windowSoftInputMode( <a href="https://developer.android.com/guide/topics/manifest/activity-element.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/manifest/activity-element.html</a> )值，或是自己监听事件来处理布局变化。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>placeholder：同input<br>maxLength:限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。<br>multiline:如果为true，文本框中可以输入多行文字。默认值为false。注意安卓上如果设置multiline = {true}，文本默认会垂直居中，可设置textAlignVertical: ‘top’样式来使其居顶显示<br>numberOfLines:设置输入框的行数<br>allowFontScaling:控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。<br>autoCapitalize:控制TextInput是否要自动将特定字符切换为大写<br>————characters: 所有的字符。<br>————words: 每个单词的第一个字符。<br>————sentences: 每句话的第一个字符（默认）。<br>————none: 不切换。<br>autoCorrect：如果为false，会关闭拼写自动修正。默认值是true<br>autoFocus：如果为true，在componentDidMount后会获得焦点。默认值为false。<br>blurOnSubmit：如果为true，文本框会在提交的时候失焦。对于单行输入框默认值为true，多行则为false。注意：对于多行输入框来说，如果将blurOnSubmit设为true，则在按下回车键时就会失去焦点同时触发onSubmitEditing事件，而不会换行。<br>caretHidden：如果为true，则隐藏光标。默认值为false。<br>clearButtonMode：是否要在文本框右侧显示“清除”按钮。仅在单行模式下可用。默认值为never。<br>clearTextOnFocus：如果为true，每次开始输入的时候都会清除文本框的内容。<br>defaultValue：<br>提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。<br>editable：如果为false，文本框是不可编辑的。默认值为true<br>enablesReturnKeyAutomatically：如果为true，键盘会在文本框内没有文字的时候禁用确认按钮。默认值为false。<br>inlineImageLeft：指定一个图片放置在左侧。图片必须放置在/android/app/src/main/res/drawable目录下，经过编译后按如下形式引用（无路径无后缀）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextInput</span><br><span class="line"> inlineImageLeft=&apos;search_icon&apos;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<p>inlineImagePadding:给放置在左侧的图片设置padding样式。<br>keyboardAppearance:指定键盘的颜色。<br>keyboardType:决定弹出何种软键盘类型</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>onBlur：当文本框失去焦点的时候调用此回调函数。<br>onChange：当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }<br>onChangeText：当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。<br>onEndEditing：当文本输入结束后调用此回调函数。<br>onKeyPress：当一个键被按下的时候调用此回调。传递给回调函数的参数为{ nativeEvent: { key: keyValue } }，其中keyValue即为被按下的键。会在onChange之前调用。注意：在Android上只有软键盘会触发此事件，物理键盘不会触发。<br>onSubmitEditing：此回调函数当软键盘的确定/提交按钮被按下的时候调用此函数。如果multiline={true}，此属性不可用。</p>
<h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><p>样式单一，可能不适合统一UI样式</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>title:按钮名<br>color：文本的颜色(iOS)，或是按钮的背景色(Android)<br>disabled：禁用</p>
<h2 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h2><p>onPress:点击触发</p>
<h2 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h2><p>用来封装可以点击的元素，来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。<br>使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低，同时会有一个底层的颜色透过而被用户看到，使得视图变暗或变亮<br>只支持一个子节点（不能没有子节点也不能多于一个）。如果你希望包含多个子组件，可以用一个View来包装它们</p>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><p>activeOpacity：指定封装的视图在被触摸操作激活时以多少不透明度显示（0到1之间，默认值为0.85）。需要设置underlayColor。<br>underlayColor：有触摸操作时显示出来的底层的颜色。</p>
<h3 id="响应-2"><a href="#响应-2" class="headerlink" title="响应"></a>响应</h3><p>onHideUnderlay：底层的颜色被隐藏的时候调用。<br>onShowUnderlay：当底层的颜色被显示的时候调用。</p>
<h2 id="TouchableNativeFeedback"><a href="#TouchableNativeFeedback" class="headerlink" title="TouchableNativeFeedback"></a>TouchableNativeFeedback</h2><p>用来封装可以点击的元素，在用户手指按下时形成类似墨水涟漪的视觉效果<br>它只支持一个单独的View实例作为子节点</p>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><p>background：决定在触摸反馈的时候显示什么类型的背景,它接受一个有着type属性和一些基于type属性的额外数据的对象。<br>一般用本组件的几个静态方法来创建这个对象<br>——————SelectableBackground()：创建一个对象，表示安卓主题默认的对于被选中对象的背景<br>——————SelectableBackgroundBorderless()：创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景<br>——————Ripple(color: string, borderless: boolean)：创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外</p>
<h1 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h1><p>一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的,适合用来显示数量不多的滚动元素</p>
<h2 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h2><p>horizontal：为true时，元素水平排列，默认false，垂直排列<br>scrollsToTop：当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true<br>indicatorStyle：设置滚动条的样式。默认default 同black,’white’白色滚动条<br>overScrollMode：覆盖默认的overScroll模式<br>——————‘auto’ ： 默认值，允许用户在内容超出视图高度之后可以滚动视图。<br>——————‘always’ ： 无论内容尺寸，用户始终可以滚动视图。<br>——————‘never’ ： 始终不允许用户滚动视图。<br>stickyHeaderIndices：一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。举个例子，传递stickyHeaderIndices={[0]}会让第一个成员固定在滚动视图顶端。这个属性不能和horizontal={true}一起使用。<br>scrollEnabled：当值为false的时候，内容不能滚动，默认值为true。注意即便禁止用户滚动，你也仍然可以调用scrollTo来滚动。<br>showsHorizontalScrollIndicator：为true的时候，显示一个水平方向的滚动条。<br>showsVerticalScrollIndicator：为true的时候，显示一个垂直方向的滚动条<br>refreshControl：用于为ScrollView提供下拉刷新功能。只能用于垂直视图，即horizontal不能为true。<br>pagingEnabled：当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。注意：垂直分页在Android上不支持。</p>
<h2 id="响应-3"><a href="#响应-3" class="headerlink" title="响应"></a>响应</h2><p>onScrollBeginDrag：当用户开始拖动此视图时调用此函数<br>onScrollEndDrag：当用户停止拖动此视图时调用此函数。<br>onScroll：在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。<br>onMomentumScrollBegin:滚动动画开始时调用此函数。<br>onMomentumScrollEnd：滚动动画结束时调用此函数<br>scrollTo(([y]: number),([x]: number),([animated]: boolean),([duration]: number))：滚到指定位置时<br>scrollToEnd(([options]: {animated: boolean, duration: number}));滚到视图底部</p>
<h2 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h2><p>用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同<br>更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>
<h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><p>data：数据源<br>renderItem：返回重复的子组件<br>ItemSeparatorComponent：行与行之间的分隔线组件。不会出现在第一行之前和最后一行之后。值是一个组件<br>ListEmptyComponent：列表为空时渲染该组件。<br>ListHeaderComponent：头部组件<br>ListFooterComponent：尾部组件。<br>horizontal：设置为 true 则变为水平布局模式</p>
<p>extraData：如果有除data以外的数据用在列表中（不论是用在renderItem还是头部或者尾部组件中），请在此属性中指定。同时此数据在修改时也需要先修改其引用地址（比如先复制到一个新的 Object 或者数组中），然后再修改其值，否则界面很可能不会刷新。</p>
<p>initialNumToRender：指定一开始渲染的元素数量，最好刚刚够填满一个屏幕，这样保证了用最短的时间给用户呈现可见的内容。注意这第一批次渲染的元素不会在滑动过程中被卸载，这样是为了保证用户执行返回顶部的操作时，不需要重新渲染首批元素</p>
<p>initialScrollIndex:开始时屏幕顶端的元素是列表中的第 initialScrollIndex个元素, 而不是第一个元素。如果设置了这个属性，则第一批initialNumToRender范围内的元素不会再保留在内存里，而是直接立刻渲染位于 initialScrollIndex 位置的元素。需要先设置 getItemLayout 属性。</p>
<p>keyExtractor:此函数用于为给定的 item 生成一个不重复的 key。Key 的作用是使 React 能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。若不指定此函数，则默认抽取item.key作为 key 值。若item.key也不存在，则使用数组下标。</p>
<p>onEndReachedThreshold：决定当距离内容最底部还有多远时触发onEndReached回调。注意此参数是一个比值而非像素单位<br>refreshing：在等待加载新数据时将此属性设为 true，列表就会显示出一个正在加载的符号</p>
<h2 id="响应-4"><a href="#响应-4" class="headerlink" title="响应"></a>响应</h2><p>onEndReached：当列表被滚动到距离内容最底部不足onEndReachedThreshold的距离时调用<br>onRefresh：如果设置了此选项，则会在列表头部添加一个标准的RefreshControl控件，以便实现“下拉刷新”的功能。同时你需要正确设置refreshing属性<br>onViewableItemsChanged：在可见行元素变化时调用。可见范围和变化频率等参数的配置请设置viewabilityConfig属性<br>scrollToOffset()：滚动列表到指定的偏移（以像素为单位），等同于ScrollView的scrollTo方法。</p>
<h2 id="SectionList"><a href="#SectionList" class="headerlink" title="SectionList"></a>SectionList</h2><p>要渲染的是一组需要分组的数据，也许还带有分组标签的数据<br><a href="https://reactnative.cn/docs/sectionlist/" target="_blank" rel="noopener">文档</a></p>
<h1 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h1><p>Platform是一个模块，不是组件，用来进行平台检测<br>Platform.OS，在 iOS 上会返回ios，而在 Android 设备或模拟器上则会返回android。<br>Platform.select({ios:{},android:{}}) 可以以 Platform.OS 为 key，从传入的对象中返回对应平台的值<br>Platform.Version, Android 的 api level，值为数字，ios上为一个表示当前系统版本的字符串<br>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native 会检测某个文件是否具有.ios.或是.android.的扩展名，然后根据当前运行的平台自动加载正确对应的文件。<br>比如你可以在项目中创建下面这样的组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigButton.ios.js</span><br><span class="line">BigButton.android.js</span><br></pre></td></tr></table></figure></p>
<p>然后去掉平台扩展名直接引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import BigButton from &apos;./BigButton&apos;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>用于管理 iOS 和 Android 应用中的图片<br>图片文件的查找会和 JS 模块的查找方式一样,如果有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件<br>可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片，Packager 会打包所有的图片并且依据屏幕精度提供对应的资源，如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片。<br>为了使新的图片资源机制正常工作，require 中的图片名字必须是一个静态字符串（不能使用变量！因为 require 是在编译时期执行，而非运行时期执行！）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;;</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">var icon = this.props.active ? &apos;my-icon-active&apos; : &apos;my-icon-inactive&apos;;</span><br><span class="line">&lt;Image source=&#123;require(&apos;./&apos; + icon + &apos;.png&apos;)&#125; /&gt;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var icon = this.props.active</span><br><span class="line">  ? require(&apos;./my-icon-active.png&apos;)</span><br><span class="line">  : require(&apos;./my-icon-inactive.png&apos;);</span><br><span class="line">&lt;Image source=&#123;icon&#125; /&gt;;</span><br><span class="line">//通过这种方式引用的图片资源包含图片的尺寸（宽度，高度）信息，如果需要动态缩放图片（例如，通过 flex），可能必须手动在 style 属性设置&#123; width: null, height: null &#125;。</span><br></pre></td></tr></table></figure></p>
<p>require语法也可以用来静态地加载你项目中的声音、视频或者文档文件,包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等<br>注意的是视频必须指定尺寸而不能使用flex样式</p>
<p>要在 App 中显示的图片并不能在编译的时候获得，又或者有时候需要动态载入来减少打包后的二进制文件的大小。这些时候，与静态资源不同的是,需要手动指定图片的尺寸<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/logo-og.png&apos;&#125;&#125;</span><br><span class="line">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</span><br><span class="line">//或者 指定请求参数</span><br><span class="line">&lt;Image</span><br><span class="line">  source=&#123;&#123;</span><br><span class="line">    uri: &apos;https://facebook.github.io/react/logo-og.png&apos;,</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      Pragma: &apos;no-cache&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: &apos;Your Body goes here&apos;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  style=&#123;&#123;width: 400, height: 400&#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">//或者 引用base64</span><br><span class="line">&lt;Image</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    width: 51,</span><br><span class="line">    height: 51,</span><br><span class="line">    resizeMode: &apos;contain&apos;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  source=&#123;&#123;</span><br><span class="line">    uri:</span><br><span class="line">      &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==&apos;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">// 错误</span><br><span class="line">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/logo-og.png&apos;&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>读取本地静态图片（使用require(‘./my-icon.png’)语法）则无需指定尺寸，因为它们的尺寸在加载时就可以立刻知道。</p>
<h2 id="ImageBackground"><a href="#ImageBackground" class="headerlink" title="ImageBackground"></a>ImageBackground</h2><p>用于设置背景图，把需要背景图的子组件嵌入其中即可，需要设置大小</p>
<h1 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h1><p>导航器，控制跳转<br><a href="https://www.jianshu.com/p/a0ae81e1942a" target="_blank" rel="noopener">资料</a></p>
<h1 id="InteractionManager"><a href="#InteractionManager" class="headerlink" title="InteractionManager"></a>InteractionManager</h1><p>确保在执行繁重工作之前所有的交互和动画都已经处理完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InteractionManager.runAfterInteractions(() =&gt; &#123;</span><br><span class="line">  // ...需要长时间同步执行的任务...</span><br><span class="line">&#125;);</span><br><span class="line">//允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它</span><br><span class="line">var handle = InteractionManager.createInteractionHandle();</span><br><span class="line">// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)</span><br><span class="line">// 在动画完成之后</span><br><span class="line">InteractionManager.clearInteractionHandle(handle);</span><br><span class="line">// 在所有句柄都清除之后，现在开始依序执行队列中的任务</span><br></pre></td></tr></table></figure></p>
<p>requestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码<br>setImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。<br>runAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/reactNativeCreat.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/reactNativeCreat.html" itemprop="url">
                  react Native 环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-04T22:50:37+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实按照官网一步一步来就好了，也不用翻墙，基本上，就是耗时间<br>我配置的是window android环境<br><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">中文文档</a><br>1.安装node<br>可以直接使用nvm安装，但版本必须是8.<em>或者10.</em><br>带来的问题是，nvm切换版本后，npm可能找不到，可以直接用全局安装的yarn代替<br><a href="http://yuanhehe.cn/2017/06/11/npm-%E4%B8%8E-Yarn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/" target="_blank" rel="noopener">npm 与 Yarn 常用命令对比</a><br>或者直接将npm文件夹从能用的版本移到不能用的版本</p>
<p>2.python2<br>官网说不支持Python3.X,因为很早之前安装的python没管，今天一看是3.*，能跑起来</p>
<p>3.JDK<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载地址</a><br>我下载的这个<br><img src="/image/native1.png" alt="native1"><br>安装过程注意，jdk和jre使用不同文件夹<br><a href="https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html" target="_blank" rel="noopener">安装与环境配置</a><br>4.Android Studio<br>按文档步骤安装好后，需要先创建项目再创建虚拟机<br>构建虚拟机过程文档应该需要翻墙，但其实可以直接百度<br><a href="https://jingyan.baidu.com/article/3aed632edf252e701080911f.html" target="_blank" rel="noopener">构建虚拟机</a><br>相当于在PC上调试<br>5.链接真机测试<br>数据线链接手机和电脑，在git里跑’react-native run-android’<br>遇到的问题<br>1.第一次跑时，出现：unable to load script from assets<br> 解决如下：<br> 第一步：在Android/app/src/main目录下创建一个空的assets文件夹。<br> 第二步：执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</span><br></pre></td></tr></table></figure></p>
<p>再重新跑react-native run-android<br>2.摇晃手机reload 后：could not connect to development sever<br>华为手机andorid版本较低,4.*<br>点击dev setting，选择Debug server host&amp;port for device,填入PC电脑的IP地址和端口号<br>3.引入使用native-nivigation和react-native-gesture-handler后运行报错<br>settings file ‘E:\git\mobileApp\android\settings.gradle’: 3: unexpected char: ‘\’ @ line 3, column 1<br>解决： android下setiing.gradle,’\’换成‘/’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project(&apos;:react-native-gesture-handler&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-gesture-handler/android&apos;)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/performance/webpackdetail.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/performance/webpackdetail.html" itemprop="url">
                  webpack配置项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T16:21:02+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>webpack在启动后会从Entry里配置的Moudule开始，递归解析Entry依赖的所有Module，每找到一个module,就会根据配置的loader去找对应的转换规则，<br>对Module进行转换后，在解析当前Module依赖的Module。这些模块会以Entry为单位进行分组，一个Entry及其所有依赖Module被分到一个组，也就是一个Chunk<br>最后，webpack会将所有Chunk转换成文件输出。webpack会在恰当的时机执行Plugin里定义的逻辑</p>
<h1 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h1><p>入口，webpack执行构建的第一步将从Entry开始，可抽象成输入<br>配置：<br>方式1： 直接一个文件路径字符串：’./app/entry1’<br>方式2： 文件路径字符串数组：[‘./app/entry1’,’./app/entry2’]<br>方式3： 文件路径字符串对象：{A：’./app/entryA’,B:’./app/entryB’}<br>方式4： 函数，动态导出以上三种形式<br>方式1,2最后只会有一个文件会被导出，即导出一个Chunk,名为main<br>方式3导出多个Chunk,名称分别对应对象KEY值</p>
<h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>输出结果，在webpack经过一系列处理并得到最终想要的代码后输出结果<br>配置：</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p>输出文件名<br>方式1：静态，名字写死，如bundle.js，适用于只有一个导出Chunk，一个输出文件<br>方式2：利用Chunk内置变量，动态拼接生成文件名，例如’[name].js’<br>Chunk内置变量有：id,name,hash(name的hash,可指定长度，例如[hash:8]),chunkhash(chunk内容的hash)<br>相关：ExtractTextWebpackPlugin使用contenthash表示文件内容hash,但提取的内容为代码本身，不是一组模块组成的chunck内容</p>
<h2 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h2><p>无具体入口的chunk输出的文件名<br>例如通过commonChunkPlugin生成的文件，或者使用import动态加载生成的文件等<br>因为都是chunk输出文件，所以内置变量同filename的chunk</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>输出文件的存放目录<br>配置：绝对路径的字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="publishPath"><a href="#publishPath" class="headerlink" title="publishPath"></a>publishPath</h2><p>配置发布到线上资源的URL前缀<br>配置：字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="crossOriginloading"><a href="#crossOriginloading" class="headerlink" title="crossOriginloading"></a>crossOriginloading</h2><p>配置异步插入的script标签的crossorign值<br>配置：<br>anonymous，默认，不带cookie<br>use-credentials,加载时，带cookie</p>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>导出库的名称,与libraryTarget配合使用<br>配置：字符串</p>
<h2 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h2><p>以何种方式导出库<br>配置：以下字符串<br>‘var’|’commonjs’|’commonjs2’|’this’|’window’|’global’</p>
<h2 id="libraryExport"><a href="#libraryExport" class="headerlink" title="libraryExport"></a>libraryExport</h2><p>在libraryTarget配置’commonjs’|’commonjs2’时，配置导出模块中哪些子模块被导出</p>
<h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>模块处理规则</p>
<h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><p>数组，每一项是处理同一类文件的相关配置对象</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>处理哪些文件，文件名命中规则，<br>配置：字符串</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>在什么目录范围内匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>排除哪些目录范围，再匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>配置loader<br>loader可以看作具有文件转换功能的翻译员，告诉webpack在遇到哪些文件时使用哪些loader去加载和转换<br>配置：数组，每一项可以是是字符串，或者对象<br>默认执行顺序为数组倒序执行，即最末尾先执行<br>字符串：loader名称<br>对象：对于该loader的一些相关配置</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>配置：字符串，loader名</p>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>配置：对象，给loader处理函数传入的参数</p>
<h4 id="enforce"><a href="#enforce" class="headerlink" title="enforce"></a>enforce</h4><p>更改loader执行顺序<br>配置：<br>pre: 放在执行顺序最前面<br>post:放在执行顺序最后</p>
<h2 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h2><p>功能类似于exclude,排除不需要进行接续处理的文件，<br>此类文件中不能采用模块化方式编写，即不应包含import,require,define等语句，<br>否则导致无法在浏览器下执行<br>配置：字符串，文件路径</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>更细粒度地配置哪些语法被解析，哪些不被解析，精确到语法层面<br>{cmd:false,commonjs:false….}</p>
<h1 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h1><p>配置如何寻找模块对应的文件</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>通过将路径前缀指定别名，进行映射<br>配置：对象，key为别名，值为实际路径<br>例：{components：’./src/components’,…}</p>
<p>第三方模块一般会包含两套代码<br>一套采用comonjs规范的模块代码，这些文件都放在lib目录下，以package.json中指定的react.js为模块入口<br>一套是将React所有相关代码打包好的完整代码放到一个单独文件中，这些代码没有采用模块化，可以直接执行，<br>其中非压缩文件（dist/xxx.js）用于开发环境，里面包含检查和警告的代码，压缩的代码(dist/xxx.min.js)用于线上环境<br>默认情况下，webpack会从入口文件./node_module/xxx/xxx.js开始递归解析和处理依赖的几十个文件，会是一个耗时操作<br>可以通过配置reaolve.alias,让webpack处理第三方库时，直接使用单独完整的xxx.min.js，从而跳过耗时的递归解析操作</p>
<h2 id="mainFields"><a href="#mainFields" class="headerlink" title="mainFields"></a>mainFields</h2><p>决定优先使用第三方模块的哪份代码，按数组顺序查找，使用找到的第一份文件<br>默认值和target有关，<br>当target为web或者webwork时，值是[‘browser’,’module’,’main’]<br>当target为其他值时，值时[‘module’,’main’]<br>配置：第三方模块导出文件的关键字<br>例：[‘jsnext:main’,’brower’,’main’]</p>
<h2 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h2><p>导入语句没有带文件后缀时，尝试寻找的后缀代表<br>配置：后缀字符串数组<br>例：[‘.ts’,’.js’,’json’]</p>
<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>去哪些目录下寻找第三方模块，<br>默认node_modules 含义是先去当前目录的./node_module目录下找，如果没有找到，就去上一级目录../node_module中去找<br>再没有就去../../node_module中找，一次类推<br>配置：字符串数组<br>例：[‘.src/components’,’node_modules’],<br>可以直接在页面中import ‘.src/components’里面的模块，不用再写相对路径</p>
<h2 id="descriptionFiles"><a href="#descriptionFiles" class="headerlink" title="descriptionFiles"></a>descriptionFiles</h2><p>配置第三方模块名<br>配置：字符串数组</p>
<h2 id="enforceExtension"><a href="#enforceExtension" class="headerlink" title="enforceExtension"></a>enforceExtension</h2><p>是否强制导入语句中必须带后缀<br>true:必须带<br>false:不用必须带</p>
<h2 id="enforceModuleExtension"><a href="#enforceModuleExtension" class="headerlink" title="enforceModuleExtension"></a>enforceModuleExtension</h2><p>只对node_module文件夹下模块生效<br>通常设置false，与enforceExtension：true配合，兼容第三方模块，使用时不加后缀</p>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果或者做一些自定义的操作<br>比如将css文件单独打包，或者抽离公共模块<br>不使用plugin处理css文件的原理大概是将CSS内容用JS字符串存储起来，在网页执行JS时，通过DOM操作，动态向HTML head标签里插入HTML style标签<br>使用plugin将css抽离，是从打包好的js文件再提取出来<br>配置：plugin实例数组，使用new操作符调用构造函数，同时将参数传递进去<br>例：[new commonsChunkPlugin({name:’common’})]</p>
<h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><p>配置针对使用webpack-dev-server启动webpack时的一些配置，相当于配置webpack-dev-server<br>devServer 会启动一个http服务器，用于服务网页请求，<br>同时会启动webpack,将webpack构建的文件保存在内存中，在要访问输出的文件时，必须通过HTTP服务访问，<br>同时会开启webpack的监听模式，devServer会让webpack在构建出的js代码里注入一个代理客户端用于控制网页，<br>网页和devServer之间通过webSocket协议通信，以方便devServer主动向客户端发送命令，<br>devServer在收到来自webpack的文件变化通知时，通过注入的客户端控制自动刷新网页，做到实时预览。<br>1.由于devServer不会理会配置的output.path属性，所以获取打包文件时，应该依据HTTP获取，不再依据output.path获取<br>因此要注意使用devServer之后打包文件的获取路径要进行更改。<br>2.index.html因为脱离js模块化系统，webpack不知道它的存在，故，更改index.html，不会被监听到<br>3.除了通过重新刷新整个网页来实现预览，devServer还有一种被称作模块热替换的刷新技术。<br>模块热替换能做到在不重新加载整个网页的情况下，通过将已更新的模块替换老模块，再重新执行一次来实现实时预览。<br>模块热替换相对于默认的刷新机制能提供更快的响应速度和更好的开发体验。<br>可以在执行devServer时加上 –hot开启<br>4.启动webpack时，加上–devtool source-map 可生成souce-map，方便在浏览器中调试源代码</p>
<p>配置<br>hot是否开启热加载(热替换)<br>模块热替换原理：<br>类似于自动刷新，都需要向要开发的网页中注入一个代理客户端来连接DevServer和网页，区别在于热替换时会多出三个用于热替换的文件<br>在发生文件变化时，会重新生成一个用于替换老模块的补丁文件，补丁文件中会包含新编译的代码，页面会使用新编译的代码<br>当子模块发生更新时，更新事件会一层一层向上传递，会从根组件传递到main.js,直到有某层文件接收了当前变化的模块，<br>就会去执行自定义的逻辑，如果事件一直往上抛，到最外层都没有文件接收它，则会直接刷新网页，<br>最直观的就是修改main.js时，会发生整个页面刷新<br>而对于.css文件，在使用style-loader处理时会注入用于接收CSS的代码，所以在修改.css文件时，会触发模块热替换</p>
<p>inline<br>开启实现实时预览，自动刷新；<br>不开启，使用iframe方式运行开发的网页，需要去localhost:8080/webpack-dev-pack实时预览<br>historyApiFallback:用于H5History API单页应用开发<br>contentBase:devServer HTTP服务器文件根目录<br>headers:在HTTP响应中注入HTTP响应头<br>host:监听地址<br>port:监听端口<br>allowedHosts:只有HTTP请求的HOST在列表中才正常返回<br>disabledHostCheck:是否关闭用于DNS重新绑定的HTTP请求的HOST检查<br>https:是否运行在https上<br>clientloglevel:配置客户端日志等级</p>
<h1 id="target"><a href="#target" class="headerlink" title="target"></a>target</h1><p>构建不同运行环境的代码</p>
<h1 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h1><p>有很多选项可配置，选项之间可以随意组合<br>6个关键配置项：<br>eval:用eval语句包裹需要安装的模块<br>source-map:生成独立的Source Map文件<br>hidden：不在JS文件中指出 Source Map文件的位置，这样浏览器就不会自动加载Source Map<br>inline:将生成的Source Map转换成BASE64格式内嵌在JS文件中<br>cheap:在生成的Source Map文件中不会包含列信息，这样计算量更小，输出的Source Map文件更小，同时Loader输出的Source Map不会被采用<br>module:来自Loader的Source Map被简单的处理成每行一个模块</p>
<h2 id="‘source-map’"><a href="#‘source-map’" class="headerlink" title="‘source-map’"></a>‘source-map’</h2><p>仅设置source-map会造成以下两个问题<br>1.会输出质量最高且最详细的Source Map，会造成构建速度缓慢，特别是开发过程中需要频繁修改时会增加等待时间<br>2.会将Source Map暴露，若构建发布到线上代码的Source Map暴露等于源码被泄露<br>解决：<br>1.开发环境下将dev-tool设置成cheap-module-eval-source-map,因为生成这种Source Map的速度最快，能加速构建，<br>在开发环境下不会做代码压缩，所以在Source Map中即使没有列信息，也不会影响断点调试<br>2.生产环境下将dev-tool设置成hidden-source-map,生成最详细的Source Map，但不会将Source Map暴露出去<br>在生产环境会做代码压缩，一个JS文件只有一行，所以需要列信息</p>
<p>生产环境通常不会将Source Map上传到HTTP服务器让用户获取，而是上传到JS错误错误收集系统，<br>在错误收集系统上根据Source Map和收集到的JS运行错误堆栈，计算出错误所在源码位置</p>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>webpack是默认不会加载第三方模块附带的Source Map文件的，会在转换过程中生成Source Map，<br>为了让webpack加载这些第三方模块的Source Map，需要使用source-map-loader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">	test:/\.js$/,</span><br><span class="line">	include:[path.resolve(root,&apos;node_module/some-component&apos;)],</span><br><span class="line">	//加载Source Map时计算量很大，因此要避免让该Loader处理过多的文件，不然会导致构建变慢</span><br><span class="line">	use:[source-map-loader],</span><br><span class="line">	//要将source-map-loader的执行顺序放到最前面，</span><br><span class="line">	//如果在source-map-loader之前有Loader转换了该JS文件，就会导致Source Map映射错误</span><br><span class="line">	enforce:&apos;pre&apos;</span><br><span class="line">	&#125;]</span><br></pre></td></tr></table></figure></p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>是否开启监听文件变动模式</p>
<h1 id="watchOption"><a href="#watchOption" class="headerlink" title="watchOption"></a>watchOption</h1><p>配置监听规则,在开启监听模式时，才有用</p>
<p>ignore:不监听的文件/文件夹<br>aggregateTimeout:监听到变化发生后，等多少ms再去执行动作，截流，防止文件更新太快而导致重新编译的频率太快，默认为300ms<br>poll:判断文件是否发生变化是通过不停的询问系统指定文件有没有变化实现的，这里配置每秒询问多少次</p>
<p>文件监听原理：<br>默认情况下，webpack会从配置的Entry文件出发，递归出Entry文件依赖的文件，将这些依赖的文件都加入到监听列表中，而不是监听整个项目目录下的文件<br>然后对列表中每个文件都定时执行检查，定时获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后编辑时间不一致，<br>就认为该文件发生了变化，watchOption.poll控制定时检查的周期<br>文件发生变化后并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。watchOption.aggregateTimeout用于配置这个等待时间<br>这样做的目的就是在编辑代码过程可能会高频地输入文字，导致文件变化的时间高频发生，如果每次都重新执行构建，就会让构建卡死</p>
<h1 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h1><p>配置哪些模块不用被打包</p>
<h1 id="resolveloader"><a href="#resolveloader" class="headerlink" title="resolveloader"></a>resolveloader</h1><p>配置如何去寻找loader</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/psb.jpg" alt="YooHannah">
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">240</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
